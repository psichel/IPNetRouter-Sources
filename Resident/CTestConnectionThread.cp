// ===========================================================================//	CTestConnectionThread.cp й1997 Sustainable Softworks. All rights reserved.// ===========================================================================//	Thread object to test if reconnection is needed, that is,//	there is traffic for an on demand interface#include "CTestConnectionThread.h"#include "CResidentIfInfo.h"#include "CProxyControl.h"#include "CConnectionData.h"#include "CGatewayData.h"// Globalsextern CConnectionData*	gConnectionData;extern CGatewayData*	gGatewayData;extern CProxyControl*	gProxyControl;// ===========================================================================#pragma mark еее CTestConnectionThread еееCTestConnectionThread::CTestConnectionThread(	CResidentIfInfo*		inResInfo)		: LThread(false, thread_DefaultStack, threadOption_Default, nil)		  {	mResInfo = inResInfo;	mAbort = false;	mPauseSeconds = 0;	mPauseRepeat = false;}// ---------------------------------------------------------------------------//		е ~CTestConnectionThread// ---------------------------------------------------------------------------CTestConnectionThread::~CTestConnectionThread(){}// ---------------------------------------------------------------------------//		е Abort// ---------------------------------------------------------------------------voidCTestConnectionThread::Abort(){	if (!mAbort) {		mAbort = true;		if (this->GetState() == threadState_Suspended) this->Resume();		if (this->GetState() == threadState_Sleeping) this->Wake();	}}// ---------------------------------------------------------------------------//		е Pause// ---------------------------------------------------------------------------// Stop testing for on demand traffic for requested number of secondsvoidCTestConnectionThread::Pause(UInt32 inPauseSeconds){	mPauseSeconds = inPauseSeconds;	// set to try again after long pause is up	if (mPauseSeconds >= 300) mPauseRepeat = true;	// resume thread to set new sleep interval	if (this->GetState() == threadState_Suspended) this->Resume();	if (this->GetState() == threadState_Sleeping) this->Wake();}// ---------------------------------------------------------------------------//		е Run// ---------------------------------------------------------------------------void*CTestConnectionThread::Run(){	UInt32		delay;	mResult = kOTNoError;	while (!mAbort) {			// sleep for approximately one second		delay = 1000;		Sleep(delay);				if (mAbort) break;				// check for pause after series of retries have failed		while (mPauseSeconds) {			delay = mPauseSeconds*1000;	// wait pause seconds			mPauseSeconds = 0;			// reset pause			Sleep(delay);			if (mAbort) break;		}		if (mAbort) break;				// test for on demand traffic		mResult = gProxyControl->ProxyIoctl(I_OnDemandConnect, nil);		if ((mResult == kProxyOnDemand)					||			(gGatewayData->GetDataRemainConnected())	||			(mPauseRepeat)								) {			mPauseRepeat = false;			// change state so we don't allow multiples			gConnectionData->SetDataLinkState( kLinkStateConnecting );			// start connection attempt			mResult = mResInfo->ConnectPPP(nil);			// if connection attempt successfully launched			if (mResult == kOTNoError) {				// stop idling to test for reconnect				break;			}		}		}	SetResult(&mResult);	// set result so Object Master can retrieve it.	mResInfo->ObjectThreadDied(this);	return &mResult;}