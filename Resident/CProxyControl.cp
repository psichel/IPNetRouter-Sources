// =================================================================================//	CProxyControl.cp	 			©1997 Sustainable Softworks. All rights reserved.// =================================================================================//	Shared data and methods for accessing our Proxy STREAMS module#include "CompileFlags.h"#include "CProxyControl.h"#include "ProxyModule.h"#include "CInterfacesData.h"#include "CLogAction.h"#include "CTurboUDPEndpoint.h"#include "CIPRouterApp.h"#include "IPRouterCommon.h"		// pickup rPPob_GatewayWindow#include "CGatewayWindow.h"		// pickup kGatewayStateSize#include "MacSupport.h"#include "IPSupport.h"#include "Autopush.h"#include "MoreNetworkSetup.h"#include "NetworkSetupHelpers.h"#include <UModalDialogs.h>#include <LString.h>#include <LPreferencesFile.h>#include <UResourceMgr.h>#include <LThread.h>#include <OpenTransport.h>#include <OpenTptConfig.h>#include <OpenTptInternet.h>//#include <OpenTptLinks.h>#include <modnames.h>			// names of the standard OT modules.#include <OpenTptPPP.h>// Globalsextern CLogAction*			gLogAction;extern CInterfacesData*	 	gInterfacesData;extern UInt8				gApplicationMode;extern CIPRouterApp*		gAppObject;// ---------------------------------------------------------------------------------//		¥ CProxyControl()// ---------------------------------------------------------------------------------CProxyControl::CProxyControl(){	// initialization	isDoneInsertModule = false;	bzero((UInt8*)&mLastStamp, sizeof(OTTimeStamp));	// Proxy Control	mProxyEndpointRef = nil;	mProxyEndpoint = nil;}// ---------------------------------------------------------------------------------//		¥ ~CProxyControl// ---------------------------------------------------------------------------------CProxyControl::~CProxyControl(){	Terminate();	}// ---------------------------------------------------------------------------------//		¥ Terminate// ---------------------------------------------------------------------------------voidCProxyControl::Terminate(){	// Proxy Control	StopIdling();	if (mProxyEndpointRef) {		::OTCloseProvider(mProxyEndpointRef);		// ignore errors		mProxyEndpointRef = nil;	}	if (mProxyEndpoint) {		mProxyEndpoint->RemoveListener(this);		delete mProxyEndpoint;		mProxyEndpoint = nil;	}}voidCProxyControl::DoCleanup(){    Terminate();}#pragma mark --- Proxy Control ---// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------//	Listen for other notifications from endpoint//		BroadcastMessage(nextMessage->GetMessageType(), nextMessage);voidCProxyControl::ListenToMessage(	MessageT	inEventCode,	void		*ioParam ){	Str32		str;	switch ( inEventCode ) {					case kOTProviderWillClose:			gLogAction->LogText("\p\r### Network connection terminated.");			gLogAction->LogText("\p\r kOTProviderWillClose - Provider will close immediately.");			break;		case kOTProviderIsClosed:		case msg_BroadcasterDied:			break;		case kStreamIoctlEvent:			gLogAction->LogText("\p\rCProxyControl:  kStreamIoctlEvent");			break;		default:			gLogAction->LogText("\p\rCProxyControl unknown async message type: ");			IP_NumToHexStr(inEventCode, str);			gLogAction->LogText(str);	}}// ---------------------------------------------------------------------------//		¥ SpendTime// ---------------------------------------------------------------------------//	Periodical function to Age Filter TablevoidCProxyControl::SpendTime(const EventRecord &inMacEvent){#pragma unused (inMacEvent)	struct strioctl		stri;	proxy_age_t			proxyAge;	OTResult			result;	UInt32 				deltaTime;	// if more than 30 second since we last aged the Filter table	deltaTime = OTElapsedMilliseconds(&mLastStamp);	if (deltaTime > 30000) {		::OTGetTimeStamp(&mLastStamp);		// age Filter table		proxyAge.age = 240;	//  2 hours				proxyAge.portNameHash = 0;		SetupIoctl(&stri, I_AgeFilterTable, (char*)&proxyAge, sizeof(proxy_age_t));		result = ProxyIoctl(I_STR, &stri);		if (result != kProxyNoError) {			gLogAction->LogText("\p\rCProxyControl - Age Filter table error ", result);		}	}}// ---------------------------------------------------------------------------------//		¥ ProxyConnect// ---------------------------------------------------------------------------------//	Setup to connect with our Proxy modulevoidCProxyControl::ProxyConnect(){				// Register module as a streams Driver so we can open a control stream to it	SetupPort();	// Create a connectionless endpoint to communicate with	// our "Proxy" driver	if (!mProxyEndpoint) {		mProxyEndpoint = new CTurboUDPEndpoint("Proxy");		ThrowIfNil_(mProxyEndpoint);		// Register to receive other event notifications (including Ioctl responses)		mProxyEndpoint->AddListener(this);	}	StartIdling();}// ---------------------------------------------------------------------------//		¥ SetupPort// ---------------------------------------------------------------------------//	SetupPort for my Streams modulevoidCProxyControl::SetupPort(){	OSStatus		err = kOTNoError;	OTPortRecord	portInfo, my_record;	//OTPortRef 	childPortRef;	UInt32			index;	LStr255 		str, messageText;		// Try to register our driver module (if not already registered)		if ( !OTFindPort(&portInfo, "Proxy") ) {		portInfo.fRef = OTCreatePortRef(0, kOTPseudoDevice, 0, 0);		portInfo.fPortFlags = 0;		portInfo.fInfoFlags = kOTPortIsTPI;		portInfo.fCapabilities = 0;		// Find child's port ref		portInfo.fNumChildPorts = 0;		portInfo.fChildPorts = nil;		// set port name and module name		SmallStrCopy((UInt8*)portInfo.fPortName, "Proxy");		SmallStrCopy((UInt8*)portInfo.fModuleName, "Proxy");		portInfo.fSlotID[0] = 0;		//OTStrCopy((UInt8*)portInfo.fSlotID, "Proxy");		portInfo.fResourceInfo[0] = 0;		bzero((UInt8*)portInfo.fReserved, 164);		err = OTRegisterPort(&portInfo, nil);		if (err != kOTNoError ) {			gLogAction->LogText("\p\rERROR: Register Port failed with ", err);		}	}	if (false) {		// get information on available ports		index = 0;		while ( OTGetIndexedPort(&my_record, index) ) {			messageText = "\p\r\rPort Record info for port ";			NumToString(index, str);			messageText += str;			gLogAction->LogText(messageText);						messageText = "\p\rName: ";			str.Assign(my_record.fPortName);			messageText += str;			gLogAction->LogText(messageText);						//fprintf(stderr, "InfoFlags: %08x\n", my_record.fInfoFlags);			messageText = "\p\rInfoFlags: ";			IP_NumToHexStr(my_record.fInfoFlags, str);			messageText += str;			gLogAction->LogText(messageText);			//fprintf(stderr, "NumChildPOrts: %08x\n", my_record.fNumChildPorts);			messageText = "\p\rNumChildPOrts: ";			NumToString(my_record.fNumChildPorts, str);			messageText += str;			gLogAction->LogText(messageText);			//fprintf(stderr, "Module Name: %s\n", my_record.fModuleName);			messageText = "\p\rModule Name: ";			str.Assign(my_record.fModuleName);			messageText += str;			gLogAction->LogText(messageText);			index += 1;		}	}}// ---------------------------------------------------------------------------//		¥ SetupStream// ---------------------------------------------------------------------------// Setup to insert our proxy module// in subsequent link stacks created by InetConfiguratorvoidCProxyControl::SetupStream(){			// get "Use Network Setup" resource	UInt8 state = 1;	UOpenTptSupport::StartOpenTransport();#if powerc	// Try to use the Configuration Database if available		// otherwise just munge the prefs file	if ( IsNetworkSetupAvailable() && state) {		NSInsertModule();	} else {		PFInsertModule();	}#else	PFInsertModule();#endif}// ---------------------------------------------------------------------------//		¥ NSInsertModule// ---------------------------------------------------------------------------//	Configure OT to plumb our Proxym module below IP.////	In contrast to PFInsertModule below, this method uses the//	supported technique of accessing the Configuration Database//	available under Mac OS 8.5 and later to modify the 'crpt'//	preference within the current TCP/IP network connection entity.//	Of course the 'crpt' preference is still not officially supported,//	but modifying network parameters using the configuration database//	is supported and has the major benefit of rebuilding the link//	stream when changes are committed, thereby avoiding the possible//	need to restart////  For OT2.5 or later, we use the 'blip' (below IP) resource instead//  of 'crpt'.  The 'blip' resource is like a 'STR#' containing a list//  of modules to insert below IP.////	Function Outline://		Open Configuration DB//		Find Current Connection//			Find Active Set//			Iterate Active Set to find TCP/IP network connection entity//		Write 'crpt' preference for this entity//		Close Configuration DB and commit changes////	Use Quinn's "More Network Setup" and "Network Setup Helpers"//	supplied by Apple DTS.////	Additional Work Needed://		Try to remove the 'crpt' preference when we're done to//			clean up after ourselves.//		Iterate over all TCP/IP network connection entities//		to remove any previous 'crpt' preferences that point to//		"Proxym".//voidCProxyControl::NSInsertModule(){	OSStatus err;	MNSDatabadeRef ref;	CfgEntityRef currentEntity;	Str255*		bufferPtr;	Str255		buffer;	ByteCount	prefSize;	Str63		str;	Boolean		closeDB;	Boolean		commit;	bufferPtr = nil;	prefSize = 0;	closeDB = false;	commit = false;		do {				if (gApplicationMode & kModeWamnet) break;				// check if already configured to avoid slow Network Setup		UInt8 present = PFCheckModule();		if ((present == 1) || (present == 2)) {			if (!OptionKeyDown()) break;	// Option forces update		}		// open Config DB for writing		err = MNSOpenDatabase(&ref, true);		if (err != noErr) {			gLogAction->LogText("\p\rUnexpected result while opening Configuration DB: ", err);			break;		}		closeDB = true;				// find TCP/IP network connection entity		err = NSHFindCurrentConnection(&ref, kOTTCPv4NetworkConnection, &currentEntity);		if (err != noErr) {			gLogAction->LogText("\p\rUnexpected result finding current TCP connection: ", err);			break;		}				// check for a 'crpt' resource already present		err = MNSGetPref(&ref, &currentEntity, (OSType)'crpt',	(void**)&bufferPtr, &prefSize);		if ((err == noErr) && (prefSize <= 255)) {			// transfer to our own buffer			::BlockMove(bufferPtr, buffer, prefSize);			if (buffer[0]) {						// tell user what we found				gLogAction->LogText("\p\rThe TCP/IP Preferences resource needed for IPNetRouter was ");				gLogAction->LogText(buffer);			}		}		// cleanup for next customer		if (bufferPtr != nil) {			DisposePtr((char*)bufferPtr);			bufferPtr = nil;		}		if ( !IsOT25() || (present & 1) ) {			// Use 'crpt' if pre Open Transport 2.5				// update Network Setup if 'crpt' present in Prefs			LString::CopyPStr(kProxyModuleName, str, sizeof(Str63));			// write our 'crpt'			prefSize = str[0]+1;			str[prefSize] = 0;	// pad with zero's to multiple of 4 bytes			err = MNSSetPref(&ref, &currentEntity, (OSType)'crpt', str, kModuleNameSize);			if (err != noErr) {				gLogAction->LogText("\p\rUnexpected result setting 'crpt' for current TCP connection: ", err);				break;			}		}		else {			// OT2.5 and 'crpt' not found in prefs			if (::EqualString(buffer, kProxyModuleName, false, false) && !(present & 1)) {				// remove 'crpt' if found in Network Setup				str[0] = 0;				err = MNSSetPref(&ref, &currentEntity, (OSType)'crpt', str, 1);			}			if (err != noErr) {				gLogAction->LogText("\p\rUnexpected result removing 'crpt' for current TCP connection: ", err);				//break;	// don't skip below			}		}		// OT 2.5 or later, try to use 'blip'		if ( IsOT25() ) {			short	numStrings;			short	strIndex;			short	strOffset;			Boolean	found;			Boolean last;			UInt8	len, rem;			// check for a 'blip' resource already present			err = MNSGetPref(&ref, &currentEntity, (OSType)'blip',	(void**)&bufferPtr, &prefSize);			if ((err == noErr) && (prefSize <= 255)) {				// found 'blip' resource				// transfer to our own buffer				::BlockMove(bufferPtr, buffer, prefSize);				// get # of strings in STR#				::BlockMove(buffer, &numStrings, sizeof(short));				// check if our module is already in list				strIndex = 1;				strOffset = 2;				found = false;				last = true;				while (strIndex <= numStrings) {					LString::CopyPStr(&buffer[strOffset], str, sizeof(Str63));					if (::EqualString(str, kProxyModuleName, true, true)) {						found = true;						if (strIndex < numStrings) last = false;						break;					}					strIndex += 1;					strOffset += str[0] + 1;				}			} else {				// initialize 'blip'				buffer[0] = 0;				buffer[1] = 0;				prefSize = 2;				numStrings = 0;			}			// if found 'blip', last in list, and no 'crpt', just exit			if (found && last && (present == 2)) break;			// If found 'blip' and 'crpt' is present or not last, remove 'blip'			if ( found && ((present & 1) || !last) ) {				// remove our module from 'blip' list									// get # of strings in STR#				::BlockMove(buffer, &numStrings, sizeof(short));					// remove each instance in list				strIndex = 1;				strOffset = 2;				while (strIndex <= numStrings) {					LString::CopyPStr(&buffer[strOffset], str, sizeof(Str63));					if (::EqualString(str, kProxyModuleName, true, true)) {							// move any remaining data back to fill in space						len = str[0] + 1;						rem = prefSize-(strOffset+len);						if (rem) ::BlockMove(&buffer[strOffset+len], &buffer[strOffset], rem);							// adjust STR# count						numStrings -= 1;						::BlockMove(&numStrings, buffer, sizeof(short));							// adjust resource size						prefSize -= len;									} else {						strIndex += 1;						strOffset += str[0] + 1;					}				}			}			// if 'blip' not found or not last, and no 'crpt', add our module to blip			if ( (!found || !last) && !(present & 1) ) {			    if (true) {    				// insert our module at end of 'blip' list    				len = kProxyModuleName[0] + 1;	// include PString len    					// add our name to list    				::BlockMove(kProxyModuleName, &buffer[prefSize], len);    					// adjust STR# count    				numStrings += 1;    				::BlockMove(&numStrings, buffer, sizeof(short));    					// adjust resource size    				prefSize += len;                } else {    				// insert our module at front of 'blip' list    					// move data forward to make room    				len = kProxyModuleName[0] + 1;	// include PString len    				::BlockMove(&buffer[2], &buffer[len+2], prefSize-2);    					// add our name to list    				::BlockMove(kProxyModuleName, &buffer[2], len);    					// adjust STR# count    				numStrings += 1;    				::BlockMove(&numStrings, buffer, sizeof(short));    					// adjust resource size    				prefSize += len;                }			}			// write our 'blip' (update Network Setup even if no changes)			err = MNSSetPref(&ref, &currentEntity, (OSType)'blip', &buffer, prefSize);			if (err != noErr) {				gLogAction->LogText("\p\rUnexpected result setting 'blip' for current TCP connection: ", err);				break;			}		}		commit = true;				} while (false);			// clean up		if (closeDB) MNSCloseDatabase(&ref, commit);	if (bufferPtr != nil) DisposePtr((char*)bufferPtr);	}// ---------------------------------------------------------------------------//		¥ PFInsertModule// ---------------------------------------------------------------------------//	Configure OT to plumb our Proxym module below IP.////	This module uses the undocumented and unsupported hook of//	placing a 'crpt' resource in the "TCP/IP Preferences" file with//	rerource ID matching the desired TCP/IP configuration and//	containing a pstring with the name of our module "Proxym"//	to be plumbed below IP.////	The four resources used in the TCP/IP Preferences file are://	'ccfg'	resource ID of the selected configuration//	'cnam'	the resource name is the name of the selected configuration//	'crpt'	pstring name of module to plumb below IP//	'port'	the OT registered port (DLPI) to use//voidCProxyControl::PFInsertModule(){	FSSpec 				fss;	LPreferencesFile*	prefsFile;	SInt16				cfg_id, id;	Str32				portStr, moduleStr;	Str255				nameStr;	LStr255				messageStr;	Handle				resH;	OSStatus			err = kOTNoError;	if (!(gApplicationMode & kModeWamnet)) {				// Get TCP/IP Preferences file		err = FindTCPPrefFile(&fss);		if (err != noErr) return;		// Open the TCP/IP Preferences resource fork		prefsFile = new LPreferencesFile(fss);		ThrowIfNil_( prefsFile );		prefsFile->OpenOrCreateResourceFork(			fsCurPerm, (OSType)'ztcp', (OSType)'pref', smRoman ); // privs, creator, type, script				do {	// begin scope for resource objects					// If the current configuration is connecting via PPP,			// we can use autopush which is supported, so just get out.					// get selected configuration			StResource ccfgR( (ResType)'ccfg',				1, false, true );			// inThrowFail, inGet1Resource			if (!ccfgR.mResourceH) break;	//  resource doesn't exist, get out			cfg_id = *(UInt16*)(*ccfgR.mResourceH);					// get port			StResource portR( (ResType)'port',				cfg_id, false, true );		// inThrowFail, inGet1Resource			if (!portR.mResourceH) break;	//  resource doesn't exist, get out			LString::CopyPStr( (UInt8*)*portR.mResourceH, portStr, sizeof(portStr) );			// test if STREAM is already configured			StResource crptR( (ResType)'crpt',				cfg_id, false, true );		// inThrowFail, inGet1Resource			if (crptR.mResourceH) {			//  resource exists				LString::CopyPStr( (UInt8*)*crptR.mResourceH, moduleStr, sizeof(moduleStr) );				if (::EqualString(moduleStr, "\pProxym", true, true)) break;			}			// get configuration name			StResource cnamR( (ResType)'cnam',				cfg_id, false, true );		// inThrowFail, inGet1Resource			if (cnamR.mResourceH) {			//  resource exists				ResType theType;				GetResInfo(cnamR.mResourceH, &id, &theType, nameStr);			}						// ask user if it's OK to reconfigure			gLogAction->LogText("\p\rCProxyControl: Proxy Services may not be available until after restart.");//			StDialogHandler dialog(rPPob_ChangeMonitor, mLogWindow);//			LCaption* theCaption = (LCaption*) dialog.GetDialog()->FindPaneByID(kConfigCaption);//			ThrowIfNil_( theCaption );//			messageStr = nameStr;//			messageStr += "\p via: ";//			messageStr += portStr;//			theCaption->SetDescriptor(messageStr);//			MessageT hitMessage;//			while (true) {//				hitMessage = dialog.DoDialog();//				if ((hitMessage == msg_Cancel) || (hitMessage == msg_OK)) break;//				if (hitMessage != 0) {//					gLogAction->LogText("\p\rHit message is: ", hitMessage);//				}//			}//			if (hitMessage == msg_Cancel) break;						// remove old 'crpt' configuration if any			for (id=128; id<144; id++) {				if ( ECGetResource((OSType)'crpt', (short)id, &resH) == noErr ) {					if ( ::EqualString((UInt8*)*resH, "\pProxym", true, true) )						::RemoveResource(resH);					else					    ::ReleaseResource((Handle)resH);				}			}						// create new 'crpt' configuration			StNewResource crptRNew( (ResType)'crpt',				cfg_id, kModuleNameSize, true );	// inDefaultSize, inGet1Resource			if (crptRNew.mResourceH) {		//  resource created				LString::CopyPStr( "\pProxym", (UInt8*)*crptRNew.mResourceH, kModuleNameSize );			}								} while (false);	// end scope for resource objects (write out any changes)				// close preferences file		// *** caution only close file after resource objects are out of scope		prefsFile->CloseResourceFork();		delete prefsFile;	}}// ---------------------------------------------------------------------------//		¥ PFCheckModule// ---------------------------------------------------------------------------//	Check if OT is Configured to plumb our Proxym module below IP.////	This module uses the undocumented and unsupported hook of//	checking for a 'crpt' resource in the "TCP/IP Preferences" file with//	rerource ID matching the desired TCP/IP configuration and//	containing a pstring with the name of our module "Proxym"//	to be plumbed below IP.////	The four resources used in the TCP/IP Preferences file are://	'ccfg'	resource ID of the selected configuration//	'cnam'	the resource name is the name of the selected configuration//	'crpt'	pstring name of module to plumb below IP//	'port'	the OT registered port (DLPI) to use////	For OT2.5 or later, also check for blip.  Returns://	0 found neither//	1 found crpt//	2 found blip//	3 found bothUInt8CProxyControl::PFCheckModule(){	FSSpec 				fss;	LPreferencesFile*	prefsFile = nil;	SInt16				cfg_id;	Str63				moduleStr;	LStr255				messageStr;	OSStatus			err = kOTNoError;	Boolean				found_crpt = false;	Boolean				found_blip = false;	UInt8				result = 0;				do {	// begin scope for resource objects		// Get TCP/IP Preferences file		err = FindTCPPrefFile(&fss);		if (err != noErr) break;		// Open the TCP/IP Preferences resource fork		prefsFile = new LPreferencesFile(fss);		if (prefsFile == nil) break;		prefsFile->OpenOrCreateResourceFork(			fsCurPerm, (OSType)'ztcp', (OSType)'pref', smRoman ); // privs, creator, type, script			// get selected configuration		StResource ccfgR( (ResType)'ccfg',			1, false, true );			// inThrowFail, inGet1Resource		if (!ccfgR.mResourceH) break;	//  resource doesn't exist, get out		cfg_id = *(UInt16*)(*ccfgR.mResourceH);		// test if STREAM is already configured		StResource crptR( (ResType)'crpt',			cfg_id, false, true );		// inThrowFail, inGet1Resource		if (crptR.mResourceH) {			//  resource exists			LString::CopyPStr( (UInt8*)*crptR.mResourceH, moduleStr, sizeof(moduleStr) );			if (::EqualString(moduleStr, kProxyModuleName, true, true)) {				found_crpt = true;			}		}						// for OT 2.5, test if configured using 'blip'		if (IsOT25()) {			Str255	buffer;			UInt32	size;			short	numStrings;			short	strIndex;			short	strOffset;			StResource blipR( (ResType)'blip',				cfg_id, false, true );		// inThrowFail, inGet1Resource			if (blipR.mResourceH) {			//  resource exists				// copy 'blip' resource to our own buffer				size = ::GetHandleSize(blipR.mResourceH);				if (size <= 255) {					::BlockMove((UInt8*)*blipR.mResourceH, buffer, size);					// get # of strings in STR#					::BlockMove(buffer, &numStrings, sizeof(short));					// check if our module is already in list					strIndex = 1;					strOffset = 2;					while (strIndex <= numStrings) {						LString::CopyPStr(&buffer[strOffset], moduleStr, sizeof(Str63));						if (::EqualString(moduleStr, kProxyModuleName, true, true)) {							found_blip = true;	// already in list							break;						}						strIndex += 1;						strOffset += moduleStr[0] + 1;					}				}			}				}			} while (false);	// end scope for resource objects (write out any changes)		// close preferences file	// *** caution only close file after resource objects are out of scope	if (prefsFile) {		prefsFile->CloseResourceFork();		delete prefsFile;	}	result = 0;	if (found_crpt) result = 1;	if (found_blip) result |= 2;	return result;}// ---------------------------------------------------------------------------------//		¥ ProxyIoctl// ---------------------------------------------------------------------------------//	Send synchronous ioctl to Proxy moduleOTResultCProxyControl::ProxyIoctl(UInt32 inCmd, void* inData){	OTResult		result;	TEndpointInfo	info;		// Make sure we have an endpoint to communicate with our "Proxy" driver	if (!mProxyEndpointRef) {		UOpenTptSupport::StartOpenTransport();		SetupPort();	// make sure port is registered		mProxyEndpointRef = ::OTOpenEndpoint(::OTCreateConfiguration("Proxy"), 0, &info, &result);		ThrowIfError_(result);	}	// make sure it's synchronouse	::OTSetSynchronous(mProxyEndpointRef);	::OTSetBlocking(mProxyEndpointRef);			// issue requested ioctl	result = ::OTIoctl(mProxyEndpointRef, inCmd, inData);	return result;}// ---------------------------------------------------------------------------------//		¥ AsyncOpenAndClose// ---------------------------------------------------------------------------------//	Perform asynchronous endpoint open to force InetConfigurator to firetypedef struct	{	OTResult		asyncResult;	EndpointRef		asyncEndpointRef;	} AsyncOpenInfo;OTResultCProxyControl::AsyncOpenAndClose(){	TEndpointInfo	myEndpointInfo;	OSStatus result;	UOpenTptSupport::StartOpenTransport();	AsyncOpenInfo info = { 1,  nil };		//DebugStr("\pBegin Async Open");	result = ::OTAsyncOpenEndpoint(::OTCreateConfiguration("tcp"), 0, &myEndpointInfo,					 (OTNotifyProcPtr) Int_NotifierProc, &info);	while (result == kEAGAINErr) {		gAppObject->ProcessNextEvent();		result = ::OTAsyncOpenEndpoint(::OTCreateConfiguration("tcp"), 0, &myEndpointInfo,						 (OTNotifyProcPtr) Int_NotifierProc, &info);	}	if (result == kOTNoError) {		//DebugStr("\pAsync Open waiting");		while (info.asyncResult == 1) {			gAppObject->ProcessNextEvent();		}				//DebugStr("\pAsync Open complete");		if (info.asyncResult == kOTNoError) {			::OTCloseProvider(info.asyncEndpointRef);		}		//DebugStr("\pAsync Close complete");	}		return info.asyncResult;}// ---------------------------------------------------------------------------//		¥ NotifierProc// ---------------------------------------------------------------------------pascal voidCProxyControl::Int_NotifierProc(	void*			inContextPtr,	OTEventCode		inEventCode,	OTResult		inResult,	void*			inCookie){	if (inEventCode == T_OPENCOMPLETE) {		//DebugStr("\pCProxyControl::Int_NotifierProc got T_OPENCOMPLETE");		AsyncOpenInfo *info = (AsyncOpenInfo*)inContextPtr;		info->asyncResult      = inResult;		info->asyncEndpointRef = (EndpointRef)inCookie;	}	//else DebugStr("\pCProxyControl::Int_NotifierProc got unexpected event code");}