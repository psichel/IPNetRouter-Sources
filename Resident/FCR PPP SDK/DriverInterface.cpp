/* 	DriverInterface.cpp: Class that enables interaction with FCR PPP Driver.    	   	This document contains proprietary information developed by    		FCR Software Inc.   		222 Third Street, Suite 3130   		Cambridge, MA 02142   		   	and should not be distributed, copied, or disclosed without explicit   	permission of FCR Software, Inc..   	   	You may use this document and the source herein for developing    	applications that use the LinkUPPP! (FCR PPP) driver.   	   	NOTE: This code assumes that the user has set up a connection document   	properly, and configured the driver with it (i.e. used it most recently   	to make a connection, or selected Configure Driver from the File menu   	in LinkUPPP!.	Copyright 1997-98 FCR Software, Inc.		November 6, 1997 - Jessica Kahn <jess@fcr.com>*/#include <Devices.h>#include "TradDriverLoaderLib.h"#include "ppp_api.h"#include "DriverInterface.h"// ---------------------------------------------------------------------------//		¥ DriverInterface() 	//			Default Constructor - assumes driver name is .PPP// ---------------------------------------------------------------------------DriverInterface::DriverInterface() { 	mUnitNum = 0;	mDriverName = (StringPtr)PPP_DRVR_NAME;}// ---------------------------------------------------------------------------//		¥ DriverInterface(StringPtr inDriverName)  //			Constructor - takes driver name as param.// ---------------------------------------------------------------------------DriverInterface::DriverInterface(StringPtr inDriverName){	mUnitNum = 0;	mDriverName = inDriverName;}// ---------------------------------------------------------------------------//		¥ ~DriverInterface() 	//			Destructor - does nothing// ---------------------------------------------------------------------------DriverInterface::~DriverInterface(){}// ---------------------------------------------------------------------------//		¥ IsIPCPUp() 	//			True if IPCP is up, false if not// ---------------------------------------------------------------------------Boolean DriverInterface::IsIPCPUp(){	OSErr errCode;		// Set up pointer to driver's status information	PPPStatusBlock * theStatusBlk;	theStatusBlk = (PPPStatusBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	theStatusBlk->mode = -1;	theStatusBlk->message = (char *)0;		// Grab driver status information	PrepCntrlParam(D_STAT_GETSTATUS);	errCode = ::PBStatusSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);		ThrowIfOSErr_(errCode);	// If PPP is framing, see about IPCP's status	if (theStatusBlk->mode == STATUS_PPP) {		for (int i = 0; i < PPP_MAX_PROTOCOL; i++) {			if (theStatusBlk->cp[i].cp_name == 'IPCP' && 				theStatusBlk->cp[i].cp_status == OPEN) {				return true;			}		}	}//	else		return false;	}// ---------------------------------------------------------------------------//		¥ IsATCPUp() 	//			True if ATCP is up, false if not// ---------------------------------------------------------------------------Boolean DriverInterface::IsATCPUp(){	OSErr errCode;		// Set up pointer to driver's status information	PPPStatusBlock * theStatusBlk;	theStatusBlk = (PPPStatusBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	theStatusBlk->mode = -1;	theStatusBlk->message = (char *)0;		// Grab driver status information	PrepCntrlParam(D_STAT_GETSTATUS);	errCode = ::PBStatusSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);		ThrowIfOSErr_(errCode);		// If PPP is framing, see about ATCP's status	if (theStatusBlk->mode == STATUS_PPP) {		for (int i = 0; i < PPP_MAX_PROTOCOL; i++) {			if (theStatusBlk->cp[i].cp_name == 'ATCP' && 				theStatusBlk->cp[i].cp_status == OPEN) {				return true;			}		}	}//	else		return false;}// ---------------------------------------------------------------------------//		¥ IsHeaderCompOn() 	//			True if TCP header compression is on, false if not// ---------------------------------------------------------------------------Boolean DriverInterface::IsHeaderCompOn(){	OSErr errCode;//	int isOn;		// Set up pointer to information about protocol negociation	NCPQueryBlock * theQueryPtr;			theQueryPtr = (NCPQueryBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	// Choose to find out about IPCP	theQueryPtr->protocol = PPP_IPCP;	theQueryPtr->pointer = (Ptr)&mIPCPBlk;	theQueryPtr->size = sizeof(mIPCPBlk);		// Get NCP state information from driver	PrepCntrlParam(D_CTRL_GETSTATE_NCP);	errCode = ::PBControlSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);	ThrowIfOSErr_(errCode);		if (mIPCPBlk.ipcp_tcp_hdr_comp)		return true;	else		return false;}// ---------------------------------------------------------------------------//		¥ GetDriverStatus() 	//			Returns driver status. From ppp_api.h, possible values are://	//			STATUS_IDLE		0			Script idle//  		STATUS_INIT		1			Initializing//			STATUS_SCRIPT	2			Running script//  		STATUS_STALLED	3			Script stalled waiting for free iopb//			STATUS_DONE		4			Script done; result in result//			STATUS_RECYCLE	5			Recycling serial port//			STATUS_FAULT	6			Script faulted due to script error//			STATUS_TIMEOUT	7			Link coming down due to idle-timeout//			STATUS_CLOSING	8			Link coming down//			STATUS_PPP		10			Framing, PPP//			STATUS_SLIP		11			Framing, SLIP// ---------------------------------------------------------------------------short DriverInterface::GetDriverStatus(){	OSErr errCode;		// Set up pointer to driver's status information	PPPStatusBlock * theStatusBlk;	theStatusBlk = (PPPStatusBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	theStatusBlk->mode = -1;	theStatusBlk->message = (char *)0;		// Grab driver status information	PrepCntrlParam(D_STAT_GETSTATUS);	errCode = ::PBStatusSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);	ThrowIfOSErr_(errCode);		return theStatusBlk->mode;}// ---------------------------------------------------------------------------//		¥ GetScriptResult() 	//			Returns code for ccl script result -- see all #defined items//			starting with "SCRIPT_" in ppp_api.h for possible values// ---------------------------------------------------------------------------short DriverInterface::GetScriptResult(){	OSErr errCode;		// Set up pointer to driver's status information	PPPStatusBlock * theStatusBlk;	theStatusBlk = (PPPStatusBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	theStatusBlk->message = (char *)0;		// Grab driver status information	PrepCntrlParam(D_STAT_GETSTATUS);	errCode = ::PBStatusSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);	ThrowIfOSErr_(errCode);		return theStatusBlk->result;}// ---------------------------------------------------------------------------//		¥ GetClientIP() 	//			Returns negociated client IP address// ---------------------------------------------------------------------------long DriverInterface::GetClientIP(){	OSErr errCode;		// Set up pointer to information about protocol negociation	NCPQueryBlock * theQueryPtr;			theQueryPtr = (NCPQueryBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	// Choose to find out about IPCP	theQueryPtr->protocol = PPP_IPCP;	theQueryPtr->pointer = (Ptr)&mIPCPBlk;	theQueryPtr->size = sizeof(mIPCPBlk);		// Get NCP state information from driver	PrepCntrlParam(D_CTRL_GETSTATE_NCP);	errCode = ::PBControlSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);	ThrowIfOSErr_(errCode);		return mIPCPBlk.ipcp_local_addr;}// ---------------------------------------------------------------------------//		¥ GetServerIP() 	//			Returns server's IP address// ---------------------------------------------------------------------------long DriverInterface::GetServerIP(){	OSErr errCode;		// Set up pointer to information about protocol negociation	NCPQueryBlock * theQueryPtr;			theQueryPtr = (NCPQueryBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	// Choose to find out about IPCP	theQueryPtr->protocol = PPP_IPCP;	theQueryPtr->pointer = (Ptr)&mIPCPBlk;	theQueryPtr->size = sizeof(mIPCPBlk);		// Get NCP state information from driver	PrepCntrlParam(D_CTRL_GETSTATE_NCP);	errCode = ::PBControlSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);	ThrowIfOSErr_(errCode);			return mIPCPBlk.ipcp_remote_addr;}// ---------------------------------------------------------------------------//		¥ GetPrimaryDNS() 	//			Returns IP address of primary DNS// ---------------------------------------------------------------------------long DriverInterface::GetPrimaryDNS(){	OSErr errCode;		// Set up pointer to information about protocol negociation	NCPQueryBlock * theQueryPtr;			theQueryPtr = (NCPQueryBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	// Choose to find out about IPCP	theQueryPtr->protocol = PPP_IPCP;	theQueryPtr->pointer = (Ptr)&mIPCPBlk;	theQueryPtr->size = sizeof(mIPCPBlk);		// Get NCP state information from driver	PrepCntrlParam(D_CTRL_GETSTATE_NCP);	errCode = ::PBControlSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);	ThrowIfOSErr_(errCode);			return mIPCPBlk.ipcp_primary_dns;}// ---------------------------------------------------------------------------//		¥ GetSecondaryDNS() 	//			Returns IP address of secondary DNS// ---------------------------------------------------------------------------long DriverInterface::GetSecondaryDNS(){	OSErr errCode;		// Set up pointer to information about protocol negociation	NCPQueryBlock * theQueryPtr;			theQueryPtr = (NCPQueryBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	// Choose to find out about IPCP	theQueryPtr->protocol = PPP_IPCP;	theQueryPtr->pointer = (Ptr)&mIPCPBlk;	theQueryPtr->size = sizeof(mIPCPBlk);		// Get NCP state information from driver	PrepCntrlParam(D_CTRL_GETSTATE_NCP);	errCode = ::PBControlSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);	ThrowIfOSErr_(errCode);			return mIPCPBlk.ipcp_secondary_dns;}// ---------------------------------------------------------------------------//		¥ GetLocalATAddr() 	//			Returns client's AppleTalk address// ---------------------------------------------------------------------------long DriverInterface::GetLocalATAddr(){	OSErr errCode;		// Set up pointer to information about protocol negociation	NCPQueryBlock * theQueryPtr;			theQueryPtr = (NCPQueryBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	// Choose to find out about IPCP	theQueryPtr->protocol = PPP_ATCP;	theQueryPtr->pointer = (Ptr)&mATCPBlk;	theQueryPtr->size = sizeof(mATCPBlk);		// Get NCP state information from driver	PrepCntrlParam(D_CTRL_GETSTATE_NCP);	errCode = ::PBControlSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);	ThrowIfOSErr_(errCode);			return mATCPBlk.atcp_local_address;}// ---------------------------------------------------------------------------//		¥ GetRemoteATAddr() 	//			Returns peer's AppleTalk address// ---------------------------------------------------------------------------long DriverInterface::GetRemoteATAddr(){	OSErr errCode;		// Set up pointer to information about protocol negociation	NCPQueryBlock * theQueryPtr;			theQueryPtr = (NCPQueryBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	// Choose to find out about IPCP	theQueryPtr->protocol = PPP_ATCP;	theQueryPtr->pointer = (Ptr)&mATCPBlk;	theQueryPtr->size = sizeof(mATCPBlk);		// Get NCP state information from driver	PrepCntrlParam(D_CTRL_GETSTATE_NCP);	errCode = ::PBControlSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);	ThrowIfOSErr_(errCode);			return mATCPBlk.atcp_remote_address;}// ---------------------------------------------------------------------------//		¥ OpenPPPDriver() 	//			Returns OSErr from Device Mgr. ::OpenDriver() call// ---------------------------------------------------------------------------OSErr DriverInterface::OpenPPPDriver(){	// Open the driver, and while doing so, set mUnitNum.	return ::OpenDriver(mDriverName, &mUnitNum);}// ---------------------------------------------------------------------------//		¥ Dial() 	//			Returns OSErr from PBControlSync D_CTRL_START call.// ---------------------------------------------------------------------------OSErr DriverInterface::Dial(){	// Send start command to driver	PrepCntrlParam(D_CTRL_START);	return ::PBControlSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);}// ---------------------------------------------------------------------------//		¥ HangUp() 	//			Returns OSErr from PBControlSync D_CTRL_STOP call.// ---------------------------------------------------------------------------OSErr DriverInterface::HangUp(){	// Send stop command to driver	PrepCntrlParam(D_CTRL_STOP);	return ::PBControlSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);}// ---------------------------------------------------------------------------//		¥ GetCharsIn() 	//			Returns # input chars so far// ---------------------------------------------------------------------------unsigned long DriverInterface::GetCharsIn(){	OSErr errCode;		// Set up pointer to driver's status information	PPPStatusBlock * theStatusBlk;	theStatusBlk = (PPPStatusBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	theStatusBlk->message = (char *)0;		// Grab driver status information	PrepCntrlParam(D_STAT_GETSTATUS);	errCode = ::PBStatusSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);	ThrowIfOSErr_(errCode);			return theStatusBlk->chars_in;}// ---------------------------------------------------------------------------//		¥ GetCharsOut() 	//			Returns # output chars so far// ---------------------------------------------------------------------------unsigned long DriverInterface::GetCharsOut(){	OSErr errCode;	// Set up pointer to driver's status information	PPPStatusBlock * theStatusBlk;	theStatusBlk = (PPPStatusBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	theStatusBlk->message = (char *)0;	// Grab driver status information	PrepCntrlParam(D_STAT_GETSTATUS);	errCode = ::PBStatusSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);	ThrowIfOSErr_(errCode);		return theStatusBlk->chars_out;}// ---------------------------------------------------------------------------//		¥ GetFramesIn() 	//			Returns # input frames so far// ---------------------------------------------------------------------------unsigned long DriverInterface::GetFramesIn(){	OSErr errCode;		// Set up pointer to driver's status information	PPPStatusBlock * theStatusBlk;	theStatusBlk = (PPPStatusBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	theStatusBlk->message = (char *)0;		// Grab driver status information	PrepCntrlParam(D_STAT_GETSTATUS);	errCode = ::PBStatusSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);	ThrowIfOSErr_(errCode);		return theStatusBlk->frames_in;}// ---------------------------------------------------------------------------//		¥ GetFramesOut() 	//			Returns # output frames so far// ---------------------------------------------------------------------------unsigned long DriverInterface::GetFramesOut(){	OSErr errCode;		// Set up pointer to driver's status information	PPPStatusBlock * theStatusBlk;	theStatusBlk = (PPPStatusBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	theStatusBlk->message = (char *)0;		// Grab driver status information	PrepCntrlParam(D_STAT_GETSTATUS);	errCode = ::PBStatusSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);	ThrowIfOSErr_(errCode);		return theStatusBlk->frames_out;}// ---------------------------------------------------------------------------//		¥ GetErrorFramesIn() 	//			Returns # input frames with error so far// ---------------------------------------------------------------------------unsigned long DriverInterface::GetErrorFramesIn(){	OSErr errCode;		// Set up pointer to driver's status information	PPPStatusBlock * theStatusBlk;	theStatusBlk = (PPPStatusBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	theStatusBlk->message = (char *)0;		// Grab driver status information	PrepCntrlParam(D_STAT_GETSTATUS);	errCode = ::PBStatusSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);	ThrowIfOSErr_(errCode);		return theStatusBlk->frames_error_in;}// ---------------------------------------------------------------------------//		¥ GetSecondsUp() 	//			Returns # seconds connection's been up// ---------------------------------------------------------------------------unsigned long DriverInterface::GetSecondsUp(){	OSErr errCode;		// Set up pointer to driver's status information	PPPStatusBlock * theStatusBlk;	theStatusBlk = (PPPStatusBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	theStatusBlk->message = (char *)0;		// Grab driver status information	PrepCntrlParam(D_STAT_GETSTATUS);	errCode = ::PBStatusSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);	ThrowIfOSErr_(errCode);		return theStatusBlk->up_seconds;}// ---------------------------------------------------------------------------//		¥ GetIdleSeconds() 	//			Returns # seconds connection's been idle// ---------------------------------------------------------------------------unsigned long DriverInterface::GetIdleSeconds(){	OSErr errCode;		// Set up pointer to driver's status information	PPPStatusBlock * theStatusBlk;	theStatusBlk = (PPPStatusBlock *)mExtendedCtrlBlk.mCtrlBlk.csParam;	theStatusBlk->message = (char *)0;		// Grab driver status information	PrepCntrlParam(D_STAT_GETSTATUS);	errCode = ::PBStatusSync((ParmBlkPtr)&mExtendedCtrlBlk.mCtrlBlk);	ThrowIfOSErr_(errCode);		return theStatusBlk->idle_seconds;}// ---------------------------------------------------------------------------//		¥ PrepCntrlParam() 	//			Sets up the CntrlParam member with new info for the driver, to//			be passed in with the next PBStatusSync or PBControlSync call.// ---------------------------------------------------------------------------void DriverInterface::PrepCntrlParam(short inCsCode){	mExtendedCtrlBlk.mCtrlBlk.csCode = inCsCode;	mExtendedCtrlBlk.mCtrlBlk.ioCompletion = nil;	mExtendedCtrlBlk.mCtrlBlk.ioResult = 0;	mExtendedCtrlBlk.mCtrlBlk.ioVRefNum = 0;	mExtendedCtrlBlk.mCtrlBlk.ioCRefNum = mUnitNum;}