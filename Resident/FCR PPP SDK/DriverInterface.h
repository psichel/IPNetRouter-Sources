/* 	DriverInterface.h: Class that enables interaction with FCR PPP Driver.    	   	This document contains proprietary information developed by    		FCR Software Inc.   		222 Third Street, Suite 3130   		Cambridge, MA 02142   		   	and should not be distributed, copied, or disclosed without explicit   	permission of FCR Software, Inc..   	   	You may use this document and the source herein for developing    	applications that use the LinkUPPP! (FCR PPP) driver.   	   	NOTE: This code assumes that the user has set up a connection document   	properly, and configured the driver with it (i.e. used it most recently   	to make a connection, or selected Configure Driver from the File menu   	in LinkUPPP!.	Copyright 1997-98 FCR Software, Inc.		November 5, 1997 - Jessica Kahn <jess@fcr.com>*/#pragma once#include "ppp_api.h"// PowerPlant uses this for exceptions too, but in case you aren't using PowerPlant...#ifndef ThrowIfOSErr_ #define Throw_(err)		throw (long)(err)#define ThrowIfOSErr_(err)											\	do {															\		OSErr	__theErr = err;										\		if (__theErr != noErr) {									\			Throw_(__theErr);										\		}															\	} while (false)#endif // ThrowIfOSErr_class DriverInterface {public:		DriverInterface();							// Default Constructor for .PPP driver	DriverInterface(StringPtr inDriverName);	// Constructor: takes driver name	~DriverInterface();							// Destructor - does nothing		Boolean IsIPCPUp();					// True if IPCP is up, false if not	Boolean IsATCPUp();					// True if ATCP is up, false if not	Boolean IsHeaderCompOn();			// True if TCP header compression is on, false if not		long GetClientIP();					// Returns negociated client IP address	long GetServerIP();					// Returns server's IP address	long GetPrimaryDNS();				// Returns primary DNS address	long GetSecondaryDNS();				// Returns secondary DNS address	long GetLocalATAddr();				// Returns local AppleTalk address	long GetRemoteATAddr();				// Returns peer's AppleTalk address		short GetDriverStatus();			// Returns PPP driver status (see ppp_api.h)	short GetScriptResult();			// Returns ccl script result (see ppp_api.h)		OSErr OpenPPPDriver();				// Returns OSErr from ::OpenDriver()	OSErr Dial();						// Returns OSErr from ::PBControlSync() call	OSErr HangUp();						// Returns OSErr from ::PBControlSync() call		unsigned long GetCharsIn();			// Returns # input chars so far	unsigned long GetCharsOut();		// Returns # output chars so far	unsigned long GetFramesIn();		// Returns # input frames so far	unsigned long GetFramesOut();		// Returns # output frames so far	unsigned long GetErrorFramesIn();	// Returns # input frames with error so far	unsigned long GetSecondsUp();		// Returns # seconds connection's been up	unsigned long GetIdleSeconds();		// Returns # seconds connection's been idle	private:	void PrepCntrlParam(short inCsCode);	// Sets new csCode for syncing w/ driver	short mUnitNum;					// Number of our driver in driver unit table		StringPtr mDriverName;			// String containing PPP driver name		PPPIPCPConfigBlock mIPCPBlk;	// Holds information about IPCP's configuration	PPPATCPConfigBlock mATCPBlk;	// Holds information about ATCP's configuration		// Explanation of why the following struct is needed: 	// A CntrlParam has various pieces of member data, including an array of	// 11 shorts called "csParam". Our .PPP driver returns information to us	// through the csParam portion of the CntrlParam, but we then deal with 	// it using a PPPStatusBlock. To make this transition seamless, we 	// create a struct, mExtendedCtrlBlk, that has an entire CntrlParam in it,	// with additional memory tacked on at the end, such that 	// sizeof(CSParam) + sizeof(filler) == sizeof(PPPStatusBlock). 	struct {		CntrlParam 	mCtrlBlk;		char 		filler[sizeof(PPPStatusBlock) - 22];	} mExtendedCtrlBlk;};	