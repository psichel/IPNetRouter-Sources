// =================================================================================//	CControlOTPPP.cp	 		©1997-98 Sustainable Softworks. All rights reserved.// =================================================================================//	Object to control OT/PPP connection//	This object is a subclass of CControlLink#include "CompileFlags.h"#include "CControlOTPPP.h"#include "CResidentIfInfo.h"#include "CLogAction.h"#include "MacSupport.h"#include "IPSupport.h"#include <LString.h>//#include <OpenTransport.h>//#include <OpenTptPPP.h>//#include <modnames.h>			// names of the standard OT modules.#include "CSendUDPThread.h"#include "CTurboUDPEndpoint.h"#include "CNetMessage.h"// Globalsextern CLogAction*		gLogAction;// ---------------------------------------------------------------------------------//		¥ CControlOTPPP()// ---------------------------------------------------------------------------------CControlOTPPP::CControlOTPPP(Str63 inPortName){	LString::CopyPStr(inPortName, mPortName, sizeof(Str63));	// initialization	mPPPEndpointRef = nil;	mPPPEndpoint = nil;	mSendUDPThread = nil;	mLastTime = 0;	mPPPState = kPPPStateNone;}// ---------------------------------------------------------------------------------//		¥ ~CControlOTPPP// ---------------------------------------------------------------------------------CControlOTPPP::~CControlOTPPP(){	Terminate();}// ---------------------------------------------------------------------------------//		¥ Terminate// ---------------------------------------------------------------------------------voidCControlOTPPP::Terminate(){	StopMonitoring();}#pragma mark --- public API ---// ---------------------------------------------------------------------------------//		¥ StartMonitoring// ---------------------------------------------------------------------------------//	Open a PPP control endpoint to begin monitoring PPP stateOTResultCControlOTPPP::StartMonitoring(Boolean inShowDialogs){	OSStatus	err = kOTNoError;	OSStatus	response;	UInt32		eventParam = 1;		try {		//	OpenTransport/ Remote Access must be present		ThrowIfOSErr_(::Gestalt(gestaltOpenTptRemoteAccess, &response));		ThrowIfNot_( response & (1 << gestaltOpenTptRemoteAccessPresent) );		//	OpenTransport/ Remote Access PPP must also be present		ThrowIfNot_( response & (1 << gestaltOpenTptPPPPresent) );				UOpenTptSupport::StartOpenTransport();		// Create a PPP control endpoint		if (!mPPPEndpoint) {				// if no endpoint, make sure we get a new thread				if (mSendUDPThread) {					mSendUDPThread->Abort();					mSendUDPThread = nil;				}			mPPPEndpoint = new CTurboUDPEndpoint(kPPPControlName);			ThrowIfNil_(mPPPEndpoint);			// Register to receive other event notifications (including Ioctl responses)			mPPPEndpoint->AddListener(this);		}		if (!mSendUDPThread) {			mSendUDPThread = new CSendUDPThread(				(CObjectMaster*)	this,				(CTurboUDPEndpoint*) mPPPEndpoint);			ThrowIfNil_(mSendUDPThread);			// enable OT/PPP events			mSendUDPThread->Ioctl(I_OTGetMiscellaneousEvents, (void*)eventParam);			// launch thread to begin I/O			mSendUDPThread->Resume();		}		// initialize link state		if (mPPPState == kPPPStateNone) {			if (IsLinkUp()) mPPPState = kPPPConnectCompleteEvent;			else mPPPState = kPPPDisconnectCompleteEvent;		}		// enable/disable PPP modal dialogs		AlertEnable(inShowDialogs);	}	catch (const LException& inErr) {		err = inErr.GetErrorCode();	} 		return err;}// ---------------------------------------------------------------------------------//		¥ StopMonitoring// ---------------------------------------------------------------------------------//	Release control endpoint to stop monitoring PPPOTResultCControlOTPPP::StopMonitoring(){	StopIdling();	if (mSendUDPThread) mSendUDPThread->Abort();	// Wait for threads to abort normally	UInt8 retryLimit = 8;	while (mSendUDPThread != nil) {		LThread::Yield();		retryLimit -= 1;		if (retryLimit == 0) break;	}		if (mSendUDPThread) {		mSendUDPThread->DeleteThread();		mSendUDPThread = nil;	}	// Release the Endpoint we created		// PPP Control	if (mPPPEndpoint) {		mPPPEndpoint->RemoveListener(this);		delete mPPPEndpoint;		mPPPEndpoint = nil;	}	if (mPPPEndpointRef) {		::OTCloseProvider(mPPPEndpointRef);		mPPPEndpointRef = nil;	}		mPPPState = kPPPStateNone;		return kOTNoError;}// ---------------------------------------------------------------------------------//		¥ Connect// ---------------------------------------------------------------------------------//	BringUpPPP//	Open a PPP control endpoint//	Install notifier to monitor for events//	If not connected, try to connectOTResultCControlOTPPP::Connect(Boolean inShowDialogs){	OTResult	err = kOTNoError;	Boolean		result;	do {				err = StartMonitoring(inShowDialogs);			if (err != kOTNoError) {			BroadcastMessage(msg_AsynchCompletion, this);			break;		}		try {			switch (mPPPState) {				case kPPPDisconnectCompleteEvent:				case kPPPDisconnectEvent:				case kPPPLowerLayerDownEvent:				case kPPPDCECallFinishedEvent:					// make sure we still have a thread					if (mSendUDPThread == nil) {						err = kENXIOErr;						BroadcastMessage(msg_AsynchCompletion, this);						break;					}					// start asynchronous connection attempt					// If already connected, this will return an outstate error					gLogAction->LogText("\p\rControl OT/PPP start connection attempt");					result = mSendUDPThread->Ioctl(I_OTConnect, nil);					if (!result) err = kOTOutStateErr;					break;				default:					err = kOTOutStateErr;					gLogAction->LogText("\p\rControl OT/PPP call issued in unexpected state: ", mPPPState-kPPPEvent);					break;			}		}		catch (const LException& inErr) {			err = inErr.GetErrorCode();				} 	} while (false);		return err;}// ---------------------------------------------------------------------------------//		¥ Disconnect// ---------------------------------------------------------------------------------//	Disconnect dial on demand linkOTResultCControlOTPPP::Disconnect(Boolean inShowDialogs){	OSStatus	err = kOTNoError;		do {				err = StartMonitoring(inShowDialogs);			if (err != kOTNoError) break;		try {			// make sure we still have a thread			if (mSendUDPThread == nil) {				err = kENXIOErr;				break;			}			// start asynchronous disconnection attempt			// If already connected, this will return an outstate error			if (mPPPState == kPPPConnectCompleteEvent) {				gLogAction->LogText("\p\rStart asynchronous disconnection");			} else {				gLogAction->LogText("\p\rAbort connection attempt in progress");			}			mSendUDPThread->Ioctl(I_OTDisconnect, nil);		}		catch (const LException& inErr) {			err = inErr.GetErrorCode();				} 		catch(...) {		    SysBeep(30);		} 	} while (false);		if (err != kOTNoError) BroadcastMessage(msg_AsynchCompletion, this);	return err;}// ---------------------------------------------------------------------------------//		¥ IsLinkUp// ---------------------------------------------------------------------------------//	Test for PPP upBooleanCControlOTPPP::IsLinkUp(){	OTResult	err;	Boolean		result = false;	TOptMgmt	cmd;	TOption*	option;	UInt8		buf[sizeof(TOptionHeader) + sizeof(CCMiscInfo) + kOptionPadSize];	// if Monitoring PPP	if (mPPPEndpoint) {		// test for actual status		cmd.opt.buf      = buf;		cmd.opt.len      = sizeof(TOptionHeader);		cmd.opt.maxlen   = sizeof(buf);		cmd.flags        = T_CURRENT;		option           = (TOption *) buf;		option->level    = COM_PPP;		option->name     = CC_OPT_GETMISCINFO;		option->status   = 0;					option->len      = sizeof(TOptionHeader); 				err = PPPOptionManagement(&cmd);		if (err != kOTNoError) {			gLogAction->LogText("\p\r### CControlOTPPP Unexpected Option Management result: ", err);		}		else {	// no error in request			option = (TOption *) cmd.opt.buf;			if (option->status != T_FAILURE) {				CCMiscInfo *info = (CCMiscInfo *) &option->value[0];				//				// Are we connected?				//				if (info->connectionStatus == kPPPConnectionStatusConnected) {					result = true;				}			}		}	}	return result;}// ---------------------------------------------------------------------------------//		¥ IsMonitoring// ---------------------------------------------------------------------------------//	Test for Monitoring PPP stateBooleanCControlOTPPP::IsMonitoring(){	Boolean		result = false;	if (mPPPEndpoint) result = true;	return result;}// ---------------------------------------------------------------------------------//		¥ GetIPAddress// ---------------------------------------------------------------------------------//	Get PPP Local Protocol Address//	Return zero if address not availableUInt32CControlOTPPP::GetIpAddress(){	OTResult	err;	UInt32		result = 0;	TOptMgmt	cmd;	TOption*	option;	UInt8		buf[sizeof(TOptionHeader) + sizeof(InetAddress) + kOptionPadSize];	InetAddress* theAddress;	cmd.opt.buf      = buf;	cmd.opt.len      = sizeof(TOptionHeader);	cmd.opt.maxlen   = sizeof(buf);	cmd.flags        = T_CURRENT;	option           = (TOption *) buf;	option->level    = COM_PPP;	option->name     = IPCP_OPT_GETLOCALPROTOADDR;	option->status   = 0;				option->len      = sizeof(TOptionHeader); 		err = PPPOptionManagement(&cmd);	if (err != kOTNoError) {		gLogAction->LogText("\p\r### CControlOTPPP Unexpected Option Management result: ", err);	}	else {	// request OK		option = (TOption *) cmd.opt.buf;		if (option->status != T_FAILURE) {			theAddress = (InetAddress *) &option->value[0];			result = theAddress->fHost;		}	}	return result;}// ---------------------------------------------------------------------------------//		¥ GetRemoteAddress// ---------------------------------------------------------------------------------//	Get PPP Local Protocol Address//	Return zero if address not availableUInt32CControlOTPPP::GetRemoteAddress(){	OTResult	err;	UInt32		result = 0;	TOptMgmt	cmd;	TOption*	option;	UInt8		buf[sizeof(TOptionHeader) + sizeof(InetAddress) + kOptionPadSize];	InetAddress* theAddress;	cmd.opt.buf      = buf;	cmd.opt.len      = sizeof(TOptionHeader);	cmd.opt.maxlen   = sizeof(buf);	cmd.flags        = T_CURRENT;	option           = (TOption *) buf;	option->level    = COM_PPP;	option->name     = IPCP_OPT_GETREMOTEPROTOADDR;	option->status   = 0;				option->len      = sizeof(TOptionHeader); 		err = PPPOptionManagement(&cmd);	if (err != kOTNoError) {		gLogAction->LogText("\p\r### CControlOTPPP Unexpected Option Management result: ", err);	}	else {	// request OK		option = (TOption *) cmd.opt.buf;		if (option->status != T_FAILURE) {			theAddress = (InetAddress *) &option->value[0];			result = theAddress->fHost;		}	}	return result;}// ---------------------------------------------------------------------------------//		¥ AlertEnable// ---------------------------------------------------------------------------------//	Enable/Disable PPP modal notification dialogsBooleanCControlOTPPP::AlertEnable(Boolean inFlag){	OTResult	err;	Boolean		result = false;	TOptMgmt	cmd;	TOption*	option;	UInt8		buf[kOTFourByteOptionSize];	// if Monitoring PPP	if (mPPPEndpoint) {		// setup to set option		bzero(buf, sizeof(buf));		cmd.opt.buf      = buf;		cmd.opt.len      = kOTFourByteOptionSize;		cmd.opt.maxlen   = sizeof(buf);		cmd.flags        = T_NEGOTIATE;		option           = (TOption *) buf;		option->level    = COM_PPP;		option->name     = OPT_ALERTENABLE;		option->status   = 0;					option->len      = kOTFourByteOptionSize;		if (inFlag) option->value[0] = kPPPConnectionStatusDialogsFlag +			kPPPOutPasswordDialogsFlag;		else option->value[0] = kPPPAllAlertsDisabledFlag;				err = PPPOptionManagement(&cmd);		if (err != kOTNoError) {			gLogAction->LogText("\p\r### CControlOTPPP Unexpected Option Management result: ", err);		}		else {	// no error in request			option = (TOption *) cmd.opt.buf;			if (option->status == T_SUCCESS) {				result = true;			}		}	}	return result;}#pragma mark --- private support functions ---// ---------------------------------------------------------------------------------//		¥ PPPOptionManagement// ---------------------------------------------------------------------------------//	Send synchronous Option Management request to PPP EndpointOTResultCControlOTPPP::PPPOptionManagement(TOptMgmt* cmd){	OTResult		result;	TEndpointInfo	info;		// Make sure we have an endpoint to communicate with PPP	if (!mPPPEndpointRef) {		UOpenTptSupport::StartOpenTransport();		mPPPEndpointRef = ::OTOpenEndpoint(::OTCreateConfiguration(kPPPControlName), 0, &info, &result);		ThrowIfError_(result);		::OTSetSynchronous(mPPPEndpointRef);		::OTSetBlocking(mPPPEndpointRef);	}			// issue Option Management request	result = ::OTOptionManagement(mPPPEndpointRef, cmd, cmd);	return result;}// ---------------------------------------------------------------------------------//		¥ PPPIoctl// ---------------------------------------------------------------------------------//	Send synchronous ioctl to PPP EndpointOTResultCControlOTPPP::PPPIoctl(UInt32 inCmd, void* inData){	OTResult		result;	TEndpointInfo	info;		// Make sure we have an endpoint to communicate with PPP	if (!mPPPEndpointRef) {		UOpenTptSupport::StartOpenTransport();		mPPPEndpointRef = ::OTOpenEndpoint(::OTCreateConfiguration(kPPPControlName), 0, &info, &result);		ThrowIfError_(result);	}			// issue requested ioctl	result = ::OTIoctl(mPPPEndpointRef, inCmd, inData);	return result;}// ---------------------------------------------------------------------------//		¥ ObjectThreadDied// ---------------------------------------------------------------------------//	A threaded operation has completed.voidCControlOTPPP::ObjectThreadDied(LThread *inThread) {				// Transmit Thread completed?	if (inThread == mSendUDPThread) {		// get result		long result = *((long*)inThread->GetResult());		// indicate thread no longer exists		mSendUDPThread = nil;		// handle results		switch (result) {			case 0:				// no error				break;			case Abort_Error:	// operation aborted				break;			default:				// write to log window if any				gLogAction->LogText("\p\r### CResidentInfo CSendUDPThread unexpected event code: ", result);				break;		}	// end switch		// Release the endpoints we created		//LastComplete();	}}// ---------------------------------------------------------------------------//		¥ SpendTime// ---------------------------------------------------------------------------//	Periodical function to delay before we signal completionvoidCControlOTPPP::SpendTime(const EventRecord &inMacEvent){#pragma unused (inMacEvent)	if (mDelayCount == 0) {		StopIdling();		// signal completion		BroadcastMessage(msg_AsynchCompletion, this);	}	else mDelayCount -= 1;}// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------//	Listen for other notifications from endpoint//		BroadcastMessage(nextMessage->GetMessageType(), nextMessage);voidCControlOTPPP::ListenToMessage(	MessageT	inEventCode,	void		*ioParam ){	CNetMessage* inMessage = (CNetMessage*)ioParam;	OTResult	resultCode, pppResult;	Str32		str;	switch ( inEventCode ) {		case kOTProviderWillClose:			gLogAction->LogText("\p\r### Network connection terminated.");			gLogAction->LogText("\p\r kOTProviderWillClose - Provider will close immediately.");			break;		case kOTProviderIsClosed:		case msg_BroadcasterDied:			break;		case kStreamIoctlEvent:			resultCode = inMessage->GetResultCode();			pppResult = (OTResult)inMessage->GetCookie();			// check if PPP ioctl succeeded			if (resultCode != kOTNoError) switch (resultCode) {				case kENXIOErr:					gLogAction->LogText("\p\rPPP Ioctl failed:");					gLogAction->LogText("\p\r  kENXIOErr - No such device or address.");					// IOCTL completed, cleanup//					if (mSendUDPThread) mSendUDPThread->Abort();					BroadcastMessage(msg_ResetLink, this);					break;							default:					gLogAction->LogText("\p\rPPP Ioctl failed with error code: ", resultCode);					// IOCTL completed, cleanup//					if (mSendUDPThread) mSendUDPThread->Abort();					BroadcastMessage(msg_ResetLink, this);					break;			}//			else {//				gLogAction->LogText("\p\rPPP kStreamIoctlEvent: ", resultCode);//				gLogAction->LogText("\p\r  PPP result: ", pppResult);//			}			break;		case kPPPConnectCompleteEvent:			pppResult = (OTResult)inMessage->GetCookie();			if (pppResult != kOTNoError) {							// attempt completed, but state is not connected				mPPPState = kPPPStateNone;				if (pppResult < 0) {					BroadcastMessage(msg_AsynchCompletion, this);				}			}			else {				// attempt completed successfully				mPPPState = inEventCode;								// finish connection process				BroadcastMessage(msg_LinkUp, this);				//BroadcastMessage(msg_AsynchCompletion, this);				mDelayCount = 30;				StartIdling();			}			break;		case kPPPDisconnectCompleteEvent:			pppResult = (OTResult)inMessage->GetCookie();			if (pppResult != kOTNoError) {							// request completed, but state is not disconnected				mPPPState = kPPPStateNone;				if (pppResult < 0) {					BroadcastMessage(msg_LinkDown, this);					BroadcastMessage(msg_AsynchCompletion, this);				}			} else {				BroadcastMessage(msg_LinkDown, this);				BroadcastMessage(msg_AsynchCompletion, this);				mPPPState = inEventCode;				gLogAction->LogText("\p\rPPP Termination complete.");			}			break;		case kPPPDisconnectEvent:			BroadcastMessage(msg_LinkDown, this);			mPPPState = inEventCode;			break;		case kPPPIPCPUpEvent:			mPPPState = inEventCode;			gLogAction->LogText("\p\rStarting network protocols.");			break;		case kPPPIPCPDownEvent:			mPPPState = inEventCode;			break;		case kPPPLCPUpEvent:			mPPPState = inEventCode;			//gLogAction->LogText("\p\rModem compression established.");			break;		case kPPPLCPDownEvent:			mPPPState = inEventCode;			break;		case kPPPLowerLayerUpEvent:			mPPPState = inEventCode;			gLogAction->LogText("\p\rStarting PPP...");			break;		case kPPPLowerLayerDownEvent:			mPPPState = inEventCode;			mPPPState = inEventCode;			break;		case kPPPAuthenticationStartedEvent:			mPPPState = inEventCode;			gLogAction->LogText("\p\rAuthenticating...");			break;		case kPPPAuthenticationFinishedEvent:			mPPPState = inEventCode;			pppResult = (OTResult)inMessage->GetCookie();			if (pppResult != kOTNoError) {							gLogAction->LogText("\p\rAuthenticaton failed.");			} else {				gLogAction->LogText("\p\rAuthenticaton completed.");			}						break;		case kPPPDCEInitStartedEvent:			mPPPState = inEventCode;			break;		case kPPPDCEInitFinishedEvent:			mPPPState = inEventCode;			break;		case kPPPDCECallStartedEvent:			BroadcastMessage(msg_CallStarted, this);			mPPPState = inEventCode;			gLogAction->LogText("\p\rDialing...");			break;		case kPPPDCECallFinishedEvent:			mPPPState = inEventCode;			break;		default:			gLogAction->LogText("\p\rCControlOTPPP: unknown async message type: ");			IP_NumToHexStr(inEventCode, str);			gLogAction->LogText(str);	}}