// =================================================================================//	CResidentIfInfo.cp	 		©1997-1999 Sustainable Softworks. All rights reserved.// =================================================================================//	Interface Info we need to keep resident in memory#include "CompileFlags.h"#include "CResidentIfInfo.h"#include "CLogAction.h"#include "CInterfacesWindow.h"#include "CInterfacesConst.h"#include "CRoutesWindow.h"#include "CIPRouterApp.h"#include "IPRouterCommon.h"#include "MacSupport.h"#include "IPSupport.h"#include "Autopush.h"#include <LString.h>#include <LPreferencesFile.h>#include <UResourceMgr.h>#include <LThread.h>#include <OpenTransport.h>#include <OpenTptConfig.h>#include <OpenTptInternet.h>#include <modnames.h>			// names of the standard OT modules.#include <OpenTptPPP.h>#include <NSL.h>#include "MyNSL10.h"#include "MyOTInetMultilink.h"#include "CControlOTPPP.h"#include "CControlFCRPPP.h"#include "CSendUDPThread.h"#include "CTurboUDPEndpoint.h"#include "CNetMessage.h"#include "CRestoreThread.h"#include "CTestConnectionThread.h"#include "CTickleConnectionThread.h"#include "CProxyControl.h"#include "CConfigDocument.h"#include "CGatewayData.h"		// pick up "UponOpen" constants#include "CConnectionData.h"#include "CInterfacesData.h"#include "CInterfacesAction.h"#include "CRoutesAction.h"#include "CRoutesData.h"#include "CDeviceData.h"#include "CGatewayAction.h"// Globalsextern CLogAction*			gLogAction;extern CIPRouterApp*		gAppObject;extern CProxyControl*		gProxyControl;extern CConnectionData*		gConnectionData;extern CGatewayData*		gGatewayData;extern CInterfacesData*	 	gInterfacesData;extern CRoutesData*			gRoutesData;extern CDeviceData*			gDeviceData;extern CRoutesAction*		gRoutesAction;extern CInterfacesAction*	gInterfacesAction;extern CGatewayAction*		gGatewayAction;extern UInt8				gApplicationMode;// ---------------------------------------------------------------------------------//		¥ CResidentIfInfo()// ---------------------------------------------------------------------------------CResidentIfInfo::CResidentIfInfo(){	// initialization	mOnDemandName[0] = 0;	mInterfaceEntry.portName[0] = 0;	mPseudoGateway = 0;	mDHCPinterface = 0;	mDHCPNet.address = 0;	mDHCPNet.mask = 0;	mDHCPSavedNet.address = 0;	mDHCPSavedNet.mask = 0;	// PPP Control	mControlLink = nil;	mOldConfig_ResID = 0;	mRetryCount = kRetryCount;	mFirstPPPflag = true;	mPPPlocalAddress = 0;	mPPPDNSAddress = 0;	LString::CopyPStr("\pIPNetRouter", mPPPName, sizeof(Str63));	// check option setting for PPP Retry Delay	mRetryDelayInit = kRetryDelayShort;	// default number of MS until next PPP attempt	Str31	str;	::GetIndString(str, rSTRN_OptionSettings, kOptionPPPRetryDelay);	if ( BeginsWith(str, "\pPPPRetryDelay") && GetKeywordValue(str, str) ) {		long value;		::StringToNum(str, &value);		mRetryDelayInit = value;	}	mRetryDelayCurrent = mRetryDelayInit;	// Threads	mRestoreThread = nil;	mTestConnectionThread = nil;	mTickleConnectionThread = nil;		// NSL	mNSLRegisterState = kNSLRegisterNone;	mNSLServiceName = "\p";	mNSLClientRef = 0;	mNSLDataPtr = 0;}// ---------------------------------------------------------------------------------//		¥ ~CResidentIfInfo// ---------------------------------------------------------------------------------CResidentIfInfo::~CResidentIfInfo(){	// restore primary interface	RestorePrimaryIf();	// unregister and close NSL (defensive)	DeregisterWithNSL();	CloseNSL();	Reset(true);	// release control link object	if (mControlLink) {		mControlLink->RemoveListener(this);		delete mControlLink;		mControlLink = nil;	}}// ---------------------------------------------------------------------------------//		¥ Reset// ---------------------------------------------------------------------------------voidCResidentIfInfo::Reset(Boolean inCanWait){	// stop any PPP retries in progress	StopIdling();	RestorePrimaryIf();	// halt any restore in progress	if (mRestoreThread) mRestoreThread->DeleteThread();		// cleanup other threads	if (mTestConnectionThread) mTestConnectionThread->Abort();	if (mTickleConnectionThread) mTickleConnectionThread->Abort();	if (inCanWait) {		// Wait for threads to abort normally		UInt8 retryLimit = 16;		while (	(mTestConnectionThread != nil)		||				(mTickleConnectionThread != nil)	) {			LThread::Yield();			retryLimit -= 1;			if (retryLimit == 0) break;		}	}	// delete threads and provider as best we can	if (mTestConnectionThread) {		mTestConnectionThread->DeleteThread();		mTestConnectionThread = nil;	}	if (mTickleConnectionThread) {		mTickleConnectionThread->ProviderIsClosed();		mTickleConnectionThread->DeleteThread();		mTickleConnectionThread = nil;	}	// Reset PPP controller	if (mControlLink) mControlLink->Terminate();}#pragma mark --- NSL ---enum {	kSystemVersion8 = 0x800,	kSystemVersion9 = 0x900,	kNSLVersion11   = 0x010100};// ---------------------------------------------------------------------------------//		¥ InitNSL// ---------------------------------------------------------------------------------// Open a session with NSL 1.0 if necessary.  Since this function may initialize// NSL which uses the Thread Manager, it must be called from our main thread.//// We will call this at application startup, whereas RegisterWithNSL() below// may be called from within a thread when a PPP interface comes up.//// If NSL needs to be initialized, this synchronous call will take about 35 seconds,// so we only use NSL 1.0 in "Apple FBA" mode to spare our other users.voidCResidentIfInfo::InitNSL(){	OSStatus	result = 0;	#if powerc	// NSL cannot be called from 68K	UInt32 		osVersion;	UInt32 		nslVersion;	do {		// check option setting		Boolean	useNSL = true;		Str31	str;		::GetIndString(str, rSTRN_OptionSettings, kOptionUseNSL);		if ( BeginsWith(str, "\pUseNSL") && GetKeywordValue(str, str) ) {			long value;			::StringToNum(str, &value);			useNSL = value;		}		if (!useNSL) break;		// check for NSL available and which version (1.0 or 1.1)			// check Mac OS version		result = Gestalt(gestaltSystemVersion, (long *) &osVersion);		if (result != noErr) break;		if (osVersion >= kSystemVersion9) {		// Mac OS 9 or later						// NSL present?			if (NSLLibraryPresent()) {				// version 1.1?				nslVersion = NSLLibraryVersion();				if (nslVersion >= kNSLVersion11) {					break;	// skip NSL 1.0 code below				}			}		}		// if we can't use NSL 1.1,		// try to using NSL 1.0	--- requires Mac OS 8 or later			//if (osVersion >= kSystemVersion8) {			// This call can take many seconds, check for Apple FBA mode!		if ((osVersion >= kSystemVersion8) && (gApplicationMode & kModeApple)) {			gLogAction->LogText("\p\rOpen NSL 1.0");			result = NSLOpenNavigationAPI(&mNSLClientRef);	// slow!!!			if ((result != noErr) && (result != kNSLSomePluginsFailedToLoad)) mNSLClientRef=0;		}	} while (false);	#endif}// ---------------------------------------------------------------------------------//		¥ RegisterWithNSL// ---------------------------------------------------------------------------------// Register ourselves as a service with NSL// The service name used to register is formed by appending the keyword value// of NSLServiceName stored in STR# 131 Option Settings (10), with inAddrStr.// Example:  service:router://17.205.22.132//// Since IPNR affords multiple IP interfaces, we need to choose which IP// address to register.  We register our public (globally unique) IP address// as determined by which IP interface is enabled for masquerading.  This// assumption may need to be revisited.//// Result codes://  0 NSL is not available, or service registered successfully.//  * Other OSStatus.OSStatusCResidentIfInfo::RegisterWithNSL(Str255 inAddrStr){	OSStatus	result = 0;	#if powerc	// NSL cannot be called from 68K	UInt32 		osVersion;	UInt32 		nslVersion;	NSLError	nslResult;	Str255		str;	do {		// check option setting		Boolean	useNSL = true;		::GetIndString(str, rSTRN_OptionSettings, kOptionUseNSL);		if ( BeginsWith(str, "\pUseNSL") && GetKeywordValue(str, str) ) {			long value;			::StringToNum(str, &value);			useNSL = value;		}		if (!useNSL) break;				// release any previous registration		if (mNSLRegisterState != kNSLRegisterNone) {			DeregisterWithNSL();		}				// Get NSL Service Name		::GetIndString(str, rSTRN_OptionSettings, kOptionNSLServiceName);		if ( BeginsWith(str, "\pNSLServiceName") && GetKeywordValue(str, str) ) {			mNSLServiceName = str;			mNSLServiceName += inAddrStr;			mNSLServiceName[mNSLServiceName.Length()+1] = 0;	// make null terminated		} else break;	// nothing to register		// check for NSL available and which version (1.0 or 1.1)			// check Mac OS version		result = Gestalt(gestaltSystemVersion, (long *) &osVersion);		if (result != noErr) break;		if (osVersion >= kSystemVersion9) {		// Mac OS 9 or later						// try to register with NSL 1.1			// NSL present?			if (NSLLibraryPresent()) {				// version 1.1?				nslVersion = NSLLibraryVersion();				if (nslVersion >= kNSLVersion11) {					gLogAction->LogText("\p\rNSL 1.1 registering as: ");					gLogAction->LogText(mNSLServiceName);					gLogAction->Update();					// try to register using NSL 1.1					nslResult = ::NSLStandardRegisterURL((char*)&mNSLServiceName[1], NULL);					result = nslResult.theErr;					if (result == noErr) mNSLRegisterState = kNSLRegister11;					break;	// skip NSL 1.0 code below				}			}		}		// if we can't use NSL 1.1,		// try to register using NSL 1.0 --- requires Mac OS 8 or later					if (mNSLClientRef > 0) {			gLogAction->LogText("\p\rNSL 1.0 registering as: ");			gLogAction->LogText(mNSLServiceName);			gLogAction->Update();			// call our own function in a separate file so we can include NSLAPI.h			result = MyRegisterWithNSL10((char*)&mNSLServiceName[1], &mNSLDataPtr);			if (result == noErr) mNSLRegisterState = kNSLRegister10;		}	} while (false);	#endif	return result;}// ---------------------------------------------------------------------------------//		¥ DeregisterWithNSL// ---------------------------------------------------------------------------------OSStatusCResidentIfInfo::DeregisterWithNSL(){	OSStatus 	result = 0;	#if powerc	// NSL cannot be called from 68K	NSLError	nslResult;	// deregister based on how we registered	switch (mNSLRegisterState) {		case kNSLRegister11:			gLogAction->LogText("\p\rNSL 1.1 deregistering: ");			gLogAction->LogText(mNSLServiceName);			gLogAction->Update();			nslResult = ::NSLStandardDeregisterURL((char*)&mNSLServiceName[1], NULL);			result = nslResult.theErr;			mNSLRegisterState = kNSLRegisterNone;						break;		case kNSLRegister10:			gLogAction->LogText("\p\rNSL 1.0 deregistering: ");			gLogAction->LogText(mNSLServiceName);			gLogAction->Update();			// call our own function in a separate file so we can include NSLAPI.h			result = MyDeregisterWithNSL10(&mNSLDataPtr);			mNSLRegisterState = kNSLRegisterNone;			break;		case kNSLRegisterNone:			break;	}	#endif	return result;}// ---------------------------------------------------------------------------------//		¥ CloseNSL// ---------------------------------------------------------------------------------voidCResidentIfInfo::CloseNSL(){	#if powerc	// NSL cannot be called from 68K	if (mNSLClientRef > 0) {		// close NSL session		gLogAction->LogText("\p\rClose NSL 1.0");		::NSLCloseNavigationAPI(mNSLClientRef);			}	#endif}#pragma mark --- Restore Saved Configuration ---// ---------------------------------------------------------------------------------//		¥ DoRestore()// ---------------------------------------------------------------------------------// Create a thread to step through the restore processBooleanCResidentIfInfo::DoRestore(){			Boolean result = true;	// Create thread to step through load sequence	if (!mRestoreThread) {		mRestoreThread = new CRestoreThread(this);		if (mRestoreThread) mRestoreThread->Resume();		else {			gLogAction->LogText("\p\rCResidentInfo failure creating restore thread");		}	}	else result = false;	return result;}#pragma mark --- PPP Control ---// ---------------------------------------------------------------------------------//		¥ GetPPPController// ---------------------------------------------------------------------------------//	Get PPP controller for corresponding port name//		Returns true if a matching controller was found, otherwise false//		Controller object will be in mControlLink (or nil)BooleanCResidentIfInfo::GetPPPController(Str63 inPortName){	OTResult		result = kProxyNoError;	struct strioctl	streamCommand;	LStr255			text;		if ( ::EqualString("\pIPCP", inPortName, false, false) ) {		mControlLink = new CControlOTPPP(inPortName);	}	else if ( ::EqualString("\pmdev03", inPortName, false, false) ) {		mControlLink = new CControlFCRPPP(inPortName);	}	else mControlLink = nil;	// set dial on demand interface in proxy module	LString::CopyPStr(inPortName, mOnDemandName, kInterfaceNameDim);	UInt32 theHash;	theHash = HashName(inPortName);	SetupIoctl(&streamCommand, I_SetOnDemandName,		(char*)&theHash, sizeof(UInt32));	result = gProxyControl->ProxyIoctl(I_STR, &streamCommand);	if (result == kProxyNoError) {		text = "\p\r    On Demand interface: ";		text += mOnDemandName;		gLogAction->LogText(text);	}			return (mControlLink != nil);}// ---------------------------------------------------------------------------------//		¥ MonitorPPP// ---------------------------------------------------------------------------------//	Begin monitoring PPP stateOTResultCResidentIfInfo::MonitorPPP(InterfaceEntry_t* inInterfaceEntry){	OSStatus	err = kOTNoError;		// remember inInterfaceEntry	if (inInterfaceEntry) {		mInterfaceEntry = *inInterfaceEntry;	}	// setup to tell proxy module about PPP events	gProxyControl->ProxyConnect();		// get corresponding control link object if needed	if (mControlLink == nil) {		GetPPPController(mInterfaceEntry.portName);		if (mControlLink) mControlLink->AddListener(this);	}		if (mControlLink) {		err = mControlLink->StartMonitoring(gGatewayData->GetDataShowPPPdialogs());		if (err == kOTNoError) {			// initialize link state			if (IsPPPUp()) gConnectionData->SetDataLinkState(kLinkStateConnected);			else gConnectionData->SetDataLinkState(kLinkStateIdle);		}	} else {		err = kENXIOErr;	}	SetTickle(gGatewayData->GetDataRemainConnected());	return err;}// ---------------------------------------------------------------------------------//		¥ ConnectPPP// ---------------------------------------------------------------------------------//	ConnectPPPOTResultCResidentIfInfo::ConnectPPP(InterfaceEntry_t* inInterfaceEntry){	OSStatus	err = kOTNoError;		if (!IsMonitoringPPP()) MonitorPPP(inInterfaceEntry);		// remember we've tried this before	if (mFirstPPPflag) {		mFirstPPPflag = false;	}	// remember inInterfaceEntry	if (inInterfaceEntry) {		mInterfaceEntry = *inInterfaceEntry;	}	// block on demand requests	if (mTestConnectionThread) {		mTestConnectionThread->Pause(90);	}	// report on demand traffic	if (gConnectionData->GetDataLinkState() == kLinkStateConnecting) {		struct strioctl	streamCommand;		NetNumber_t		addressParam;		LStr255 text;		Str31	str;				addressParam.address = 0;		SetupIoctl(&streamCommand, I_OnDemandConnect,			(char*)&addressParam, sizeof(proxy_network_t));		gProxyControl->ProxyIoctl(I_STR, &streamCommand);		text = "\p\rOn demand traffic";		if (addressParam.address) {			text += "\p from: ";			IP_NumToStr(addressParam.address, str);			text += str;		}		gLogAction->LogText(text);	}		// setup to tell proxy module about PPP events	gProxyControl->ProxyConnect();		// get corresponding control link object if needed	if (mControlLink == nil) {		GetPPPController(mInterfaceEntry.portName);		if (mControlLink) mControlLink->AddListener(this);	}		// try to connect	if (mControlLink) {		// Make PPP appear as primary interface		SetPrimaryIf(mInterfaceEntry.portName);		err = mControlLink->Connect(gGatewayData->GetDataShowPPPdialogs());		gConnectionData->SetDataLinkState( kLinkStateConnecting );	}	else {		err = kENXIOErr;	}	SetTickle(gGatewayData->GetDataRemainConnected());		return err;}// ---------------------------------------------------------------------------------//		¥ DisconnectPPP// ---------------------------------------------------------------------------------//	DisconnectPPPOTResultCResidentIfInfo::DisconnectPPP(InterfaceEntry_t* inInterfaceEntry){	OSStatus	err = kOTNoError;		if (!IsMonitoringPPP()) MonitorPPP(inInterfaceEntry);		// remember inInterfaceEntry	if (inInterfaceEntry) {		mInterfaceEntry = *inInterfaceEntry;	}	// disconnect dialup DNS client if any	if (gGatewayAction) gGatewayAction->DialupDNSClientStop(true);	// stop tickler if any	SetTickle(false);		// setup to tell proxy module about PPP events	gProxyControl->ProxyConnect();		// get corresponding control link object if needed	if (mControlLink == nil) {		GetPPPController(mInterfaceEntry.portName);		if (mControlLink) mControlLink->AddListener(this);	}		if (mControlLink) {		err = mControlLink->Disconnect(gGatewayData->GetDataShowPPPdialogs());		if (err == kOTNoError) {			gConnectionData->SetDataLinkState( kLinkStateDisconnecting );		} else {			gConnectionData->SetDataLinkState( kLinkStateIdle );		}	}	else {		err = kENXIOErr;	}		return err;}// ---------------------------------------------------------------------------------//		¥ RetryConnection// ---------------------------------------------------------------------------------//	Retry establishing PPP connection//	Return false if no more retries leftBooleanCResidentIfInfo::RetryConnection(){	Boolean result = false;		// if more retries and not reset	if ((mRetryCount > 0) && !mFirstPPPflag) {		mRetryCount -= 1;		result = true;			// setup to retry connection after a short delay		OTGetTimeStamp(&mStartTime);	// record start time		StartIdling();		gLogAction->LogText("\p\rRetry PPP connection in ", (mRetryDelayCurrent/1000));		gLogAction->LogText("\p seconds");	}	else {		// reset PPP retry state		if (mRetryCount == 0) {			// Out of retries, wait 10 minutes for on demand			// Reset PPP controller			ResetPPP();			// Create thread to test for reconnect if needed			if (!mTestConnectionThread && gGatewayData->GetDataDialOnDemand()) {				mTestConnectionThread = new CTestConnectionThread(this);				ThrowIfNil_(mTestConnectionThread);				mTestConnectionThread->Resume();			}			mTestConnectionThread->Pause(600);			gLogAction->LogText("\p\rRetries exhausted, wait 10 minutes and try again.");		}		mFirstPPPflag = true;		mRetryCount = kRetryCount;	}	return result;}// ---------------------------------------------------------------------------------//		¥ RetryConnection2// ---------------------------------------------------------------------------------//	Retry establishing PPP connectionOTResultCResidentIfInfo::RetryConnection2(){		OTResult	err = kOTNoError;	Str31		str;	gLogAction->LogText("\p\rRetry PPP connection, attempts remaining: ");	::NumToString(mRetryCount, str);	gLogAction->LogText(str);	gLogAction->Update();		if (mRetryCount > kRetryCount1) {		// first try PPP controller again		err = ConnectPPP(nil);	}	else {		gConnectionData->SetDataLinkState( kLinkStateIdle );		// remove interface		gInterfacesAction->RemoveInterface(&mInterfaceEntry, true);		// try to add it back		err = gInterfacesAction->DoInterfaceEntry(&mInterfaceEntry, true);		gInterfacesAction->UpdateInterfacesData();		gInterfacesData->SetDataInterfaceEntry(&mInterfaceEntry);		// If successful, re-initialize retry counter		if (err == kOTNoError) {			mRetryCount = kRetryCount;		}	}		return err;}// ---------------------------------------------------------------------------------//		¥ FinishConnection// ---------------------------------------------------------------------------------//	Finish bringing up interface after new PPP connection establishedvoidCResidentIfInfo::FinishConnection(Boolean inPortOnline){	DeviceEntry_t	deviceEntry;	UInt32			ipAddressBuffer;	OTResult		result;	UInt16			index;	short			outFlags;	enum {		kOTVersion250 = 0x02508000	};			do {		// Test if a previous PPP interface exists		result = gInterfacesAction->GetInterfaceFlags(mInterfaceEntry.interfaceName, &outFlags);		if (result == kOTNoError) {			// give PPP a chance to tell us its IP address			// find corresponding ipLinkStream			index = gDeviceData->FindDataDeviceArray(nil, mInterfaceEntry.portName, nil, &deviceEntry);			if (index && deviceEntry.ipLinkStream) {				// found link stream, try to get address via kernal API				ipAddressBuffer = 0;				struct strioctl	stri;				SetupIoctl(&stri, TCP_IOC_P2PCONFIG, (char*)&ipAddressBuffer, sizeof(InetHost));				result = ::OTStreamIoctl(deviceEntry.ipLinkStream, I_STR, &stri);				// set entry to use PPP address if any				if ((result == kOTNoError) && (ipAddressBuffer != 0)) {					mInterfaceEntry.interfaceAddr = ipAddressBuffer;					mInterfaceEntry.pppAddr = true;					mPPPlocalAddress  = ipAddressBuffer;					// try to get DNS address					ipAddressBuffer = 0;					SetupIoctl(&stri, TCP_IOC_DNSCONFIG, (char*)&ipAddressBuffer, sizeof(InetHost));					result = ::OTStreamIoctl(deviceEntry.ipLinkStream, I_STR, &stri);					if ((result == kOTNoError) && (ipAddressBuffer != 0)) {						mPPPDNSAddress  = ipAddressBuffer;						gLogAction->LogText("\p\rFinishConnection - DNS address from PPP server: ");						Str31 str;						IP_NumToStr(mPPPDNSAddress, str);						gLogAction->LogText(str);					}				}				else if (inPortOnline) {					gLogAction->LogText("\p\rCResidentInfo: unable to retrieve PPP address, OT result ", result);				}			} else {				// no link stream, try to get address from PPP controller				ipAddressBuffer = PPPGetAddress();				if (ipAddressBuffer != 0) {					mInterfaceEntry.interfaceAddr = ipAddressBuffer;					mPPPlocalAddress  = ipAddressBuffer;				} else {					gLogAction->LogText("\p\rCResidentInfo: PPP address not available.");					result = kEAGAINErr;				}			}			// If old PPP (not PortOnlineEvent)			if (!inPortOnline || (result != kOTNoError)) {				// remove previous interface so we can				// plumb a new PPP link stack and get its IP address					// skip IPCP under Mac OS 9				if ((!IsOT25()) ||					( !::EqualString(mInterfaceEntry.portName, "\pIPCP", false, false) )) {					gInterfacesAction->RemoveInterface(&mInterfaceEntry, true);				}			}		}		result = gInterfacesAction->DoInterfaceEntry(&mInterfaceEntry, true);		// check for port offline		if (mInterfaceEntry.interfaceAddr == kOffLineAddress) {			result = kEAGAINErr;		}		//if ((result != kOTNoError) && (mRetryCount > 0)) {		if ( ((result == kENXIOErr) ||			  (result == kOTDuplicateFoundErr) ||			  (result == kEAGAINErr)) &&			 (mRetryCount > 0) ) {			// try again in a little while			mRetryCount -= 1;			RestorePrimaryIf();			OTGetTimeStamp(&mStartTime);	// record start time			StartIdling();			break;		}		mPPPlocalAddress = mInterfaceEntry.interfaceAddr;		// update local address		// Success			// re-initialize retry counter		mRetryCount = kRetryCount;			// tell user what happened		gLogAction->LogText("\p\rPPP connection complete.");			// login dialupDNS client if enabled		if (gGatewayAction) gGatewayAction->DialupDNSClientStart();	} while (false);}// ---------------------------------------------------------------------------------//		¥ StopMonitoring// ---------------------------------------------------------------------------------//	Release control endpoint to stop monitoring PPPOTResultCResidentIfInfo::StopMonitoring(){	RestorePrimaryIf();	// Cleanup threads	//Reset(true);		// release control link object so we get a new one	if (mControlLink) {		mControlLink->RemoveListener(this);		delete mControlLink;		mControlLink = nil;	}	gConnectionData->SetDataLinkState( kLinkStateNone );	// release streams to proxy module	//gProxyControl->Terminate();		return kOTNoError;}// ---------------------------------------------------------------------------------//		¥ ResetPPP// ---------------------------------------------------------------------------------//	Release control endpoint to stop monitoring PPPvoidCResidentIfInfo::ResetPPP(){	// reset PPP controller	StopIdling();	DisconnectPPP(nil);	StopMonitoring();	gConnectionData->SetDataLinkState( kLinkStateIdle );	// wait before testing for on demand traffic again	if (mTestConnectionThread) mTestConnectionThread->Pause(30);	mFirstPPPflag = true;		// reset retry state}// ---------------------------------------------------------------------------------//		¥ IsPPPUp// ---------------------------------------------------------------------------------//	Test for PPP up//	Returns true if no access to PPP controllerBooleanCResidentIfInfo::IsPPPUp(){	Boolean		result = true;	// get corresponding control link object if needed	if (mControlLink == nil) {		GetPPPController(mInterfaceEntry.portName);		if (mControlLink) mControlLink->AddListener(this);	}	if (mControlLink) result = mControlLink->IsLinkUp();		return result;}// ---------------------------------------------------------------------------------//		¥ IsPPPComplete// ---------------------------------------------------------------------------------//	Test if FinishConnection() has completedBooleanCResidentIfInfo::IsPPPComplete(){	return (mRetryCount == kRetryCount);}// ---------------------------------------------------------------------------------//		¥ IsMonitoringPPP// ---------------------------------------------------------------------------------//	Test for Monitoring PPP//	Return false if no access to PPP controllerBooleanCResidentIfInfo::IsMonitoringPPP(){	Boolean		result = false;	if (mControlLink) {			result = mControlLink->IsMonitoring();	}		return result;}// ---------------------------------------------------------------------------------//		¥ PPPGetAddress// ---------------------------------------------------------------------------------//	Get PPP Local Protocol Address//	Return zero if address not availableUInt32CResidentIfInfo::PPPGetAddress(){	UInt32	theAddress = 0;		// get corresponding control link object if needed	if (mControlLink == nil) {		GetPPPController(mInterfaceEntry.portName);		if (mControlLink) mControlLink->AddListener(this);	}		if (mControlLink) theAddress = mControlLink->GetIpAddress();	return theAddress;}// ---------------------------------------------------------------------------------//		¥ PPPGetRemoteAddress// ---------------------------------------------------------------------------------//	Get PPP Remote Protocol Address//	Return zero if address not availableUInt32CResidentIfInfo::PPPGetRemoteAddress(){	UInt32	theAddress = 0;		// get corresponding control link object if needed	if (mControlLink == nil) {		GetPPPController(mInterfaceEntry.portName);		if (mControlLink) mControlLink->AddListener(this);	}		if (mControlLink) theAddress = mControlLink->GetRemoteAddress();	return theAddress;}// ---------------------------------------------------------------------------//		¥ SetPrimaryIf// ---------------------------------------------------------------------------//	Set primary interface in TCP/IP Preferences file.////	In order to configure an OT/PPP link stack, OT/PPP//	needs to be the primary interface.  This function//  modifies the selected TCP/IP configuration (Cmd-K)//  to match the specified "portName" if possible,//	and returns true if the configuration was actually//	changed.////	The two resources used in the TCP/IP Preferences file are://	'ccfg'	resource ID of the selected configuration//	'iitf'	data including pstring with port name at offset 13////	The previous interface ID is saved in 'mOldConfig_ResID'//	to be restored by RestorePrimaryIf().BooleanCResidentIfInfo::SetPrimaryIf(Str63 inPortName){	FSSpec 				fss;	LPreferencesFile*	prefsFile;	SInt16				cfg_id, id, new_id;	Str63				portStr;	Handle				resH;	OSStatus			err = kOTNoError;	Boolean				result = false;	Boolean				foundName = false;			// Get TCP/IP Preferences file	err = FindTCPPrefFile(&fss);	if (err != noErr) return result;	// Open the TCP/IP Preferences resource fork	prefsFile = new LPreferencesFile(fss);	ThrowIfNil_( prefsFile );	prefsFile->OpenOrCreateResourceFork(		fsCurPerm, (OSType)'ztcp', (OSType)'pref', smRoman ); // privs, creator, type, script		do {	// begin scope for resource objects			// get selected configuration		StResource ccfgR( (ResType)'ccfg',			1, false, true );			// inThrowFail, inGet1Resource		if (!ccfgR.mResourceH) break;	//  resource doesn't exist, get out		cfg_id = *(UInt16*)(*ccfgR.mResourceH);		// get corresponding portName from prefs file		StResource portR( (ResType)'iitf',			cfg_id, false, true );		// inThrowFail, inGet1Resource		if (!portR.mResourceH) break;	//  resource doesn't exist, get out		LString::CopyPStr( &((UInt8*)*portR.mResourceH)[13], portStr, sizeof(portStr) );		// if selected port matches desired port, get out		if (::EqualString(portStr, inPortName, true, true))			break;		// otherwise look for configuration with matching port		new_id = cfg_id;		for (id=128; id<144; id++) {			if ( ECGetResource((OSType)'iitf', (UInt16)id, &resH) == noErr ) {				LString::CopyPStr( &((UInt8*)*resH)[13], portStr, sizeof(portStr) );				::ReleaseResource(resH);				if ( ::EqualString(portStr, inPortName, true, true) ) {					new_id = id;					break;				}			}		}		// use configuration with 'cnam' mPPPName if any		for (id=128; id<144; id++) {			if ( ECGetResource((OSType)'cnam', (UInt16)id, &resH) == noErr ) {				short	theID;				ResType	theType;				::GetResInfo(resH, &theID, &theType, portStr);				::ReleaseResource(resH);				if ( ::EqualString(portStr, mPPPName, false, true) ) {					new_id = id;					foundName = true;					break;				}			}		}				// if we found a matching configuration		if (new_id != cfg_id) {			// make it the selected interface			*(UInt16*)(*ccfgR.mResourceH) = new_id;			::ChangedResource(ccfgR.mResourceH);			::WriteResource(ccfgR.mResourceH);			// save the previous selection			//if (mOldConfig_ResID == 0) 			mOldConfig_ResID = cfg_id;			mNewConfig_ResID = new_id;			result = true;		}					} while (false);	// end scope for resource objects (write out any changes)		// close preferences file	// *** caution only close file after resource objects are out of scope	prefsFile->CloseResourceFork();	delete prefsFile;	// set cfg_ID in prefs file//	StNewResource cfgState( (ResType)'mCfg',//		(ResIDT)rPPob_InterfacesWindow, kCfgStateSize, true );	// inDefaultSize, inGet1Resource//	((UInt8*)(*cfgState.mResourceH))[0] = mOldConfig_ResID;	if (result) {		LStr255 text;		text = "\p\rSet Primary Interface: ";		text += inPortName;		if (foundName) {			text += "\p (";			text += mPPPName;			text += "\p)";		}		gLogAction->LogText(text);	}		return result;}// ---------------------------------------------------------------------------//		¥ RestorePrimaryIf// ---------------------------------------------------------------------------//	Restore primary interface in TCP/IP Preferences file we modified aboveBooleanCResidentIfInfo::RestorePrimaryIf(){	FSSpec 				fss;	LPreferencesFile*	prefsFile;	SInt16				cfg_id;	Str63				portStr;	Boolean				result = false;	OSStatus			err = kOTNoError;	portStr[0] = 0;		// Is there a valid saved selection?	if (mOldConfig_ResID != 0) {				// Get TCP/IP Preferences file		err = FindTCPPrefFile(&fss);		if (err != noErr) return result;		// Open the TCP/IP Preferences resource fork		prefsFile = new LPreferencesFile(fss);		ThrowIfNil_( prefsFile );		prefsFile->OpenOrCreateResourceFork(			fsCurPerm, (OSType)'ztcp', (OSType)'pref', smRoman ); // privs, creator, type, script				do {	// begin scope for resource objects						// get selected configuration			StResource ccfgR( (ResType)'ccfg',				1, false, true );			// inThrowFail, inGet1Resource			if (!ccfgR.mResourceH) break;	//  resource doesn't exist, get out			cfg_id = *(UInt16*)(*ccfgR.mResourceH);						// if current selection was set by us and is different from saved selection			if ((mNewConfig_ResID == cfg_id) && (mOldConfig_ResID != cfg_id)) {				// restore saved selection				*(UInt16*)(*ccfgR.mResourceH) = mOldConfig_ResID;				::ChangedResource(ccfgR.mResourceH);				::WriteResource(ccfgR.mResourceH);				result = true;				// get corresponding portName from prefs file				StResource portR( (ResType)'iitf',					mOldConfig_ResID, false, true );		// inThrowFail, inGet1Resource				if (portR.mResourceH)					LString::CopyPStr( &((UInt8*)*portR.mResourceH)[13], portStr, sizeof(portStr) );			}					// reset saved selection			mOldConfig_ResID = 0;					} while (false);	// end scope for resource objects (write out any changes)				// close preferences file		// *** caution only close file after resource objects are out of scope		prefsFile->CloseResourceFork();		delete prefsFile;		if (result) {			gLogAction->LogText("\p\rRestore Primary Interface ");			gLogAction->LogText(portStr);		}	}	return result;}// ---------------------------------------------------------------------------//		¥ SetTickle// ---------------------------------------------------------------------------//	Set whether to tickle dial on demand connectionvoidCResidentIfInfo::SetTickle(Boolean inState){	if ( inState && IsMonitoringPPP() ) {		// Create thread to tickle interface every few minutes		if (!mTickleConnectionThread) {			mTickleConnectionThread = new CTickleConnectionThread(this);			ThrowIfNil_(mTickleConnectionThread);			// Launch thread to begin tickler			mTickleConnectionThread->Resume();		}		} else {		// stop tickler if any		if (mTickleConnectionThread) mTickleConnectionThread->Abort();	}}// ---------------------------------------------------------------------------//		¥ DoCleanup// ---------------------------------------------------------------------------//	Make sure the primary interface is restored even if program exits to shellvoidCResidentIfInfo::DoCleanup(){	RestorePrimaryIf();	DeregisterWithNSL();	CloseNSL();}// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------//	Listen for other notifications from endpoint//		BroadcastMessage(nextMessage->GetMessageType(), nextMessage);voidCResidentIfInfo::ListenToMessage(	MessageT	inEventCode,	void		*ioParam ){	CNetMessage* inMessage = (CNetMessage*)ioParam;	Str32		str;	Boolean		result;	switch ( inEventCode ) {		case kOTProviderWillClose:			gLogAction->LogText("\p\r### Network connection terminated.");			gLogAction->LogText("\p\r kOTProviderWillClose - Provider will close immediately.");			break;		case kOTProviderIsClosed:			gLogAction->LogText("\p\r### Network connection terminated.");			gLogAction->LogText("\p\r kOTProviderWillClose - Provider is closed.");			break;		case msg_BroadcasterDied:			break;		case kOTPortOnline:			RestorePrimaryIf();		// ***			gLogAction->LogText("\p\rkOTPortOnLine: PPP has reconnected.");			// tell our proxy module what happened			gProxyControl->ProxyIoctl(I_OnDemandUp, nil);			// stop idling to test for reconnect			if (mTestConnectionThread) mTestConnectionThread->Abort();			// finish connection process			mRetryCount = kRetryCount;			FinishConnection(true);			gConnectionData->SetDataLinkState( kLinkStateConnected );			break;		case msg_CallStarted:			gConnectionData->SetDataLinkState( kLinkStateConnecting );			break;					case msg_LinkUp:			RestorePrimaryIf();		// ***			// tell our proxy module what happened			gProxyControl->ProxyIoctl(I_OnDemandUp, nil);			// stop idling to test for reconnect			if (mTestConnectionThread) mTestConnectionThread->Abort();			// finish connection process			mRetryCount = kRetryCount;			FinishConnection(false);			gConnectionData->SetDataLinkState( kLinkStateConnected );			break;		case msg_LinkDown:			RestorePrimaryIf();		// ***			// tell user what happened			if (gConnectionData->GetDataLinkState() != kLinkStateIdle) {				gLogAction->LogText("\p\rPPP disconnected.");			}			// tell our proxy module what happened			gProxyControl->ProxyIoctl(I_OnDemandDown, nil);			// if pending operation, wait for asynch completion			if (gConnectionData->GetDataLinkState() != kLinkStateDisconnecting) {				// Create thread to test for reconnect				if (!mTestConnectionThread && gGatewayData->GetDataDialOnDemand()) {					mTestConnectionThread = new CTestConnectionThread(this);					if (mTestConnectionThread) mTestConnectionThread->Resume();				}				gConnectionData->SetDataLinkState( kLinkStateIdle );			}			break;		case msg_AsynchCompletion:			RestorePrimaryIf();			result = false;			if (gConnectionData->GetDataLinkState() == kLinkStateConnecting) {				gLogAction->LogText("\p\rPPP attempt did not complete.");				// try to recover				StopMonitoring();				MonitorPPP(nil);				result = RetryConnection();			}			if (!result && !IsPPPUp()) {				// tell our proxy module what happened				gProxyControl->ProxyIoctl(I_OnDemandDown, nil);				// Create thread to test for reconnect				if (!mTestConnectionThread && gGatewayData->GetDataDialOnDemand()) {					mTestConnectionThread = new CTestConnectionThread(this);					if (mTestConnectionThread) mTestConnectionThread->Resume();				}				// not connecting or no more retries & link is down				gConnectionData->SetDataLinkState( kLinkStateIdle );				gLogAction->LogText("\p\rAsnch Completion: link is not connected.");			}			//gInterfacesAction->SetForwarding(kForwardingAutomatic);			break;		case msg_ResetLink:			RestorePrimaryIf();		// ***			mPPPDNSAddress = 0;			// alternate reset procedure			if (mRetryCount%2) {				StopMonitoring();				MonitorPPP(nil);			} else {				DisconnectPPP(nil);			}			// try to recover			mRetryDelayCurrent = kRetryDelayLong + mRetryDelayInit;			result = RetryConnection();			break;		case kStreamIoctlEvent:			gLogAction->LogText("\p\rCResidentInfo:  kStreamIoctlEvent");			break;		default:			gLogAction->LogText("\p\rCResidentInfo unknown async message type: ");			IP_NumToHexStr(inEventCode, str);			gLogAction->LogText(str);	}}// ---------------------------------------------------------------------------//		¥ SpendTime// ---------------------------------------------------------------------------//	Periodical function to monitor PPP connection processvoidCResidentIfInfo::SpendTime(const EventRecord &inMacEvent){#pragma unused (inMacEvent)	UInt32		timeStamp;	OTResult	err;	const SInt16 kRetryIPDelay	= 2000;		timeStamp = OTElapsedMilliseconds(&mStartTime);	if (gConnectionData->GetDataLinkState() == kLinkStateIdle) {		// Link state is idle after a failed connection attempt		if ( timeStamp > mRetryDelayCurrent) {			// try again after mRetryDelay			StopIdling();			err = RetryConnection2();			if (err == kOTOutStateErr) {				mRetryDelayCurrent = kRetryDelayLong + mRetryDelayInit;			}			else mRetryDelayCurrent = mRetryDelayInit;		}	}	else if (gConnectionData->GetDataLinkState() == kLinkStateConnected) {		// PPP has connected and we're waiting to configure IP		if ( timeStamp > kRetryIPDelay) {			StopIdling();			FinishConnection(false);		}	}}// ---------------------------------------------------------------------------//		¥ ObjectThreadDied// ---------------------------------------------------------------------------//	A threaded operation has completed.voidCResidentIfInfo::ObjectThreadDied(LThread *inThread){			if (inThread == mRestoreThread) {		// get result		long result = *((long*)inThread->GetResult());		// indicate thread no longer exists		mRestoreThread = nil;		// handle results	}	else if (inThread == mTestConnectionThread) {		// get result		long result = *((long*)inThread->GetResult());		// indicate thread no longer exists		mTestConnectionThread = nil;		// handle results		if (result != kOTNoError) {			gLogAction->LogText("\p\rCTestConnectionThread terminated with result: ", result);		}	}	else if (inThread == mTickleConnectionThread) {		// get result		long result = *((long*)inThread->GetResult());		// indicate thread no longer exists		mTickleConnectionThread = nil;		// handle results		if (result != kOTNoError) {			gLogAction->LogText("\p\rCTickleConnectionThread terminated with result: ", result);		}	}}