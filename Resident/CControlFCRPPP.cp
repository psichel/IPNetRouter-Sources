// =================================================================================//	CControlFCRPPP.cp	 		©1997-98 Sustainable Softworks. All rights reserved.// =================================================================================//	Object to control PPP connection//	This object is a subclass of CControlLink#include "CompileFlags.h"#include "CControlFCRPPP.h"#include "CResidentIfInfo.h"#include "CLogAction.h"#include "MacSupport.h"#include "IPSupport.h"#include <LString.h>#include "DriverInterface.h"#include "StringUtilities.h"#include "ppp_api.h"// Globalsextern CLogAction*		gLogAction;// ---------------------------------------------------------------------------------//		¥ CControlFCRPPP()// ---------------------------------------------------------------------------------CControlFCRPPP::CControlFCRPPP(Str63 inPortName){	LString::CopyPStr(inPortName, mPortName, sizeof(Str63));	// initialization	mDriver = nil;	mLastTime = 0;	mState = kStateNone;}// ---------------------------------------------------------------------------------//		¥ ~CControlFCRPPP// ---------------------------------------------------------------------------------CControlFCRPPP::~CControlFCRPPP(){	Terminate();}// ---------------------------------------------------------------------------------//		¥ Terminate// ---------------------------------------------------------------------------------voidCControlFCRPPP::Terminate(){	StopIdling();	mState = kStateNone;	// release the driver object we created	if (mDriver) delete mDriver;}#pragma mark --- public API ---// ---------------------------------------------------------------------------------//		¥ StartMonitoring// ---------------------------------------------------------------------------------//	Open a PPP control endpoint to begin monitoring PPP stateOTResultCControlFCRPPP::StartMonitoring(Boolean inShowDialogs){	OSStatus	err = kOTNoError;		try {		do {			// get FCR PPP driver if needed			if (mDriver == nil) {				mDriver = new DriverInterface("\p"PPP_DRVR_NAME);				if (!mDriver) {					err = kENXIOErr;					break;				}				err = mDriver->OpenPPPDriver();				if (err != noErr) {					// try alternate driver name					delete mDriver;					mDriver = new DriverInterface("\p"FCR_DRVR_NAME);					if (!mDriver) {						err = kENXIOErr;						break;					}					err = mDriver->OpenPPPDriver();					if (err != noErr) {						gLogAction->LogText("\p\rError opening FCR PPP driver.");						delete mDriver;						mDriver = nil;						break;					}											}			}						// start idling to check connection state at regular intervals			if (mState == kStateNone) {				mState = kStateIdle;				mLastTime = ::TickCount();				StartIdling();			}		} while (false);	}	catch (const LException& inErr) {		err = inErr.GetErrorCode();	} 	return err;}// ---------------------------------------------------------------------------------//		¥ StopMonitoring// ---------------------------------------------------------------------------------OTResultCControlFCRPPP::StopMonitoring(){	StopIdling();	mState = kStateNone;	// release FCR PPP driver we created if any	if (mDriver) delete mDriver;	mDriver = nil;		return kOTNoError;}// ---------------------------------------------------------------------------------//		¥ Connect// ---------------------------------------------------------------------------------//	BringUpPPP//	Open a PPP control endpoint//	Install notifier to monitor for events//	If not connected, try to connectOTResultCControlFCRPPP::Connect(Boolean inShowDialogs){	OSStatus	err = kOTNoError;		try {			do {				// get driver if needed			err = StartMonitoring(inShowDialogs);				if (err != kOTNoError) break;			// tell driver to dial			err = mDriver->Dial();			if (err != noErr) {				gLogAction->LogText("\p\rError telling FCR PPP driver to dial.");				break;			}			mState = kStatePendingUp;		} while (false);	}	catch (const LException& inErr) {		err = inErr.GetErrorCode();	} 		if (err != kOTNoError) BroadcastMessage(msg_AsynchCompletion, this);	return err;}// ---------------------------------------------------------------------------------//		¥ Disconnect// ---------------------------------------------------------------------------------//	Disconnect dial on demand linkOTResultCControlFCRPPP::Disconnect(Boolean inShowDialogs){	OSStatus	err = kOTNoError;		try {		do {				// get driver if needed			err = StartMonitoring(inShowDialogs);				if (err != kOTNoError) break;			// tell driver to hangup			err = mDriver->HangUp();			if (err != noErr) {				gLogAction->LogText("\p\rError telling FCR PPP driver to hang up.");				break;			}			mState = kStatePendingDown;					} while (false);	}	catch (const LException& inErr) {		err = inErr.GetErrorCode();	} 		if (err != kOTNoError) BroadcastMessage(msg_AsynchCompletion, this);	return err;}// ---------------------------------------------------------------------------------//		¥ IsLinkUp// ---------------------------------------------------------------------------------//	Test for PPP upBooleanCControlFCRPPP::IsLinkUp(){	Boolean	result = false;	if (mDriver) {		if ( mDriver->IsIPCPUp() ) result = true;	}	return result;}// ---------------------------------------------------------------------------------//		¥ IsMonitoring// ---------------------------------------------------------------------------------//	Test for Monitoring PPP stateBooleanCControlFCRPPP::IsMonitoring(){	Boolean	result = false;	if (mDriver) result = true;	return result;}// ---------------------------------------------------------------------------------//		¥ GetIPAddress// ---------------------------------------------------------------------------------//	Get PPP Local Protocol Address//	Return zero if address not availableUInt32CControlFCRPPP::GetIpAddress(){	OSStatus	err = kOTNoError;	UInt32		theAddress = 0;		try {		if (mDriver) theAddress = mDriver->GetClientIP();	}	catch (const LException& inErr) {		err = inErr.GetErrorCode();	} 		return theAddress;}// ---------------------------------------------------------------------------------//		¥ GetRemoteAddress// ---------------------------------------------------------------------------------//	Get PPP Remote Protocol Address//	Return zero if address not availableUInt32CControlFCRPPP::GetRemoteAddress(){	OSStatus	err = kOTNoError;	UInt32		theAddress = 0;		try {		if (mDriver) theAddress = mDriver->GetServerIP();	}	catch (const LException& inErr) {		err = inErr.GetErrorCode();	} 		return theAddress;}#pragma mark --- private support functions ---// ---------------------------------------------------------------------------//		¥ SpendTime// ---------------------------------------------------------------------------//	Periodical function to wait for PPP connection process to finishvoidCControlFCRPPP::SpendTime(const EventRecord &inMacEvent){#pragma unused (inMacEvent)	OSStatus	err = kOTNoError;	short	theScriptResult;	short	theConnectionStatus;	UInt32	thisTime;		thisTime = ::TickCount();	if ( ((thisTime - mLastTime) > kTestInterval) && mDriver ) {		mLastTime = thisTime;				try {						switch (mState) {				case kStatePendingUp:					theConnectionStatus = mDriver->GetDriverStatus();					if (theConnectionStatus == STATUS_STALLED ||						theConnectionStatus == STATUS_FAULT ||						theConnectionStatus == STATUS_TIMEOUT ||						theConnectionStatus == STATUS_CLOSING) {						// connection attempt did not succeed						BroadcastMessage(msg_AsynchCompletion, this);						mState = kStateDown;						//delete mDriver;						//mDriver = nil;					}					else if (theConnectionStatus == STATUS_DONE) {						theScriptResult = mDriver->GetScriptResult();						if (theScriptResult) {							// script error while dialing							BroadcastMessage(msg_AsynchCompletion, this);							mState = kStateDown;							//delete mDriver;							//mDriver = nil;											} else {							// connection succeeded							BroadcastMessage(msg_LinkUp, this);							BroadcastMessage(msg_AsynchCompletion, this);							mState = kStateUp;							}					}					else if ((theConnectionStatus == STATUS_PPP) ||					    	 (theConnectionStatus == STATUS_SLIP)) {						if ( mDriver->IsIPCPUp() ) {							// connection must have succeeded							BroadcastMessage(msg_LinkUp, this);							BroadcastMessage(msg_AsynchCompletion, this);							mState = kStateUp;							}					}					break;				case kStatePendingDown:					theConnectionStatus = mDriver->GetDriverStatus();					if (theConnectionStatus == STATUS_IDLE) {						BroadcastMessage(msg_LinkDown, this);						BroadcastMessage(msg_AsynchCompletion, this);						mState = kStateDown;						}					break;				default:					if ( mDriver->IsIPCPUp() ) {						if (mState != kStateUp) {							mState = kStateUp;							BroadcastMessage(msg_LinkUp, this);						}					}					else {						if (mState != kStateDown) {							mState = kStateDown;							BroadcastMessage(msg_LinkDown, this);						}									}					break;			}				}		catch (const LException& inErr) {			err = inErr.GetErrorCode();		} 		catch(...) {		    SysBeep(30);		} 	}}