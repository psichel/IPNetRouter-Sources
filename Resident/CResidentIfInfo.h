// =================================================================================//	CResidentIfInfo.h	 			©1997 Sustainable Softworks. All rights reserved.// =================================================================================//	Interface Info we need to keep resident in memory#ifndef _H_CResidentIfInfo#define _H_CResidentIfInfo#pragma once#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import on#endif#include <LListener.h>#include <LCleanupTask.h>#include <LPreferencesFile.h>#include <UResourceMgr.h>#include <UModalDialogs.h>#include <LCaption.h>#include <OpenTransport.h>#include <OpenTptPPP.h>#include "CNatTask.h"#include "CInterfacesData.h"#include "CRoutesData.h"#include "CObjectMaster.h"struct InterfaceInfo {	Str63		portName;	Str63		interfaceName;	Str63		userPortName;	SInt32		ipLinkId;	SInt32		arpLinkId;	Boolean		needArp;	Boolean		needPPP;	Boolean		isMacIP;};typedef struct InterfaceInfo InterfaceInfo_t;class CTurboUDPEndpoint;class CRestoreThread;class CTestConnectionThread;class CTickleConnectionThread;class CSendUDPThread;class CControlLink;class CConfigDocument;class CResidentIfInfo : public LCleanupTask, LListener, LPeriodical, CObjectMaster {public:	enum { class_ID = 'CRIf' };							CResidentIfInfo();	virtual		 			~CResidentIfInfo();	void				Reset(Boolean inCanWait=true);	void				InitNSL();	OSStatus			RegisterWithNSL(Str255 inAddrStr);	OSStatus			DeregisterWithNSL();	void				CloseNSL();	Boolean				DoRestore();	Boolean				SetPrimaryIf(Str63 inPortName);	Boolean				RestorePrimaryIf();	Boolean				GetPPPController(Str63 inPortName);	OTResult			MonitorPPP(InterfaceEntry_t* inInterfaceEntry);	OTResult			ConnectPPP(InterfaceEntry_t* inInterfaceEntry);	OTResult			DisconnectPPP(InterfaceEntry_t* inInterfaceEntry);	OTResult			StopMonitoring();	void				ResetPPP();	Boolean				IsPPPUp();	Boolean				IsPPPComplete();	Boolean				IsMonitoringPPP();	UInt32				PPPGetAddress();	UInt32				PPPGetRemoteAddress();	void				SetTickle(Boolean inState);	void				DoCleanup();	virtual void		ListenToMessage( MessageT inMessage, void *ioParam );	void				ObjectThreadDied(LThread *inThread);	// shared resident data	Str63				mOnDemandName;		// name of on demand interface driver	Str63				mPPPName;			// name of PPP configuration	UInt32				mPseudoGateway;		// PPP pseudo gateway	UInt32				mPPPlocalAddress;	// PPP local protocol address	UInt32				mPPPDNSAddress;		// DNS address from PPP server	UInt32				mDHCPinterface;		// hashed name of DHCP interface if any	NetNumber_t			mDHCPNet;			// DHCP dynamically assigned IP address	NetNumber_t			mDHCPSavedNet;		// DHCP saved address to be ignored	SInt16				mRetryCount;		// PPP retry count	Boolean				mFirstPPPflag;		// first PPP connection attemptprotected:	Boolean				RetryConnection();	OTResult			RetryConnection2();	void				FinishConnection(Boolean inPortOnline);	virtual void		SpendTime(const EventRecord &inMacEvent);	// PPP control		CControlLink*		mControlLink;	ResIDT				mOldConfig_ResID;	// save ResID of primary If in TCP/IP Prefs	ResIDT				mNewConfig_ResID;	// save ResID of temporary If in TCP/IP Prefs	UInt32				mLinkState;			// state of PPP link	InterfaceEntry_t	mInterfaceEntry;	// interfaceEntry to be configured	OTTimeStamp			mStartTime;			// mark start of delay interval	UInt32				mRetryDelayCurrent;	// delay from mStartTime to launch next attempt	UInt32				mRetryDelayInit;	// Thread objects	CRestoreThread*		mRestoreThread;				// restore thread object	CTestConnectionThread* mTestConnectionThread;	// test for reconnection needed	CTickleConnectionThread* mTickleConnectionThread;	// NSL 1.1 and 1.0	UInt8				mNSLRegisterState;	LStr255				mNSLServiceName;	// NSL 1.0 only	UInt32 				mNSLClientRef;	void*				mNSLDataPtr;private:	};// constantsconst SInt16 kIndexAtEnd				= 1024;		// a large value past end of arrayconst UInt32 kOffLineAddress			= 0xA9FEFFFE;	// 169.254.255.254const SInt16 kReconnectDelay			= 80;		// delay (ticks) to test for reconnectconst SInt16 kCfgStateSize				= 4;		// size of configuration state resourceconst SInt16 kRetryCount				= 6;		// initial PPP retriesconst SInt16 kRetryCount1				= 1;const SInt32 kRetryDelayShort			= 5000;		// delay (ms) before next retryconst SInt32 kRetryDelayLong			= 15000;	// 15 secondsconst SInt16 kNSLRegisterNone			= 0;const SInt16 kNSLRegister10				   = 1;const SInt16 kNSLRegister11				   = 2;#endif