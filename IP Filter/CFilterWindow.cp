// =================================================================================//	CFilterWindow.cp			©1998 Sustainable Softworks All rights reserved.// =================================================================================//	IP Filter Window#include "CompileFlags.h"#include "CFilterWindow.h"#include "CFilterConst.h"#include "CInterfacesWindow.h"#include "CIPNumberEditField.h"#include "IPRouterCommon.h"#include "CSubnetCalcWindow.h"#include "UIPNumKeyFilters.h"#include "CFilterTable.h"#include "CMultiCaption.h"#include "MacSupport.h"#include "IPSupport.h"#include "CLogAction.h"#include "CHelpWindow.h"#include <UReanimator.h>#include <LString.h>#include <LPreferencesFile.h>#include <UResourceMgr.h>#include <LArrayIterator.h>#include <OpenTransport.h>#include "CFilterData.h"#include "CFilterAction.h"#include "CDeviceData.h"#include "CGatewayData.h"// Globalsextern CLogAction*		gLogAction;extern CFilterData*		gFilterData;extern CFilterAction*	gFilterAction;extern CDeviceData*		gDeviceData;extern CGatewayData*	gGatewayData;// ---------------------------------------------------------------------------------//		¥ CFilterWindow(LStream*)// ---------------------------------------------------------------------------------CFilterWindow::CFilterWindow(	LStream	*inStream )		: CWindow( inStream ){	// initialization	mFilterPortPopup = nil;	mDirectionPopup = nil;	mActionPopup = nil;	mProtocolPopup = nil;	mAckFlagPopup = nil;	mSourceNetField = nil;	mSourcePortsField = nil;	mDestNetField = nil;	mDestPortsField = nil;}// ---------------------------------------------------------------------------------//		¥ ~CFilterWindow// ---------------------------------------------------------------------------------CFilterWindow::~CFilterWindow(){	// disconnect from filter data	gFilterData->RemoveListener(this);}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------//	Finish creating the Tuner window.voidCFilterWindow::FinishCreateSelf(){	MenuHandle	theMenuH;	SInt16		count;	// setup up Filter display table	// get the table view	mFilterTable = (CFilterTable*) this->FindPaneByID( kFilterTablePane );	ThrowIfNil_( mFilterTable );	mFilterTable->SetWindow(this);	// tell table it's parent window	// set column widths (inWidth, inFromCol, inToCol)	mFilterTable->SetColWidth(kWidthFilterPort,	1, 1);	mFilterTable->SetColWidth(kWidthDirection,	2, 2);	mFilterTable->SetColWidth(kWidthAction,		3, 3);	mFilterTable->SetColWidth(kWidthProtocol,	4, 4);	mFilterTable->SetColWidth(kWidthAckFlag,	5, 5);	mFilterTable->SetColWidth(kWidthNetwork,	6, 6);	mFilterTable->SetColWidth(kWidthPort,		7, 7);	mFilterTable->SetColWidth(kWidthNetwork,	8, 8);	mFilterTable->SetColWidth(kWidthPort,		9, 9);	// setup up table captions	CMultiCaption	*theCaption;	theCaption = (CMultiCaption*) this->FindPaneByID( kFilterTableCaptionPane );	ThrowIfNil_( theCaption );	// customize the caption widths to match table outline	theCaption->SetColWidth(kWidthFilterPort,	1, 1);	theCaption->SetColWidth(kWidthDirection,	2, 2);	theCaption->SetColWidth(kWidthAction,		3, 3);	theCaption->SetColWidth(kWidthProtocol,		4, 4);	theCaption->SetColWidth(kWidthAckFlag,		5, 5);	theCaption->SetColWidth(kWidthNetwork,		6, 6);	theCaption->SetColWidth(kWidthPort,			7, 7);	theCaption->SetColWidth(kWidthNetwork,		8, 8);	theCaption->SetColWidth(kWidthPort,			9, 9);		// Link the window (the listener) with the controls in	// the window (the broadcasters).	UReanimator::LinkListenerToControls(		(CFilterWindow *)this, this, rRidL_FilterWindow );	// setup pointer to status caption	mStatusCaption = (LCaption*)FindPaneByID( kStatusCaption );	ThrowIfNil_(mStatusCaption);	// setup pointer to popups	mDirectionPopup = (LStdPopupMenu*)this->FindPaneByID( kDirectionPopup );	ThrowIfNil_(mDirectionPopup);	mActionPopup = (LStdPopupMenu*)this->FindPaneByID( kActionPopup );	ThrowIfNil_(mActionPopup);	mProtocolPopup = (LStdPopupMenu*)this->FindPaneByID( kProtocolPopup );	ThrowIfNil_(mProtocolPopup);	mAckFlagPopup = (LStdPopupMenu*)this->FindPaneByID( kAckFlagPopup );	ThrowIfNil_(mAckFlagPopup);	mIcmpTypesPopup = (LStdPopupMenu*)this->FindPaneByID( kIcmpTypesPopup );	ThrowIfNil_(mIcmpTypesPopup);	mSourceNetField = (CIPNumberEditField*)this->FindPaneByID( kSourceNetField );	ThrowIfNil_(mSourceNetField);	mSourcePortsField = (LEditField*)this->FindPaneByID( kSourcePortsField );	ThrowIfNil_(mSourcePortsField);	mDestNetField = (CIPNumberEditField*)this->FindPaneByID( kDestNetField );	ThrowIfNil_(mDestNetField);	mDestPortsField = (LEditField*)this->FindPaneByID( kDestPortsField );	ThrowIfNil_(mDestPortsField);		// setup protocol port names popup	mProtocolPortNamesPopup = (LStdPopupMenu*)this->FindPaneByID( kProtocolPortNamesPopup );	ThrowIfNil_(mProtocolPortNamesPopup);	//UpdateMenu();	mProtocolPortNamesPopup->Enable();	mProtocolPortNamesPopup->Show();		// setup FilterPort menu	mFilterPortPopup = (LStdPopupMenu*)this->FindPaneByID( kFilterPortPopup );	ThrowIfNil_(mFilterPortPopup);	((CInterfacesWindow*)mSuperCommander)->LoadPortMenu(mFilterPortPopup);	// create a default item for "All"	theMenuH = mFilterPortPopup->GetMacMenuH();	::AppendMenu(theMenuH, kPortNameAllStr);	// count how many items we got and set max value	count = ::CountMItems(theMenuH);	mFilterPortPopup->SetMaxValue(count);	mFilterPortPopup->SetValue(0);	// show default value	mFilterPortPopup->SetValue(1);	// connect to filter data	gFilterData->AddListener(this);	// load the Filter table	gFilterAction->UpdateFilterData();	UpdateTable();	// update Filter entry in Window	FilterEntry_t filterEntry;	gFilterData->GetDataFilterEntry(&filterEntry);	DisplayFilterEntry(&filterEntry);}/*voidCFilterWindow::UpdateMenu(){	MenuHandle	theMenuH;	SInt16		count;	theMenuH = mProtocolPortNamesPopup->GetMacMenuH();	count = ::CountMItems(theMenuH);//	if (count == 0)		::AppendResMenu(theMenuH, 'STRP');	count = ::CountMItems(theMenuH);	mProtocolPortNamesPopup->SetMaxValue(count);	mProtocolPortNamesPopup->Enable();}voidCFilterWindow::ActivateSelf(){	LWindow::ActivateSelf();	UpdateMenu();//	::HiliteWindow(mMacWindowP, true);//	DrawSizeBox();}*/// ---------------------------------------------------------------------------//		¥ HandleKeyPress// ---------------------------------------------------------------------------//	Handle <Return>, <Enter> passed up from an EditField////	Return true if the Window handles the keystrokeBooleanCFilterWindow::HandleKeyPress(	const EventRecord&	inKeyEvent){	Boolean		keyHandled = true;	LControl	*keyButton = nil;	SInt16		theKey = inKeyEvent.message & charCodeMask;	switch (theKey) {			//case char_Enter:		//case char_Return:		//	keyButton =  (LControl*) FindPaneByID(kAddButton);		//	break;		case char_UpArrow:			if (inKeyEvent.modifiers & cmdKey) {//				menuChoice = mPortNamePopup->GetValue();//				if (menuChoice > 1) {//					menuChoice -= 1;//					mPortNamePopup->SetValue(menuChoice);//				}			}			break;		case char_DownArrow:			if (inKeyEvent.modifiers & cmdKey) {//				menuChoice = mPortNamePopup->GetValue();//				if (menuChoice < mPortNamePopupMax) {//					menuChoice += 1;//					mPortNamePopup->SetValue(menuChoice);//				}			}			break;		default:			if (UKeyFilters::IsCmdPeriod(inKeyEvent)) {				// reset PPP controller				//keyButton =  (LControl*) FindPaneByID(kTestButtonPane);			} else {				keyHandled = CWindow::HandleKeyPress(inKeyEvent);			}			break;	}				if (keyButton != nil) {		keyButton->SimulateHotSpotClick(kControlButtonPart);		keyHandled = true;	}		return keyHandled;}// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------voidCFilterWindow::ListenToMessage(	MessageT	inEventCode,	void		*ioParam ){	LNetMessage* 	inMessage = (LNetMessage*)ioParam;	FilterEntry_t	filterEntry;	OSStatus 		err = noErr;	try {		switch ( inEventCode ) {						case msg_SignalDataEvent:				// handle change to filter Data				UInt32 dataID = *(UInt32*)ioParam;				if (dataID == DATA_ID(kFilterData, kDataFilterEntry)) {					// Filter parameter data has changed										gFilterData->GetDataFilterEntry(&filterEntry);					DisplayFilterEntry(&filterEntry);				}				else if (dataID>>16 == kFilterData) {					// a row in the filter array has changed					TableIndexT	row;					row = dataID & 0xFFFF;					if (row > kDataFilterArrayOffset) {						row -= kDataFilterArrayOffset;						// try to get data for this row						if (gFilterData->GetDataFilterArray(row, &filterEntry)) {							// got it, update table							mFilterTable->SetFilterEntry(row, &filterEntry);						}						else {							// no data, row must have been deleted							mFilterTable->ClearRow(row);						}					}				}				break;						case msg_AddButton:			case msg_RemoveButton:				DoCommand(inEventCode);				gFilterData->SignalDataChange();				break;						case msg_UpdateButton:				gFilterAction->UpdateFilterData();				break;			case kFilterPortPopup:			case kDirectionPopup:			case kActionPopup:			case kAckFlagPopup:				break;			case kProtocolPopup:				if (mProtocolPopup->GetValue() == kProtocolMenuICMP) {					mProtocolPortNamesPopup->Hide();					mProtocolPortNamesPopup->Disable();					mIcmpTypesPopup->Enable();					mIcmpTypesPopup->Show();								} else {					mIcmpTypesPopup->Hide();					mIcmpTypesPopup->Disable();					mProtocolPortNamesPopup->Enable();					mProtocolPortNamesPopup->Show();				}				break;			case kProtocolPortNamesPopup:				{					MenuHandle	theMenuH;					Handle		h;					SInt32		value;					short		theID;					ResType		theType;					Str31		name;					// get protocol name					theMenuH = mProtocolPortNamesPopup->GetMacMenuH();					value = mProtocolPortNamesPopup->GetValue();					::GetMenuItemText( theMenuH, value, name );					// find corresponding resource to determine port#					h=::GetNamedResource ('STRP', name);					if (h != nil) {						::GetResInfo(h, &theID, &theType, name);						value = theID - kPortStart;						//mSourcePortsField->SetValue(value);						mDestPortsField->SetValue(value);						if (value == 0) {							//mSourcePortsField->SetDescriptor("\p*");							mDestPortsField->SetDescriptor("\p*");						}					}				}				break;			case kIcmpTypesPopup:				switch(mIcmpTypesPopup->GetValue()) {					case 1:						mSourcePortsField->SetValue(0);						mDestPortsField->SetValue(0);						break;					case 2:						mSourcePortsField->SetValue(3);						mDestPortsField->SetValue(3);						break;					case 3:						mSourcePortsField->SetValue(4);						mDestPortsField->SetValue(4);						break;					case 4:						mSourcePortsField->SetValue(5);						mDestPortsField->SetValue(5);						break;					case 5:						mSourcePortsField->SetValue(8);						mDestPortsField->SetValue(8);						break;					case 6:						mSourcePortsField->SetValue(11);						mDestPortsField->SetValue(11);						break;					case 7:						mSourcePortsField->SetValue(12);						mDestPortsField->SetValue(12);						break;					case 8:						mSourcePortsField->SetValue(13);						mDestPortsField->SetValue(13);						break;					case 9:						mSourcePortsField->SetValue(14);						mDestPortsField->SetValue(14);						break;					case 10:						mSourcePortsField->SetValue(17);						mDestPortsField->SetValue(17);						break;					case 11:						mSourcePortsField->SetValue(18);						mDestPortsField->SetValue(18);						break;				}				break;			case msg_HelpButton:											// Create the Help Window				CHelpWindow		*theWindow;				theWindow = (CHelpWindow*)InvokeWindow(kNameHelp, this);				theWindow->Show();				theWindow->LoadTextInWindow(rTEXT_FilterHelp);				break;		}	}	catch (const LException& inErr) {		Str31 errStr;		::NumToString( inErr.GetErrorCode(), errStr);		::ParamText(errStr, nil, nil, nil);		UDesktop::Deactivate();		// Alert will swallow Deactivate event		::Alert(ALRT_OTError, nil);		UDesktop::Activate();	} 	catch (...) {		gLogAction->LogText("\p\rCFilterWindow::ListenToMessage unexpected Exception");		::SysBeep(1);	}}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	Respond to commandsBooleanCFilterWindow::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;//	GrafPtr		theWindowP;	LWindow*	theWindow;//	LEditField*	theEditField;//	Str255		str;	switch (inCommand) {		case cmd_SubnetCalculator:			// Create the Subnet Calculator Window			theWindow = InvokeWindow(kNameSubnetCalculator, mSuperCommander);			theWindow->Show();//			theEditField = (LEditField*) this->FindPaneByID( kIPAddressField );//			ThrowIfNil_(theEditField);//			theEditField->GetDescriptor(str);//			((CSubnetCalcWindow*)theWindow)->InvokeSubnetCalcWindow(str);			break;					default:			cmdHandled = CWindow::ObeyCommand(inCommand, ioParam);			break;	}	return cmdHandled;}#pragma mark --- Window Display ---// ---------------------------------------------------------------------------------//		¥ UpdateTable// ---------------------------------------------------------------------------------//	Update Filter Table from data ojbectvoidCFilterWindow::UpdateTable(){	ArrayIndexT		num;	ArrayIndexT		index;	FilterEntry_t	filterEntry;		num = gFilterData->GetDataCount();	for (index=1; index<=num; index++) {		if (gFilterData->GetDataFilterArray(index, &filterEntry)) {			mFilterTable->SetFilterEntry(index, &filterEntry);		} else {			mFilterTable->ClearRow(index);		}	}}// ---------------------------------------------------------------------------------//		¥ DisplayFilterEntry// ---------------------------------------------------------------------------------//	Display Filter Entry in window edit fieldsvoidCFilterWindow::DisplayFilterEntry(FilterEntry_t*	inFilterEntry){	DeviceEntry_t		info;	MenuHandle			theMenuH;	UInt8				count;	short				i;	Str63				str;	LStr255				text;	do {		// filter port		if (gDeviceData->HashFindDataDeviceArray(inFilterEntry->portName, &info)) {			// set popup to match user Name in IfInfo						theMenuH = mFilterPortPopup->GetMacMenuH();			count = ::CountMItems(theMenuH);			// look for match			for (i=1; i<= count; i++) {				::GetMenuItemText( theMenuH, i, str );				if (::EqualString(info.userPortName, str, true, false)) {					mFilterPortPopup->SetValue(i);					break;				}			}		}		// set flags		if (inFilterEntry->flags & kFlagDirectionRead)			mDirectionPopup->SetValue(1);		else mDirectionPopup->SetValue(2);				UInt16 action = inFilterEntry->flags & kFlagActionMask;		action = action >> 1;		mActionPopup->SetValue(action+1);				if (inFilterEntry->flags & kFlagAck) mAckFlagPopup->SetValue(2);		else if (inFilterEntry->flags & kFlagNoAck) mAckFlagPopup->SetValue(3);		else mAckFlagPopup->SetValue(1);		// set protocol		if (inFilterEntry->protocol == kProtocolTCP) {			mProtocolPopup->SetValue(kProtocolMenuTCP);		}		else if (inFilterEntry->protocol == kProtocolUDP) {			mProtocolPopup->SetValue(kProtocolMenuUDP);		}		else if (inFilterEntry->protocol == kProtocolICMP) {			mProtocolPopup->SetValue(kProtocolMenuICMP);		}		else if (inFilterEntry->protocol == 0) {			mProtocolPopup->SetValue(kProtocolMenuAny);		}		// sourceNet		IP_NetToStr( inFilterEntry->sourceNet, str );		text = str;		if (inFilterEntry->sourceNet.address == 0) text = "\p*";		mSourceNetField->SetDescriptor( text );				// sourcePort		NumToString( inFilterEntry->sourcePorts.lo, str );		text = str;		if ((inFilterEntry->sourcePorts.lo == 0) &&		    (inFilterEntry->sourcePorts.hi == 0) &&		    (inFilterEntry->protocol != kProtocolICMP)) text = "\p*";		else {			if (inFilterEntry->sourcePorts.hi != 0) {				::NumToString( inFilterEntry->sourcePorts.hi, str );				text += "\p-";				text += str;			}		}		mSourcePortsField->SetDescriptor( text );		// destNet		IP_NetToStr( inFilterEntry->destNet, str );		text = str;		if (inFilterEntry->destNet.address == 0) text = "\p*";		mDestNetField->SetDescriptor( text );				// destPort		NumToString( inFilterEntry->destPorts.lo, str );		text = str;		if ((inFilterEntry->destPorts.lo == 0) &&		    (inFilterEntry->destPorts.hi == 0) &&		    (inFilterEntry->protocol != kProtocolICMP)) text = "\p*";		else {			if (inFilterEntry->destPorts.hi != 0) {				::NumToString( inFilterEntry->destPorts.hi, str );				text += "\p-";				text += str;			}		}		mDestPortsField->SetDescriptor( text );	} while (false);}// ---------------------------------------------------------------------------------//		¥ DoCommand// ---------------------------------------------------------------------------------voidCFilterWindow::DoCommand(MessageT inEventCode){	OTResult			result = kOTNoError;	FilterEntry_t		filterEntry;	DeviceEntry_t		info;	MenuHandle			theMenuH;	UInt8				pos;	Str63				str;		// set filter entry from edit fields	bzero((UInt8*)&filterEntry, sizeof(FilterEntry_t));	// filter port	theMenuH = mFilterPortPopup->GetMacMenuH();	::GetMenuItemText( theMenuH, mFilterPortPopup->GetValue(), str );	if (gDeviceData->FindDataDeviceArray(str, nil, nil, &info)) {		filterEntry.portName = HashName(info.portName);	} else filterEntry.portName = 0;	// flags	filterEntry.flags = 0;	if (mDirectionPopup->GetValue()	== 1) filterEntry.flags	|= kFlagDirectionRead;	UInt16 action = mActionPopup->GetValue() - 1;	filterEntry.flags |= (action << 1) & kFlagActionMask;	if (mAckFlagPopup->GetValue()	== 2) filterEntry.flags	|= kFlagAck;	if (mAckFlagPopup->GetValue()	== 3) filterEntry.flags	|= kFlagNoAck;	if (inEventCode == msg_AddButton) filterEntry.flags		|= kFlagFilterActive;	// set entryID to zero (new entry)	filterEntry.entryID = 0;	// protocol	switch(mProtocolPopup->GetValue()) {		case kProtocolMenuTCP:			filterEntry.protocol = kProtocolTCP;			break;		case kProtocolMenuUDP:			filterEntry.protocol = kProtocolUDP;			break;		case kProtocolMenuICMP:			filterEntry.protocol = kProtocolICMP;			break;		case kProtocolMenuAny:			filterEntry.protocol = 0;			break;	}	// sourceNet	filterEntry.sourceNet.address = mSourceNetField->GetValue();	pos = mSourceNetField->GetValueLength();		// if no prefix length given, use 32		// use network zero to match any	if (pos == 0) pos = 32;	filterEntry.sourceNet.mask = 0xFFFFFFFF << (32 - pos);		// sourcePorts	{		SInt32				port;		LStr255				fieldStr;		LStr255				part;		filterEntry.sourcePorts.lo = 0;		filterEntry.sourcePorts.hi = 0;		mSourcePortsField->GetDescriptor( fieldStr );		pos = fieldStr.Find( '-' );		if (pos == 0) {			// simple port number			if ( IsDigitString(fieldStr) ) {				::StringToNum(fieldStr, &port);				filterEntry.sourcePorts.lo = port;			}		}		else {			// port range A-B			part.Assign(fieldStr, 1, pos-1);			if ( IsDigitString(part) ) {				::StringToNum(part, &port);				filterEntry.sourcePorts.lo = port;			}			part.Assign(fieldStr, pos+1);			if ( IsDigitString(part) ) {				::StringToNum(part, &port);				filterEntry.sourcePorts.hi = port;			}		}	}	// destNet	filterEntry.destNet.address = mDestNetField->GetValue();	pos = mDestNetField->GetValueLength();		// if no prefix length given, use 32		// use network zero to match any	if (pos == 0) pos = 32;	filterEntry.destNet.mask = 0xFFFFFFFF << (32 - pos);		// destPorts	{		SInt32				port;		LStr255				fieldStr;		LStr255				part;		filterEntry.destPorts.lo = 0;		filterEntry.destPorts.hi = 0;		mDestPortsField->GetDescriptor( fieldStr );		pos = fieldStr.Find( '-' );		if (pos == 0) {			// simple port number			if ( IsDigitString(fieldStr) ) {				::StringToNum(fieldStr, &port);				filterEntry.destPorts.lo = port;			}		}		else {			// port range A-B			part.Assign(fieldStr, 1, pos-1);			if ( IsDigitString(part) ) {				::StringToNum(part, &port);				filterEntry.destPorts.lo = port;			}			part.Assign(fieldStr, pos+1);			if ( IsDigitString(part) ) {				::StringToNum(part, &port);				filterEntry.destPorts.hi = port;			}		}	}	// issue command	result = gFilterAction->DoFilterEntry(&filterEntry);	// show user what happened	IoctlResponse(result);}// ---------------------------------------------------------------------------------//		¥ IoctlResponse// ---------------------------------------------------------------------------------//	IoctlResponse - an ioctl completed process the resultvoidCFilterWindow::IoctlResponse(long inResult){	switch (inResult) {		case 0:				// no error			mStatusCaption->SetDescriptor("\pOK");			break;		case kProxyAddError:			mStatusCaption->SetDescriptor("\pFilter Table error adding entry.");			break;				case kProxyDelError:			mStatusCaption->SetDescriptor("\pMatching entry not found.");			break;				case kOTNotFoundErr:			mStatusCaption->SetDescriptor("\pkOTNotFoundErr.");			break;				case kEINVALErr:			mStatusCaption->SetDescriptor("\pkEINVALErr - Invalid parameter.");			break;		case kOTDuplicateFoundErr:					mStatusCaption->SetDescriptor("\pkOTDuplicateFoundErr.");			break;		case kEBUSYErr:			mStatusCaption->SetDescriptor("\pkEBUSYErr - Device or resource busy.");			break;		case kENXIOErr:			mStatusCaption->SetDescriptor("\pNo such device or address.");			break;		default:			{				LStr255	status;				status = "\pioctl unexpected result code: ";				Str32 str;				NumToString(inResult, str);				status += str;				mStatusCaption->SetDescriptor( status );			}			break;	}	// end switch}