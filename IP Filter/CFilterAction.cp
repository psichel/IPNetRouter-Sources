// =================================================================================//	CFilterAction.cp			©1998 Sustainable Softworks All rights reserved.// =================================================================================//	IP Filter Actions#include "CompileFlags.h"#include "CFilterAction.h"#include "CFilterConst.h"#include "CInterfacesWindow.h"#include "CConfigDocument.h"#include "CIPNumberEditField.h"#include "IPRouterCommon.h"#include "CSubnetCalcWindow.h"#include "UIPNumKeyFilters.h"#include "CFilterTable.h"#include "CMultiCaption.h"#include "MacSupport.h"#include "IPSupport.h"#include "CLogAction.h"#include <UReanimator.h>#include <LString.h>#include <LPreferencesFile.h>#include <UResourceMgr.h>#include <LArrayIterator.h>#include <OpenTransport.h>#include <OpenTptConfig.h>#include <OpenTptInternet.h>#include <OpenTptLinks.h>#include <LOpenTptTCPEndpoint.h>#include "CReceiveUDPThread.h"#include "CSendUDPThread.h"#include "CTurboUDPEndpoint.h"#include "ProxyModule.h"#include "CResidentIfInfo.h"#include "CProxyControl.h"#include "CFilterData.h"#include "CDeviceData.h"#include "CGatewayData.h"// Globalsextern CLogAction*		gLogAction;extern CResidentIfInfo*	gResInfo;extern CProxyControl*	gProxyControl;extern CFilterData*		gFilterData;extern CDeviceData*		gDeviceData;extern CGatewayData*	gGatewayData;// ---------------------------------------------------------------------------------//		¥ CFilterAction(LStream*)// ---------------------------------------------------------------------------------CFilterAction::CFilterAction(){	// initialization	mEndpoint = nil;	mReceiveUDPThread = nil;	mNeedInit = true;}// ---------------------------------------------------------------------------------//		¥ ~CFilterAction// ---------------------------------------------------------------------------------CFilterAction::~CFilterAction(){	// disconnect from filter data//	gFilterData->RemoveListener(this);	Terminate();}// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------voidCFilterAction::ListenToMessage(	MessageT	inEventCode,	void		*ioParam ){	LNetMessage* 	inMessage = (LNetMessage*)ioParam;	OSStatus 		err = noErr;	try {		switch ( inEventCode ) {													// Endpoint notifications			case kOTProviderWillClose:				gLogAction->LogText("\p\r### Network connection terminated.");				gLogAction->LogText("\p\r kOTProviderWillClose - Provider will close immediately.");				break;			case kOTProviderIsClosed:			case msg_BroadcasterDied:				break;			case kStreamIoctlEvent:				gLogAction->LogText("\p\rCFilterAction - IOCTL event code: ", inMessage->GetResultCode());				break;			default:				gLogAction->LogText("\p\rCFilterAction unknown async message type: ");				Str32 str;				IP_NumToHexStr(inEventCode, str);				gLogAction->LogText(str);				//gLogAction->LogText("\p\r  Result code: ");				//NumToString(inMessage->GetResultCode(), str);				//gLogAction->LogText(str);		}	}	catch (const LException& inErr) {		gLogAction->LogText("\p\rCFilterAction::ListenToMessage unexpected result from OT: ", inErr.GetErrorCode());		::SysBeep(1);	} 	catch (...) {		gLogAction->LogText("\p\rCFilterAction::ListenToMessage unexpected Exception");		::SysBeep(1);	}}// ---------------------------------------------------------------------------//		¥ ReceiveData// ---------------------------------------------------------------------------//	Some data came in from the network.voidCFilterAction::ReceiveData(LDataArrived* inMessage){	void* 			inData;			// data that arrived	//UInt32		inDataSize;		// size of the data	//LInternetAddress* inRemoteAddress;	UInt8 i;	FilterEntry_t*	filterEntry;		// setup access to message data and remote address	inData = inMessage->GetDataBuffer();	//inDataSize = inMessage->GetDataSize();	//inRemoteAddress = inMessage->GetRemoteAddress();	// update table data	dl_filter_message_t* dp = (dl_filter_message_t*)inData;			if (dp->dl_primitive == DL_FILTER_MESSAGE) {		if ((0 < dp->dl_number) && (dp->dl_number <= kFilterMessageDim)) {			for (i=0; i<dp->dl_number; i++) {				filterEntry = &dp->array[i];				// update filter data as needed				mUpdateRow += 1;				gFilterData->SetDataFilterArray(mUpdateRow, filterEntry);							}		}		// end of table?		if (dp->dl_status == 0) {			// yes, set filter data count			gFilterData->SetDataCount(mUpdateRow);			// reset update row in case another update is in the queue			mUpdateRow = 0;		}			}}// ---------------------------------------------------------------------------------//		¥ LastComplete// ---------------------------------------------------------------------------------//	Release the endpoints we created after all threads that depend on them//	have safely terminated.voidCFilterAction::LastComplete(){	if (mReceiveUDPThread == nil) {		// Release the endpoints we created		if (mEndpoint) {			// no longer want notification of endpoint events			mEndpoint->RemoveListener(this);			delete mEndpoint;			mEndpoint = nil;		}	}}// ---------------------------------------------------------------------------//		¥ ObjectThreadDied// ---------------------------------------------------------------------------//	A threaded operation has completed.voidCFilterAction::ObjectThreadDied(LThread *inThread) {			// Receive Thread completed?	if (inThread == mReceiveUDPThread) {		// get result		long result = *((long*)inThread->GetResult());		// indicate thread no longer exists		mReceiveUDPThread = nil;		// handle results		switch (result) {			case 0:				// no error			case Abort_Error:	// operation aborted				break;			default:				// write to log window if any				gLogAction->LogText("\p\r### CFilterAction CReceiveUDPThread unexpected event code: ", result);				break;		}	// end switch		if (result != 0) {			// Thread died due to Endpoint event,			//  just stop any Monitoring in progress			//PauseMonitor();		}			// Release the endpoints we created		LastComplete();	}}#pragma mark --- Proxy Module Accessors ---// ---------------------------------------------------------------------------------//		¥ Init I/O with our Proxy module// ---------------------------------------------------------------------------------voidCFilterAction::Init(){	OTResult err;	mNeedInit = false;		//	Create a tcp endpoint to force the InetConfigurator to fire	//	(blocks until TCP/IP is ready)	err = gProxyControl->AsyncOpenAndClose();	if (err != kOTNoError) {		gLogAction->LogText("\p\rCFilterAction::Init() unexpected result from OT: ", err);	}	// Register module as a streams Driver so we can open a control stream to it	gProxyControl->SetupPort();	// Create a connectionless endpoint to our "Proxy" driver		// used to send IOCTLs and receive filter data	if (!mEndpoint) {		mEndpoint = new CTurboUDPEndpoint("Proxy");		ThrowIfNil_(mEndpoint);		// Register to receive other event notifications (including Ioctl responses)		mEndpoint->AddListener(this);	}}// ---------------------------------------------------------------------------------//		¥ Terminate I/O with our Proxy module// ---------------------------------------------------------------------------------voidCFilterAction::Terminate(Boolean inCanWait){	mNeedInit = true;	// 	// Release thread objects we created	if (mReceiveUDPThread) mReceiveUDPThread->Abort();	if (inCanWait) {		// Wait for threads to abort normally		UInt8 retryLimit = 16;		while (	(mReceiveUDPThread != nil) ) {			LThread::Yield();			retryLimit -= 1;			if (retryLimit == 0) break;		}	}	// if threads didn't complete, cleanup as best we can	if (mReceiveUDPThread) {		mReceiveUDPThread->DeleteThread();		mReceiveUDPThread = nil;	}	// Release the Endpoints we created	if (mEndpoint) {		mEndpoint->RemoveListener(this);		delete mEndpoint;		mEndpoint = nil;	}}// ---------------------------------------------------------------------------------//		¥ LoadFilterConfig// ---------------------------------------------------------------------------------//	Add or Delete Filter entries for imported dataOTResultCFilterAction::LoadFilterConfig(CFilterData* inFilterData){	OTResult		result = kOTNoError;	TableIndexT		configRow;	SInt32			configNum;	FilterEntry_t	configEntry;	TableIndexT		tableRow;	SInt32			tableNum;	FilterEntry_t	tableEntry;	if (mNeedInit) Init();		do {		if (inFilterData == nil) break;		// nothing to config		configNum = inFilterData->GetDataCount();		tableNum = gFilterData->GetDataCount();		if ((configNum == 0) && (tableNum == 0)) break;				// for each existing entry in table		for (tableRow=1; tableRow<=tableNum; tableRow++) {			gFilterData->GetDataFilterArray(tableRow, &tableEntry);			configEntry.flags &= ~kFlagDone;			// check against entries in new configuration			for (configRow=1; configRow<=configNum; configRow++) {				inFilterData->GetDataFilterArray(configRow, &configEntry);				if ( gFilterData->EqualFilterEntry(&tableEntry, &configEntry) ) {					// config is already in table, set Done flag to ignore config entry					configEntry.flags |= kFlagDone;					inFilterData->SetDataFilterArray(configRow, &configEntry);					break;				}			}			// did we find it?			if ((configEntry.flags & kFlagDone == 0) && !gGatewayData->GetDataAddOnly()) {				// table entry is not in config, remove it				tableEntry.flags &= ~kFlagFilterActive;				result = DoFilterEntry(&tableEntry, false);	 // don't update				// set to continue stepping through table//				tableNum = gFilterData->GetDataCount();//				if (tableRow > 1) tableRow -= 1;			}		}		// try to apply each saved config		for (configRow=configNum; configRow>=1; configRow--) {			if (inFilterData->GetDataFilterArray(configRow, &configEntry)) {				if (configEntry.flags & kFlagDone) continue;	// ignore entries we marked above				result = DoFilterEntry(&configEntry, false);				if (result != kOTNoError) {					// command failed, update filter entry so it will appear in window					gFilterData->SetDataFilterEntry(&configEntry);					gLogAction->LogText("\p\rLoadFilterConfig OT result: ", result);					//break;				}			}		}				UpdateFilterData();	} while (false);		return result;}// ---------------------------------------------------------------------------------//		¥ RestoreFilterConfig// ---------------------------------------------------------------------------------//	Apply filters in gFilterDataOTResultCFilterAction::RestoreFilterConfig(){	OTResult		result = kOTNoError;	TableIndexT		row;	TableIndexT		numTableE;	FilterEntry_t	tableEntry;	if (mNeedInit) Init();		numTableE = gFilterData->GetDataCount();	// try to apply each saved config	for (row=numTableE; row>=1; row--) {		// get entry		if (gFilterData->GetDataFilterArray(row, &tableEntry)) {			// mark as new			tableEntry.entryID = 0;			// try to apply			result = DoFilterEntry(&tableEntry, false);			if (result != kOTNoError) {				// command failed, update filter entry so it will appear in window				gFilterData->SetDataFilterEntry(&tableEntry);				if (result < 0) gLogAction->LogText("\p\rRestoreFilterConfig OT result: ", result);				if (result == kProxyAddError) gLogAction->LogText("\p\rRestoreFilterConfig kProxyAddError");				//break;			}		}	}			UpdateFilterData();		return result;}// ---------------------------------------------------------------------------------//		¥ UpdateFilterData// ---------------------------------------------------------------------------------//	Update Filter Data object from Proxy moduleOTResultCFilterAction::UpdateFilterData(){	OTResult result = kOTNoError;	if (mNeedInit) Init();	// Create thread object to receive filter data	if (!mReceiveUDPThread) {		mReceiveUDPThread = new CReceiveUDPThread(			(CObjectMaster*)	this,			(CTurboUDPEndpoint*) mEndpoint);		ThrowIfNil_(mReceiveUDPThread);		// launch thread to begin I/O		mReceiveUDPThread->Resume();	}	// Prepare to update table	mUpdateRow = 0;	// Send IOCTL to request filter data	result = DoIoctl(I_GetFilters, nil);	//IoctlResponse(result);		if (result != kOTNoError) {		gLogAction->LogText("\p\rFilter table not updated.");	}		return result;}// ---------------------------------------------------------------------------------//		¥ DoFilterEntry// ---------------------------------------------------------------------------------//	Add or Delete Filter entry per configOTResultCFilterAction::DoFilterEntry(FilterEntry_t* inEntry, Boolean inUpdate){	OTResult	result;	struct strioctl	stri;	if (mNeedInit) Init();	// tell user what we're about to do	LStr255	text;	Str255 str;	text = "\p\r";	gFilterData->FilterEntryToString(inEntry, str);	text += str;	gLogAction->LogText(text);	// setup ioctl	if (inEntry->flags & kFlagFilterActive) {			SetupIoctl(&stri, I_AddFilterEntry, (char*)inEntry, sizeof(FilterEntry_t));	}	else {				SetupIoctl(&stri, I_DelFilterEntry, (char*)inEntry, sizeof(FilterEntry_t));	}	// send ioctl	result = gProxyControl->ProxyIoctl(I_STR, &stri);	if (inUpdate) UpdateFilterData();		return result;}// ---------------------------------------------------------------------------------//		¥ DoIoctl// ---------------------------------------------------------------------------------//	Send synchronous ioctl to proxy moduleOTResultCFilterAction::DoIoctl(UInt32 inCmd, void* inData){	OTResult	result;	EndpointRef	ep;		if (mEndpoint) {		// get OT endpoint ref		ep = mEndpoint->GetEndpointRef();				// set synchronous		::OTSetSynchronous(ep);		// issue requested ioctl		result = ::OTIoctl(ep, inCmd, inData);				// restore to asynchronous		::OTSetAsynchronous(ep);	}	else result = kOTBadReferenceErr;		return result;}