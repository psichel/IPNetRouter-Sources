// =================================================================================//	CFilterTable.cp				©1998 Sustainable Softworks All rights reserved.// =================================================================================//	Table object to display trace route information#include "CFilterTable.h"#include "CFilterConst.h"#include "CFilterWindow.h"#include "CResidentIfInfo.h"#include "CDeviceData.h"#include "CConfigDocument.h"#include "Cwindow.h"#include "CSubnetCalcWindow.h"//#include "CPingWindow.h"#include <PP_Messages.h>#include "AGAColors.h"#include "CIPRouterApp.h"#include "IPRouterCommon.h"#include "IPSupport.h"#include "MacSupport.h"#include "CIPNumberEditField.h"#include <LString.h>#include <Icons.h>#include "ICAPI.h"#include "CFilterData.h"// Globalsextern CIPRouterApp*	gAppObject;extern ICInstance		gICInstance;extern CResidentIfInfo*	gResInfo;extern CDeviceData*		gDeviceData;// ---------------------------------------------------------------------------------//		¥ CFilterTable(LStream*)// ---------------------------------------------------------------------------------CFilterTable::CFilterTable(	LStream	*inStream )		: CConfigureTable( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CFilterTable// ---------------------------------------------------------------------------------CFilterTable::~CFilterTable(){}#pragma mark --- Data and Selection ---// ---------------------------------------------------------------------------//		¥ Click Cell// ---------------------------------------------------------------------------//  Handle click in cell.//	Display table entry in window edit fieldsvoidCFilterTable::ClickCell(	const TableCellT		&inCell,	const SMouseDownEvent&	inMouseDown){	FilterEntry_t	filterEntry;	TableCellT		theCell;	TableItemW		tData;	SelectRow(inCell, false);	// ( ,extendFlag)	// check for double click	if (GetClickCount() == 2) {			// Get IP Address from clicked row of table		theCell.row = inCell.row;		theCell.col = kColumnSourceNet;		GetCellData( theCell, &tData );				// Found an address, try to invoke ping		if (tData.hi != 0) {			// ping test			LaunchURL("\pping://");		}	} else {		if (GetFilterEntry(inCell.row, &filterEntry))			((CFilterWindow*)mWindow)->DisplayFilterEntry(&filterEntry);	}}#pragma mark --- Filter Entry ---// ---------------------------------------------------------------------------------//		¥ GetFilterEntry// ---------------------------------------------------------------------------------//	Get Port Map Entry from TableBooleanCFilterTable::GetFilterEntry(TableIndexT inRow, FilterEntry_t* outEntry){	TableCellT	theCell;	TableItemW	tData;	Boolean		result = true;	do {		// check for valid row entry		theCell.row = inRow;		theCell.col = kColumnFilterPort;		GetCellData(theCell, &tData);		if (tData.hi == kItemNone) {			result = false;			break;		}		// get entry		// hashed port name		outEntry->portName		= tData.hi;		// get flags (we store the value of flags in kColumnDirection)		theCell.col = kColumnDirection;		GetCellData(theCell, &tData);		outEntry->flags = tData.hi;			// clear wamnet parameter			outEntry->flags &= ~kFlagWamnet;		// protocol				theCell.col = kColumnProtocol;		GetCellData(theCell, &tData);		outEntry->protocol = tData.hi;		// sourceNet		theCell.col = kColumnSourceNet;		GetCellData(theCell, &tData);		outEntry->sourceNet.address = tData.hi;		outEntry->sourceNet.mask = tData.lo;		// sourcePorts		theCell.col = kColumnSourcePorts;		GetCellData(theCell, &tData);		outEntry->sourcePorts.lo = tData.lo;		outEntry->sourcePorts.hi = tData.hi;		// destNet		theCell.col = kColumnDestNet;		GetCellData(theCell, &tData);		outEntry->destNet.address = tData.hi;		outEntry->destNet.mask = tData.lo;		// destPorts		theCell.col = kColumnDestPorts;		GetCellData(theCell, &tData);		outEntry->destPorts.lo = tData.lo;		outEntry->destPorts.hi = tData.hi;	} while (false);	return result;}// ---------------------------------------------------------------------------------//		¥ SetFilterEntry// ---------------------------------------------------------------------------------//	Set Filter Entry in Table//	Refresh row if entry was changedvoidCFilterTable::SetFilterEntry(TableIndexT inRow, FilterEntry_t* inEntry){	TableCellT	theCell;	TableItemW	tData, uData;	Boolean		result = false;	do {		// check for valid row entry		if (inRow > kMaxFilterTableRows) {			result = false;			break;		}		// insert rows if needed		if (inRow > mRows) {			tData.hi = 0;			tData.lo = 0;			InsertRows(inRow-mRows, mRows, &tData);	// how many, after row, *data		}		theCell.row = inRow;		// set entry			// port name		theCell.col = kColumnFilterPort;		tData.hi = inEntry->portName;		GetCellData(theCell, &uData);		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}			// flags		theCell.col = kColumnDirection;		GetCellData(theCell, &uData);		tData.hi = inEntry->flags;		// flags are kept in kColumnDirection		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}					// protocol		theCell.col = kColumnProtocol;		GetCellData(theCell, &uData);		tData.hi = inEntry->protocol;		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}			// sourceNet		theCell.col = kColumnSourceNet;		GetCellData(theCell, &uData);		tData.hi = inEntry->sourceNet.address;		tData.lo = inEntry->sourceNet.mask;		if ((tData.hi != uData.hi) || (tData.lo != uData.lo)) {			SetCellData(theCell, &tData);			result = true;		}			// source ports		theCell.col = kColumnSourcePorts;		GetCellData(theCell, &uData);		tData.lo = inEntry->sourcePorts.lo;		tData.hi = inEntry->sourcePorts.hi;		if ((tData.hi != uData.hi) || (tData.lo != uData.lo)) {			SetCellData(theCell, &tData);			result = true;		}			// destNet		theCell.col = kColumnDestNet;		GetCellData(theCell, &uData);		tData.hi = inEntry->destNet.address;		tData.lo = inEntry->destNet.mask;		if ((tData.hi != uData.hi) || (tData.lo != uData.lo)) {			SetCellData(theCell, &tData);			result = true;		}			// destPorts		theCell.col = kColumnDestPorts;		GetCellData(theCell, &uData);		tData.lo = inEntry->destPorts.lo;		tData.hi = inEntry->destPorts.hi;		if ((tData.hi != uData.hi) || (tData.lo != uData.lo)) {			SetCellData(theCell, &tData);			result = true;		}	} while (false);	if (result) RefreshRow(inRow);}#pragma mark --- Drawing ---// ---------------------------------------------------------------------------//		¥ Draw Cell// ---------------------------------------------------------------------------voidCFilterTable::DrawCell(	const TableCellT	&inCell){	Rect		cellFrame;	TableItemW	tData, uData;	TableCellT	tCell;	Str31		str;	LStr255		text;	DeviceEntry_t	info;	OSErr		err = NoError;	if (FetchLocalContentFrame(inCell, cellFrame)) {		// draw white background		::PenNormal();		ApplyForeAndBackColors();		::EraseRect(&cellFrame);		// draw border around cell		::InsetRect(&cellFrame, -1, -1);		::PenPat(&UQDGlobals::GetQDGlobals()->gray);		if (PaneInColor (this)) {			StColorState	saveColor;			RGBColor		emptyColor;			emptyColor = gAGAColorArray[6];			::RGBForeColor(&emptyColor);			::FrameRect(&cellFrame);		} else { ::FrameRect(&cellFrame); }		::PenPat(&UQDGlobals::GetQDGlobals()->black);				// draw contents		::TextFont(applFont);		::TextFace(0);	// normal		::TextSize(9);		// Get cell data		GetCellData( inCell, &tData );		// Handle each column		    // filter flags are stored in kColumnDirection		switch (inCell.col) {		case kColumnFilterPort:			tCell.row = inCell.row;			tCell.col = kColumnDirection;			GetCellData( tCell, &uData );			if (uData.hi != kItemNone) {	// valid entry    			MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);    			if (gDeviceData->HashFindDataDeviceArray(tData.hi, &info)) {    				DrawString( info.userPortName );    			}    			else DrawString( "\p*" );    		}			break;		case kColumnDirection:						tCell.row = inCell.row;			tCell.col = kColumnDirection;			GetCellData( tCell, &uData );			if (uData.hi != kItemNone) {	// valid entry				MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);				if (tData.hi & kFlagDirectionRead) text = kDirectionReadStr;				else text = kDirectionWriteStr;				DrawString( text );			}			break;		case kColumnAction:						tCell.row = inCell.row;			tCell.col = kColumnDirection;			GetCellData( tCell, &uData );			if (uData.hi != kItemNone) {	// valid entry				MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);				// flags are stored in kColumnDirection				tCell.col = kColumnDirection;				GetCellData( tCell, &tData );				UInt16 action = tData.hi & kFlagActionMask;				action = action >> 1;				if      (action == kFilterPass)     text = kActionPassStr;				else if (action == kFilterReject)   text = kActionRejectStr;				else if (action == kFilterNoDial)   text = kActionNoDialStr;				else if (action == kFilterTrigger)  text = kActionTriggerStr;				else if (action == kFilterLog)  	text = kActionLogStr;				DrawString( text );			}			break;		case kColumnProtocol:			tCell.row = inCell.row;			tCell.col = kColumnDirection;			GetCellData( tCell, &uData );			if (uData.hi != kItemNone) {	// valid entry				MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);				switch (tData.hi) {					case kProtocolICMP:						DrawString("\pICMP");						break;					case kProtocolUDP:						DrawString("\pUDP");						break;					case kProtocolTCP:						DrawString("\pTCP");						break;					case kProtocolAny:						DrawString("\p*");						break;					default:						::NumToString( tData.hi, str );						DrawString(str);						break;				}			}			break;		case kColumnAckFlag:						tCell.row = inCell.row;			tCell.col = kColumnDirection;			GetCellData( tCell, &uData );			if (uData.hi != kItemNone) {	// valid entry				MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);				text = "\p*";				// flags are stored in kColumnDirection				tCell.col = kColumnDirection;				GetCellData( tCell, &tData );				if (tData.hi & kFlagAck) text = kFlagAckStr;				else if (tData.hi & kFlagNoAck) text = kFlagNoAckStr;				DrawString( text );			}			break;		case kColumnSourceNet:			// display network as CIDR aggregate (addr/len)			tCell.row = inCell.row;			tCell.col = kColumnDirection;			GetCellData( tCell, &uData );			if (uData.hi != kItemNone) {	// valid entry				MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);				IP_NumToStr( tData.hi, str );				text = str;				if (tData.hi == 0) text = "\p*";				else {					if (tData.hi == 1) text = "\pdynamic";					tData.lo = FindRightBit(tData.lo, 32);					::NumToString(tData.lo, str);					text += "\p/";					text += str;				}				DrawString(text);			}			break;		case kColumnSourcePorts:			// source ports			tCell.row = inCell.row;			tCell.col = kColumnDirection;			GetCellData( tCell, &uData );			if (uData.hi != kItemNone) {	// valid entry				MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);				NumToString( tData.lo, str );				text = str;				// 0 is different for ICMP				tCell.col = kColumnProtocol;				GetCellData( tCell, &uData );				if ((tData.lo == 0) && (tData.hi == 0) && (uData.hi != kProtocolICMP)) text = "\p*";				else {					if (tData.hi != 0) {						NumToString( tData.hi, str );						text += "\p-";						text += str;					}					else {						// not a port range, display port number as text						tCell.col = kColumnProtocol;						GetCellData( tCell, &uData );						// unless protocol is ICMP						if (uData.hi != kProtocolICMP)							PortToString((tData.lo), text);					}				}				DrawString(text);			}			break;		case kColumnDestNet:			// display network as CIDR aggregate (addr/len)			tCell.row = inCell.row;			tCell.col = kColumnDirection;			GetCellData( tCell, &uData );			if (uData.hi != kItemNone) {	// valid entry				MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);				IP_NumToStr( tData.hi, str );				text = str;				if (tData.hi == 0) text = "\p*";				else {					if (tData.hi == 1) text = "\pdynamic";					tData.lo = FindRightBit(tData.lo, 32);					::NumToString(tData.lo, str);					text += "\p/";					text += str;				}				DrawString(text);			}			break;		case kColumnDestPorts:			// dest ports			tCell.row = inCell.row;			tCell.col = kColumnDirection;			GetCellData( tCell, &uData );			if (uData.hi != kItemNone) {	// valid entry				MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);				NumToString( tData.lo, str );				text = str;				// 0 is different for ICMP				tCell.col = kColumnProtocol;				GetCellData( tCell, &uData );				if ((tData.lo == 0) && (tData.hi == 0) && (uData.hi != kProtocolICMP)) text = "\p*";				else {					if (tData.hi != 0) {						NumToString( tData.hi, str );						text += "\p-";						text += str;					}					else {						// not a port range, display port number as text						tCell.col = kColumnProtocol;						GetCellData( tCell, &uData );						// unless protocol is ICMP						if (uData.hi != kProtocolICMP)							PortToString((tData.lo), text);					}				}				DrawString(text);			}			break;		default:								// ### Debugging								// Draw cell row & column number inside								// frame of cell			::MoveTo(cellFrame.left + 8, cellFrame.bottom - 4);				Str31	str;			NumToString(inCell.row, str);			DrawString(str);			DrawString("\p,");			NumToString(inCell.col, str);			DrawString(str);		}	}}