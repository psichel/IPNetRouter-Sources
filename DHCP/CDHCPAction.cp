// =================================================================================//	CDHCPAction.cp			©1998 Sustainable Softworks All rights reserved.// =================================================================================//	DHCP Actions object#include "CompileFlags.h"#include "CDHCPAction.h"#include "CDHCPConst.h"#include "CDHCPData.h"#include "CArpData.h"#include "CArpAction.h"#include "CInterfacesData.h"#include "CInterfacesAction.h"#include "CGatewayData.h"#include "LInternetAddress.h"#include "CProxyControl.h"#include "IPRouterCommon.h"#include "MacSupport.h"#include "IPSupport.h"#include "CLogAction.h"#include <UReanimator.h>#include <LString.h>#include <LPreferencesFile.h>#include <UResourceMgr.h>#include <LArray.h>#include <LComparator.h>#include <LArrayIterator.h>#include <UMemoryMgr.h>#include <UOpenTptSupport.h>#include "CReceiveUDPThread.h"#include "CSendUDPThread.h"#include "CTurboUDPEndpoint.h"#include <OpenTransport.h>#include <OpenTptConfig.h>#include <OpenTptInternet.h>#include <LInternetMapper.h>#include <LOpenTptInetMapper.h>#include <OpenTptLinks.h>//#include <modnames.h>			// names of the standard OT modules.// Globalsextern CLogAction*			gLogAction;extern CDHCPData*			gDHCPData;extern CInterfacesData*		gInterfacesData;extern CInterfacesAction*	gInterfacesAction;extern CGatewayData*		gGatewayData;extern CArpAction*			gArpAction;extern CProxyControl*		gProxyControl;// ---------------------------------------------------------------------------------//		¥ CDHCPAction()// ---------------------------------------------------------------------------------CDHCPAction::CDHCPAction(){	// other initialization	mReceiveUDPThread = nil;	mSendUDPThread = nil;	mReceiveICMPThread = nil;	mSendICMPThread = nil;	mUDPEndpoint = nil;	mICMPEndpoint = nil;	mResponseArray = nil;	mIsServing = false;	mWaitingToRestart = false;	mDHCPRetryCount = kDHCPRetryCount;		mPingCounter = 0;	mStartTime = 0;	mIdleDelay = kIdleDefault;	// connect to DHCP data	gDHCPData->AddListener(this);}// ---------------------------------------------------------------------------------//		¥ ~CDHCPAction// ---------------------------------------------------------------------------------CDHCPAction::~CDHCPAction(){	gDHCPData->SetDataDHCPServerOn(false);  // this should call StopServing()		// disconnect from DHCP data	gDHCPData->RemoveListener(this);	if (mResponseArray) {	    delete mResponseArray;	    mResponseArray = nil;	}		// defensive	Terminate(true);}// ---------------------------------------------------------------------------------//		¥ Terminate// ---------------------------------------------------------------------------------voidCDHCPAction::Terminate(Boolean inCanWait){	// Release thread objects we created	if (mReceiveUDPThread) mReceiveUDPThread->Abort();	if (mSendUDPThread) mSendUDPThread->Abort();	if (mReceiveICMPThread) mReceiveICMPThread->Abort();	if (mSendICMPThread) mSendICMPThread->Abort();	if (inCanWait) {		// Wait for threads to abort normally		UInt8 retryLimit = 16;		while (	(mReceiveUDPThread != nil)	||				(mSendUDPThread != nil)		||				(mReceiveICMPThread != nil)	||				(mSendICMPThread != nil)	) {			LThread::Yield();			retryLimit -= 1;			if (retryLimit == 0) break;		}	}	   	    // if threads didn't complete, cleanup as best we can    if (mReceiveUDPThread) {    	mReceiveUDPThread->DeleteThread();    	mReceiveUDPThread = nil;    }    if (mSendUDPThread) {    	mSendUDPThread->DeleteThread();    	mSendUDPThread = nil;    }    if (mReceiveICMPThread) {    	mReceiveICMPThread->DeleteThread();    	mReceiveICMPThread = nil;    }    if (mSendICMPThread) {    	mSendICMPThread->DeleteThread();    	mSendICMPThread = nil;    }	// Release the UDP Endpoint we created	if (mUDPEndpoint) {		// no longer want notification of endpoint events		mUDPEndpoint->RemoveListener(this);		delete mUDPEndpoint;		mUDPEndpoint = nil;	}	if (mICMPEndpoint) {		mICMPEndpoint->RemoveListener(this);		delete mICMPEndpoint;		mICMPEndpoint = nil;	}}// ---------------------------------------------------------------------------------//		¥ UseDefaults// ---------------------------------------------------------------------------------voidCDHCPAction::UseDefaults(){	// setup default configuration for DHCP server		// dynamic config entry	DHCPDynamicCfgEntry_t	dcEntry;	dcEntry.startLeaseAddr = IP_StrToInt("\p192.168.0.16");	dcEntry.endLeaseAddr = IP_StrToInt("\p192.168.0.254");	dcEntry.interfaceAddr = IP_StrToInt("\p192.168.0.1");	dcEntry.isDone = true;	gDHCPData->SetDataDHCPDynamicCfgArray(1, &dcEntry);	gDHCPData->SetDataCountDHCPDynamicCfg(1);		// lease data entry	// setup default configuration for Lease Data entry	DHCPLeaseDataEntry_t	ldEntry;	ldEntry.interfaceAddr = IP_StrToInt("\p192.168.0.1");	ldEntry.netMask = IP_StrToInt("\p255.255.255.0");	LString::CopyPStr("\p192.168.0.1", ldEntry.routerAddrStr);	if (gGatewayData->GetDataDNSForwarding())		LString::CopyPStr("\p192.168.0.1,0.0.0.0", ldEntry.nameServerAddrStr);	else		LString::CopyPStr("\p0.0.0.0", ldEntry.nameServerAddrStr);	//GetDNSAddress(ldEntry.nameServerAddrStr);	ldEntry.leaseDefaultTime = 24*kHourSeconds; 	// default to 24 hours	ldEntry.leaseMaxTime = 24*kHourSeconds;	 	// default to 24 hours	ldEntry.domainNameStr[0] = 0;	ldEntry.isEnabled = true;	ldEntry.isDone = true;	gDHCPData->SetDataDHCPLeaseDataArray(1, &ldEntry);}// ---------------------------------------------------------------------------------//		¥ StartServing// ---------------------------------------------------------------------------------BooleanCDHCPAction::StartServing(){	OSErr			err = noErr;	Boolean			result = false;	mWaitingToRestart = false;	try {		//	Create a tcp endpoint to force the InetConfigurator to fire		//	(blocks until TCP/IP is ready)		err = gProxyControl->AsyncOpenAndClose();		if (err != noErr) {			// Could not initialize OT.  Wait and try again.			gLogAction->LogText("\p\rCDHCPAction::StartServing() unexpected result initializing OT: ", err);			if (mDHCPRetryCount > 0) {				mDHCPRetryCount -= 1;				mIdleDelay = kIdleRestart;		// set idle time for restart				OTGetTimeStamp(&mLastStamp);				mWaitingToRestart = true;				//this->StartIdling();				this->StartRepeating();						}			else {				this->StopRepeating();				mDHCPRetryCount = kDHCPRetryCount;			}			ThrowIfNil_(nil);		}		// read saved DHCP Server Status		ReadStatusFile();		if (!mResponseArray) {			mResponseArray = new LArray(sizeof(dhcp_response_t));			ThrowIfNil_(mResponseArray);		}		//	Create a UDP endpoint		if (!mUDPEndpoint) {			mUDPEndpoint =  new CTurboUDPEndpoint(kUDPName);			ThrowIfNil_(mUDPEndpoint);			// Register to receive other event notifications			mUDPEndpoint->AddListener(this);		}		// Create ICMP endpoint to monitor for ping responses		if (!mICMPEndpoint) {			mICMPEndpoint =  new CTurboUDPEndpoint(kRawIPName);			ThrowIfNil_(mICMPEndpoint);			// Register to receive other event notifications			mICMPEndpoint->AddListener(this);		}		// Create thread objects for receive and transmit		if (!mReceiveUDPThread) {			mReceiveUDPThread = new CReceiveUDPThread(				(CObjectMaster*)	this,				(CTurboUDPEndpoint*) mUDPEndpoint);			ThrowIfNil_(mReceiveUDPThread);			// Bind to DHCP server port			LInternetAddress address(0, kDHCPServerPort);			mReceiveUDPThread->Bind(address);			mReceiveUDPThread->Resume();		}		if (!mSendUDPThread) {			mSendUDPThread = new CSendUDPThread(				(CObjectMaster*)	this,				(CTurboUDPEndpoint*) mUDPEndpoint);		// coerce to re-use code			ThrowIfNil_(mSendUDPThread);			mSendUDPThread->Resume();		}		if (!mReceiveICMPThread) {			mReceiveICMPThread = new CReceiveUDPThread(				(CObjectMaster*)	this,				(CTurboUDPEndpoint*) mICMPEndpoint);			ThrowIfNil_(mReceiveICMPThread);			mReceiveICMPThread->Resume();		}		if (!mSendICMPThread) {			mSendICMPThread = new CSendUDPThread(				(CObjectMaster*)	this,				(CTurboUDPEndpoint*) mICMPEndpoint);		// coerce to re-use code			ThrowIfNil_(mSendICMPThread);			mSendICMPThread->Resume();		}		// record server start time		if (!gDHCPData->GetDataDHCPServerOn()) {			::GetDateTime(&mStartTime);			::OTGetTimeStamp(&mLastStamp);		}		// test if we need to use 4-byte options		Boolean useFour = false;		do {			CTurboUDPEndpoint*	endpoint;			endpoint =  new CTurboUDPEndpoint(kUDPName);			if (!endpoint) break;			// do this synchronously			::OTSetBlocking(endpoint->GetEndpointRef());			::OTSetSynchronous(endpoint->GetEndpointRef());			TOption*	opt;			// Setup the fields of the options buffer...				// IP_RCVIFADDR option			opt = (TOption*)&mOptionBuf[0];	// set pointer to access option fields			opt->level  = INET_IP;			opt->name   = IP_RCVIFADDR;			opt->len    = kOTOneByteOptionSize;							// Note that kOTOneByteOptionSize != 1, it also							//  includes the size of the option header.				opt->status = 0;			*(UInt8*)opt->value = 1;			// Set up the req structure to denote the options we're requesting...			mReq.opt.buf = mOptionBuf;			mReq.opt.len = kOTOneByteOptionSize;			mReq.opt.maxlen = sizeof(mOptionBuf);			mReq.flags   = T_NEGOTIATE;						result = ::OTOptionManagement(endpoint->GetEndpointRef(), &mReq, &mReq);			if ((result == kOTBadOptionErr) || (result == 177)) useFour = true;						if (endpoint) delete endpoint;		} while (false);				// enable IP_RCVIFADDR to get interface address		{			TOption*	opt;			// Setup the fields of the options buffer...				// IP_RCVIFADDR option			opt = (TOption*)&mOptionBuf[0];	// set pointer to access option fields			opt->level  = INET_IP;			opt->name   = IP_RCVIFADDR;			opt->len    = kOTOneByteOptionSize;			if (useFour) opt->len    = kOTFourByteOptionSize;							// Note that kOTOneByteOptionSize != 1, it also							//  includes the size of the option header.				opt->status = 0;			*(UInt8*)opt->value = 1;			if (useFour) *(UInt32*)opt->value = 1;			// Set up the req structure to denote the options we're requesting...			mReq.opt.buf = mOptionBuf;			mReq.opt.len = kOTOneByteOptionSize;			if (useFour) mReq.opt.len = kOTFourByteOptionSize;			mReq.opt.maxlen = sizeof(mOptionBuf);			mReq.flags   = T_NEGOTIATE;			mSendUDPThread->DoOption(&mReq);			LThread::Yield();		}		// enable IP_RCVDSTADDR to get local target		{			TOption*	opt;			UInt8		i;			// Setup the fields of the options buffer...				// IP_RCVDSTADDR option			opt = (TOption*)&mOptionBuf2[0];	// set pointer to access option fields			opt->level  = INET_IP;			opt->name   = IP_RCVDSTADDR;			opt->len    = kOTOneByteOptionSize;			if (useFour) opt->len    = kOTFourByteOptionSize;							// Note that kOTOneByteOptionSize != 1, it also							//  includes the size of the option header.				opt->status = 0;			*(UInt8*)opt->value = 1;			if (useFour) *(UInt32*)opt->value = 1;			// Set up the req structure to denote the options we're requesting...			mReq2.opt.buf = mOptionBuf2;			mReq2.opt.len = kOTOneByteOptionSize;			if (useFour) mReq2.opt.len = kOTFourByteOptionSize;			mReq2.opt.maxlen = sizeof(mOptionBuf2);			mReq2.flags   = T_NEGOTIATE;			// allow previous option to complete			for (i=8; i>0; i--) {				if (mSendUDPThread->DoOption(&mReq2)) break;				LThread::Yield();			}		}		// Start idling to check for time outs		//this->StartIdling();		this->StartRepeating();		if (!mIsServing) gLogAction->LogText("\p\rDHCP Action: Start Serving");		mIsServing = true;		gDHCPData->SetDataDHCPServerOn(true);		result = true;	}	catch (const LException& inErr) {		gLogAction->LogText("\p\rUnexpected result while starting DHCP Server");	} 	return result;}// ---------------------------------------------------------------------------------//		¥ StopServing// ---------------------------------------------------------------------------------BooleanCDHCPAction::StopServing(Boolean inCanWait){		if (mIsServing) {		mIsServing = false;		gLogAction->LogText("\p\rDHCP Action: Stop Serving");		// save DHCP Server Status		WriteStatusFile();	}	// stop any pending restart	mWaitingToRestart = false;	//this->StopIdling();	this->StopRepeating();	// clean up	Terminate(inCanWait);	gDHCPData->SetDataDHCPServerOn(false);	mDHCPRetryCount = kDHCPRetryCount;		// reinitialize retry counter	return true;}// ---------------------------------------------------------------------------//		¥ SpendTime// ---------------------------------------------------------------------------//	Periodical function to test if query timed outvoidCDHCPAction::SpendTime(const EventRecord &inMacEvent){#pragma unused (inMacEvent)	UInt32		deltaTime;	UInt32		currentTime;	ArrayIndexT	count, index;	Boolean		result;	// do every "mIdleDelay" milliseconds	deltaTime = OTElapsedMilliseconds(&mLastStamp);	if (deltaTime > mIdleDelay) {		OTGetTimeStamp(&mLastStamp);		do {			// check if pending restart			if (mWaitingToRestart) {				mWaitingToRestart = false;				StartServing();				break;				}			// check response array			if (!mResponseArray) {				StopServing();				break;			}			count = mResponseArray->GetCount();			if (count == 0) mIdleDelay = kIdleDefault;	// no responses waiting			for (index=1; index<=count; index++) {				dhcp_response_t dhcpResponse;				if (!mResponseArray->FetchItemAt(index, &dhcpResponse)) continue;				// found a response entry from array				if (dhcpResponse.responseState == kRSPing) {					// response is waiting for ping					deltaTime = OTElapsedMilliseconds(&dhcpResponse.timeStamp);					// if waited 200ms, indicate timed out					if (deltaTime > 200) {						dhcpResponse.responseState = kRSReady;						mResponseArray->AssignItemsAt(1, index, &dhcpResponse, sizeof(dhcp_response_t));						if (gDHCPData->GetDataDHCPVerboseLogging()) {							LStr255 text;							Str31	str;							IP_NumToStr(dhcpResponse.yiaddr, str);							text = "\p\rNo response to ping on: ";							text += str;							gLogAction->LogText(text);						}					}				}				// if response is ready, try to send it				if (dhcpResponse.responseState == kRSReady) {					result = SendResponse(&dhcpResponse);					if (result) {						// response was sent, remove from array						mResponseArray->RemoveItemsAt(1, index);						index -= 1;					}					// allow SendThread to run before trying next in array					LThread::Yield();				}			}			// check status array			::GetDateTime(&currentTime);			count = gDHCPData->GetDataCountDHCPStatus();			// for each lease record			for (index=1; index<=count; index++) {				DHCPStatusEntry_t statusEntry;				if (!gDHCPData->GetDataDHCPStatusArray(index, &statusEntry)) continue;				// found a lease record				switch (statusEntry.leaseState) {				case kLeaseOffered:					if ((currentTime - statusEntry.lastUpdate) > kLeaseOfferPeriod) {						// offer has expired						statusEntry.leaseState = kLeaseExpired;						statusEntry.lastUpdate = currentTime;						gDHCPData->SetDataDHCPStatusArray(index, &statusEntry);					}					break;				case kLeaseBound:				case kLeaseBootP:					if (currentTime > (statusEntry.expireTime+kLeaseGracePeriod)) {						// lease has expired						statusEntry.leaseState = kLeaseExpired;						statusEntry.lastUpdate = currentTime;						gDHCPData->SetDataDHCPStatusArray(index, &statusEntry);					}					break;				case kLeaseInUse:				case kLeaseDeclined:					if (currentTime > (statusEntry.lastUpdate+kLeaseReclaimPeriod)) {						// block has expired						statusEntry.leaseState = kLeaseExpired;						statusEntry.lastUpdate = currentTime;						gDHCPData->SetDataDHCPStatusArray(index, &statusEntry);					}					break;				}			}	// end for each lease record		} while (false);	}	// end if (deltaTime > mIdleDelay)}// ---------------------------------------------------------------------------//		¥ ObjectThreadDied// ---------------------------------------------------------------------------//	A threaded operation has completed.voidCDHCPAction::ObjectThreadDied(LThread *inThread) {	// Receive Thread completed?	if (inThread == mReceiveUDPThread) {		// get result		long result = *((long*)inThread->GetResult());		// indicate thread no longer exists		mReceiveUDPThread = nil;		LastComplete();		// handle results		switch (result) {			case 0:				// no error			case Abort_Error:	// operation aborted				result = 0;				break;			default:				gLogAction->LogText("\p\r### DHCPAction CReceiveUDPThread unexpected event code: ", result);				break;		}	// end switch		if (result != 0) {			// Thread died due to Endpoint event, try to recover			if (mIsServing) {				StopServing(true);				mIdleDelay = kIdleRestart;		// set idle time for restart				OTGetTimeStamp(&mLastStamp);				mWaitingToRestart = true;				//this->StartIdling();				this->StartRepeating();				//StartServing();			}		}	}		// Transmit Thread completed?	else if (inThread == mSendUDPThread) {		// get result		long result = *((long*)inThread->GetResult());		// indicate thread no longer exists		mSendUDPThread = nil;		LastComplete();			// handle results		switch (result) {			case 0:				// no error			case Abort_Error:	// operation aborted				result = 0;				break;			default:				gLogAction->LogText("\p\r### DHCPAction CSendUDPThread unexpected event code: ", result);				break;		}	// end switch		if (result != 0) {			// Thread died due to Endpoint event, try to recover			if (mIsServing) {				StopServing(true);				mIdleDelay = kIdleRestart;		// set idle time for restart				OTGetTimeStamp(&mLastStamp);				mWaitingToRestart = true;				//this->StartIdling();				this->StartRepeating();				//StartServing();			}		}	}		// Receive ICMP Thread completed?	else if (inThread == mReceiveICMPThread) {		// get result		long result = *((long*)inThread->GetResult());		// indicate thread no longer exists		mReceiveICMPThread = nil;		LastComplete();		// handle results		switch (result) {			case 0:				// no error			case Abort_Error:	// operation aborted				result = 0;				break;			default:				// write to log window if any				gLogAction->LogText("\p\rDHCP Action CReceiveICMPThread unexpected event code: ", result);				break;		}	// end switch		if (result != 0) {			// Thread died due to Endpoint event, try to recover			if (mIsServing) {				StopServing(true);				mIdleDelay = kIdleRestart;		// set idle time for restart				OTGetTimeStamp(&mLastStamp);				mWaitingToRestart = true;				//this->StartIdling();				this->StartRepeating();				//StartServing();			}		}	}		// Transmit ICMP Thread completed?	else if (inThread == mSendICMPThread) {		// get result		long result = *((long*)inThread->GetResult());		// indicate thread no longer exists		mSendICMPThread = nil;		LastComplete();			// handle results		switch (result) {			case 0:				// no error			case Abort_Error:	// operation aborted				result = 0;				break;			default:				gLogAction->LogText("\p\r### DHCP Action unexpected event code: ", result);				break;		}	// end switch		if (result != 0) {			// Thread died due to Endpoint event, try to recover			if (mIsServing) {				StopServing(true);				mIdleDelay = kIdleRestart;		// set idle time for restart				OTGetTimeStamp(&mLastStamp);				mWaitingToRestart = true;				//this->StartIdling();				this->StartRepeating();				//StartServing();			}		}	}}// ---------------------------------------------------------------------------------//		¥ LastComplete// ---------------------------------------------------------------------------------//	Release our UDP endpoint only after all threads have safely completedvoidCDHCPAction::LastComplete(){	if ((mReceiveUDPThread == nil) &&		(mSendUDPThread == nil)) {		// Release the UDP Endpoint we created		if (mUDPEndpoint) {			mUDPEndpoint->RemoveListener(this);			delete mUDPEndpoint;			mUDPEndpoint = nil;		}	}	if ((mReceiveICMPThread == nil) &&		(mSendICMPThread == nil)) {		if (mICMPEndpoint) {			mICMPEndpoint->RemoveListener(this);			delete mICMPEndpoint;			mICMPEndpoint = nil;		}	}}// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------//	Listen for other notifications from endpoint//		BroadcastMessage(nextMessage->GetMessageType(), nextMessage);voidCDHCPAction::ListenToMessage(	MessageT	inEventCode,	void		*ioParam ){	LNetMessage* inMessage = (LNetMessage*)ioParam;	switch ( inEventCode ) {		case msg_SignalDataEvent:						UInt32 dataID = *(UInt32*)ioParam;			if (dataID == DATA_ID(kDHCPStatusData, kDataDHCPServerOn)) {				if (gDHCPData->GetDataDHCPServerOn()) {					StartServing();				} else {					StopServing(true);				}			}			break;		case kOTProviderWillClose:		case kOTProviderIsClosed:			gLogAction->LogText("\p\rDHCPAction:  OT Provider has closed.");			break;		case msg_BroadcasterDied:		// unknown		case 0x04:		case 0x40:			//gLogAction->LogText("\p\rDHCPAction unknown async message type: ", inEventCode);			// try to recvoer			if (mIsServing) {				//StopServing(true);				UInt32	outRemoteAddress;				UInt16	outRemotePort;				SInt32	outError;				//Str31	str;				outRemoteAddress = 0;				outRemotePort = 0;				outError = 0;				if (mUDPEndpoint) {					mUDPEndpoint->ReceiveError(outRemoteAddress, outRemotePort, outError);					//gLogAction->LogText("\p\rDHCPAction ReceiveError from ");					//IP_NumToStr(outRemoteAddress, str);					//gLogAction->LogText(str);					//gLogAction->LogText("\p:");					//::NumToString(outRemotePort, str);					//gLogAction->LogText(str);					//gLogAction->LogText("\p result: ", outError);				} else {					StartServing();				}			}			break;		default:			gLogAction->LogText("\p\rDHCPAction unexpected async message type: ", inEventCode);			gLogAction->LogText("\p\r  Result code: ", inMessage->GetResultCode());			// try to recvoer			if (mIsServing) {				StopServing(true);				mIdleDelay = kIdleRestart;		// set idle time for restart				OTGetTimeStamp(&mLastStamp);				mWaitingToRestart = true;				//this->StartIdling();				this->StartRepeating();				//StartServing();			}	}}// ---------------------------------------------------------------------------//		¥ ReceiveICMP// ---------------------------------------------------------------------------//	Some ICMP data came in from the network.voidCDHCPAction::ReceiveICMP(LDataArrived* inMessage){	void* 	inData;			// data that arrived	UInt32	inDataSize;		// size of the data	LInternetAddress* inRemoteAddress;	//UInt32	timeStamp;	//UInt8*	dp;	ArrayIndexT	count, index, i;	// setup access to message data and remote address	inData = inMessage->GetDataBuffer();	inDataSize = inMessage->GetDataSize();	inRemoteAddress = inMessage->GetRemoteAddress();	// Get time stamp from end of message	//dp = (UInt8*)inData;	//OTTimeStamp	stamp;	//::OTSubtractTimeStamps( &stamp, &mStartTime, (OTTimeStamp*)&dp[inDataSize] );	//timeStamp = OTTimeStampInMilliseconds( &stamp );		// setup pointer to ip header	ipheader *ip_header;	ip_header = (ipheader*)inData;	// setup pointer to icmp header	icmpheader *icmp_header;	icmp_header = (icmpheader*)&((UInt8*)inData)[(ip_header->hlen & 0x0F) * 4];		// check for response to our own ping	if ((icmp_header->type == kIcmpEchoReply) &&		(icmp_header->sequence_number == kDHCPServerSN)) {		// see if it matches a pending response		count = mResponseArray->GetCount();		for (index=1; index<=count; index++) {			dhcp_response_t dhcpResponse;			if (!mResponseArray->FetchItemAt(index, &dhcpResponse)) continue;			// found a response entry from array			if (( dhcpResponse.responseState == kRSPing ) &&				( dhcpResponse.yiaddr == inRemoteAddress->GetIPAddress() )) {				// response was waiting for this ping				// look for corresponding status entry (lease binding)				DHCPStatusEntry_t statusEntry;				i = FindLeaseStatus(dhcpResponse.yiaddr);				if (gDHCPData->GetDataDHCPStatusArray(i, &statusEntry)) {					// update status entry to show address is in use					statusEntry.leaseState = kLeaseInUse;					// try to show the hardware address of the machine that responded										// change the clientID to disassociate this entry					// from the client that requested an IP address					LString::CopyPStr("\p*unknown*", statusEntry.clientID);					// save changed entry					gDHCPData->SetDataDHCPStatusArray(i, &statusEntry);				}				// remove response from list since address is in use				// assume client will retry DHCP discover				mResponseArray->RemoveItemsAt(1, index);				LStr255 text;				Str31 str;				IP_NumToStr(dhcpResponse.yiaddr, str);				text = "\p\rReceiveICMP - detected address already in use: ";				text += str;				gLogAction->LogText(text);				break;			}		}	}}#pragma mark --- Read/Write DHCP Server Status ---// ---------------------------------------------------------------------------//		¥ ReadStatusFile// ---------------------------------------------------------------------------//	Read DHCP Server Status from filevoidCDHCPAction::ReadStatusFile(){	short	vRefNum;	long	parID;	FSSpec	specRead;	LFile*	fileRead;	OSErr	err;		fileRead = nil;		try {		// create file object if needed		err = FindFolder(kOnSystemDisk, kPreferencesFolderType, kCreateFolder,	    				 &vRefNum, &parID);		if (err != noErr) Throw_(err);		err = FSMakeFSSpec(vRefNum, parID, kDHCPStatusFileName, &specRead);		if ((err != noErr) && (err != fnfErr)) Throw_(err);		// Create a new file object.		fileRead = new LFile( specRead );		ThrowIfNil_(fileRead);				if (err == fnfErr) {			// create file			fileRead->CreateNewDataFile((OSType)'IPnl', (OSType)'TEXT', smSystemScript);					}				// Open the data fork.		fileRead->OpenDataFork( fsRdWrPerm );				// Read the entire file and close the file.		Handle	theTextH = fileRead->ReadDataFork();		fileRead->CloseDataFork();		// Put the contents in data objects		err = ImportFromText( theTextH );					// Dispose of the text.		::DisposeHandle( theTextH );	}	catch (const LException& inErr) {		if (inErr.GetErrorCode() != fnfErr) {			// tell user what happened			gLogAction->LogText(				"\p\rCDHCPData - Unexpected result reading DHCP Server Status", inErr.GetErrorCode());		}	} 	if (fileRead) delete fileRead;}// ---------------------------------------------------------------------------//		¥ WriteStatusFile// ---------------------------------------------------------------------------//	Write DHCP Server Status to filevoidCDHCPAction::WriteStatusFile(){	short	vRefNum;	long	parID;	FSSpec	specWrite;	FSSpec	specRead;	LFile*	fileWrite;	OSErr	err;		fileWrite = nil;	try {		// Setup to write to temp file		err = FindFolder(kOnSystemDisk, kPreferencesFolderType, kCreateFolder, &vRefNum, &parID);		if (err != noErr) Throw_(err);		// use temp file for writing and then exchange with read file		err = FSMakeFSSpec(vRefNum, parID, kDHCPTempFileName, &specWrite);		if ((err != noErr) && (err != fnfErr)) Throw_(err);		// Create a new file object.		fileWrite = new LFile( specWrite );		try {			// create file			fileWrite->CreateNewDataFile((OSType)'IPnl', (OSType)'TEXT', smSystemScript);		} catch (const LException& inErr) {			if (inErr.GetErrorCode() != dupFNErr) throw;		} 				// Open the data fork.		fileWrite->OpenDataFork( fsRdWrPerm );				// Count number of status entries and allocate a big enough block		UInt32 count, size;		count = gDHCPData->GetDataCountDHCPStatus();		size = count * kMaxDHCPSize;				size += 1024;				// extra for command overhead		Handle theTextH = ::NewHandle(size);		ThrowIfMemFail_(theTextH);				// output text to buffer		SInt32 outSize=0;		outSize = ExportToText( theTextH );		if (outSize > 0) {				UInt32 writeSize;			writeSize = outSize & 0xFFFFFE00;			if (writeSize < outSize) writeSize += 0x0200;						// Lock the text handle.			StHandleLocker	theLock( theTextH );						// Write the text to the file.			fileWrite->WriteDataFork( *theTextH, writeSize );			// set logical EOF			::SetEOF(fileWrite->GetDataForkRefNum(), outSize);		}		// Close the data fork.		fileWrite->CloseDataFork();		// Dispose of the text.		::DisposeHandle( theTextH );		// Get read file spec		err = FSMakeFSSpec(vRefNum, parID, kDHCPStatusFileName, &specRead);		if ((err != noErr) && (err != fnfErr)) Throw_(err);		// swap file data		err = FSpExchangeFiles(&specWrite, &specRead);		// delete old data		err = FSpDelete(&specWrite);	} catch (const LException& inErr) {		// tell user what happened		gLogAction->LogText("\p\rCDHCPAction - Unexpected result writing DHCP Server Status", inErr.GetErrorCode());	} 	catch(...) {	    SysBeep(30);	} 		if (fileWrite) delete fileWrite;}// ---------------------------------------------------------------------------------//		¥ ImportFromText// ---------------------------------------------------------------------------------//	Read text from handle and store corresponding config data in//	data objects////	Format of text file is as follows://		#command				! a command keyword//		+d <param>...			! dhcpStatus entry//		<not+or->				! a comment line//		#end					! end of data in file//SInt32CDHCPAction::ImportFromText(Handle inTextH){	OSStatus	result = noErr;	UInt8*		dp;	SInt32		start, end, pos, eol;	SInt32		index;	// data class elements	DHCPStatusEntry_t	statusEntry;	// get length of text we read in	end = ::GetHandleSize(inTextH);		// end = one past last char	index = 0;	start = 0;	while (start < end) {		// get pointer to text (dereference handle in case it moved)		dp = (UInt8*)(*inTextH);				// look at first character of line		// check for command		if (dp[start] == '#') {			// Get command			pos = FindByte('\r', dp, start, end);			// look for end command			if ((pos == 0) || (pos-start > 64)) break;			LStr255 cmdStr( &dp[start], (UInt8)(pos-start) );			cmdStr.SetCompareFunc(LString::CompareIgnoringCase);	// ignore case			start = pos + 1;								// advance to next			if (cmdStr.BeginsWith("\p#end")) break;			continue;		}		// skip comments		if ((dp[start] != '+') && (dp[start] != '-')) {			pos = FindByte('\r', dp, start, end);			if (pos) {				start = pos + 1;	// advance to next				continue;			}			else break;	// if not found, exit		}				// first char is + or -		// find end of line		eol = FindByte('\r', dp, start, end);		if ((eol == 0) || (eol-start > 255)) break;		// get data from file and store in data objects		result = gDHCPData->TextToStatusEntry(dp, start, eol, &statusEntry);		// insert element in status array		//	(inCount, inAtIndex, *inItem, inItemSize)		index += 1;		gDHCPData->SetDataDHCPStatusArray(index, &statusEntry);		// advance to get next line		start = eol + 1;	}	gDHCPData->SetDataCountDHCPStatus(index);		return result;}// ---------------------------------------------------------------------------------//		¥ ExportToText// ---------------------------------------------------------------------------------//	Get data from data objects and store as text in specified handle.//	Returns number of bytes written to buffer or -1 if buffer is too small.SInt32CDHCPAction::ExportToText(Handle inTextH){	UInt8*	dp;	SInt32	start, end;	LStr255	paramStr;		end = ::GetHandleSize(inTextH);		// end = one past last char	// start at beginning of text buffer	start = 0;	// get vers resource	StResource versData( (ResType)'vers', 1, false, false );	// (...inThrowFail, inCurrResOnly)	if (versData.mResourceH) {		// display version info		paramStr = "\p! IPNetRouter ";		paramStr += (unsigned char*)&(*versData.mResourceH)[6];#if powerc		paramStr += "\p PPC";#else		paramStr += "\p 68K";#endif		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}	// setup access to DHCP status data	DHCPStatusEntry_t	statusEntry;	ArrayIndexT			count, index;	count = gDHCPData->GetDataCountDHCPStatus();		// iterate over config to export data	for (index=1; index<=count; index++) {		if ( !gDHCPData->GetDataDHCPStatusArray(index, &statusEntry) ) break;		// write out entry as text if there is room		if ((start + kMaxDHCPSize) < end) {			// Lock the text handle.			StHandleLocker	theLock( inTextH );			dp = (UInt8*)(*inTextH);	// dereference handle			start += gDHCPData->StatusEntryToText(&statusEntry,  &dp[start], end-start);			// mark end of line			AppendStr(dp, start, end, kDelimeterEOLStr);		} else {			// buffer is too small			return -1;		}	}	// add end of data marker	paramStr = "\p#end\r";	dp = (UInt8*)(*inTextH);	::BlockMove(&paramStr[1], &dp[start], paramStr[0]);	start += paramStr[0];		return start;	// no error}#pragma mark --- DHCP Logging ---// ---------------------------------------------------------------------------//		¥ LogDHCPRequest// ---------------------------------------------------------------------------// Show DHCP request info in log windowvoidCDHCPAction::LogDHCPRequest(dhcp_request_t* inRequest){	LStr255	text;	Str31	str;		text = "\p\r ";	if (gDHCPData->GetDataDHCPVerboseLogging()) gLogAction->LogText(text);	MsgTypeToString(inRequest->dhcpMessageType, str);	text = "\p\rDHCP ";	text += str;	text += "\p arrived:";	gLogAction->LogText(text);		// show address info	text = "\p\r From remote host: ";	IP_NumToStr(inRequest->remoteAddr, str);	text += str;	if (inRequest->remotePort != 0) {		NumToString(inRequest->remotePort, str);		text += "\p:";		text += str;	}	text += "\p target: ";	IP_NumToStr(inRequest->localTarget, str);	text += str;	text += "\p received on: ";	IP_NumToStr(inRequest->localAddr, str);	text += str;	NumToString(kDHCPServerPort, str);	text += "\p:";	text += str;	gLogAction->LogText(text);	// verbose logging?		if (gDHCPData->GetDataDHCPVerboseLogging()) {		// show message data		LogDHCPMessage((DHCPMessage*)inRequest->data, inRequest->size);	}	else {		// show user message if any		if (inRequest->dhcpMessage.option != 0) {			gLogAction->LogText("\p\r ");			LogDHCPOption(inRequest->dhcpMessage.option,				inRequest->dhcpMessage.len, &inRequest->data[inRequest->dhcpMessage.offset]);		}	}	gLogAction->Update();		}// ---------------------------------------------------------------------------//		¥ LogDHCPResponse// ---------------------------------------------------------------------------// Show DHCP response info in log windowvoidCDHCPAction::LogDHCPResponse(dhcp_response_t* inResponse){	DHCPMessage* msg;	LStr255	text;	Str31	str;		msg = (DHCPMessage*)inResponse->buf;		text = "\p\r ";	if (gDHCPData->GetDataDHCPVerboseLogging()) gLogAction->LogText(text);	MsgTypeToString(inResponse->dhcpMessageType, str);	text = "\p\rDHCP ";	text += str;	// show where sent	switch (inResponse->respondVia) {		case kViaUnicast:			text += "\p unicast to: ";			IP_NumToStr(inResponse->ciaddr, str);			text += str;			NumToString(kDHCPClientPort, str);			text += "\p:";			text += str;			gLogAction->LogText(text);			break;		case kViaBroadcast:			text += "\p broadcast";			gLogAction->LogText(text);			break;		case kViaHardwareUnicast:			text += "\p hardware unicast to: ";			IP_NumToStr(msg->yiaddr, str);			text += str;			NumToString(kDHCPClientPort, str);			text += "\p:";			text += str;			gLogAction->LogText(text);			break;		case kViaRelayAgent:			text += "\p relayed to: ";			IP_NumToStr(msg->giaddr, str);			text += str;			NumToString(kDHCPServerPort, str);			text += "\p:";			text += str;			gLogAction->LogText(text);			break;	}			if (gDHCPData->GetDataDHCPVerboseLogging()) {		// data length		text = "\p\r Data length: ";		NumToString(inResponse->dataLen, str);		text += str;		gLogAction->LogText(text);		// show message data				LogDHCPMessage((DHCPMessage*)inResponse->buf, inResponse->dataLen);	}	gLogAction->Update();}// ---------------------------------------------------------------------------//		¥ LogDHCPMessage// ---------------------------------------------------------------------------// Show DHCP message info in log windowvoidCDHCPAction::LogDHCPMessage(DHCPMessage_t* inMessage, UInt16 inSize){	LStr255	text;	Str31	str;	UInt8	overload;	Boolean isServerName = false;	// OP HTYPE HLEN HOPS	text = "\p\r ";	if (inMessage->op == kBootRequest) text += "\pOP=request";	if (inMessage->op == kBootReply) text += "\pOP=reply";	NumToString(inMessage->htype, str);	text += "\p HTYPE:";	text += str;	NumToString(inMessage->hlen, str);	text += "\p HLEN:";	text += str;	NumToString(inMessage->hops, str);	text += "\p HOPS:";	text += str;	gLogAction->LogText(text);	// TRANSACTION ID	IP_NumToHexStr(inMessage->xid, str);	text = "\p\r TRANSACTION ID: ";	text += str;	gLogAction->LogText(text);	// SECONDS FLAGS	NumToString(inMessage->secs, str);	text = "\p\r SECONDS: ";	text += str;	if (inMessage->flags & 0x8000) text += "\p FLAGS:broadcast";	else text += "\p FLAGS:none";	gLogAction->LogText(text);	// CLIENT IP ADDRESS	IP_NumToStr(inMessage->ciaddr, str);	text = "\p\r Client IP Address: ";	text += str;	gLogAction->LogText(text);	// YOUR IP ADDRESS	IP_NumToStr(inMessage->yiaddr, str);	text = "\p\r Your IP Address: ";	text += str;	gLogAction->LogText(text);	// SERVER IP ADDRESS	IP_NumToStr(inMessage->siaddr, str);	text = "\p\r Next Server IP Address: ";	text += str;	gLogAction->LogText(text);	// ROUTER IP ADDRESS	IP_NumToStr(inMessage->giaddr, str);	text = "\p\r Relay Agent IP Address: ";	text += str;	gLogAction->LogText(text);	// CLIENT HARDWARE ADDRESS	text = "\p\r Client Hardware Address: ";	if (inMessage->hlen == 6) {		MACAddr_t hwAddr;		OTMemcpy(&hwAddr, &inMessage->chaddr, 6);		HW_NumToHexStr(&hwAddr, str);		text += str;	}	gLogAction->LogText(text);	// Show options	UInt32	start, end;	start = 28 + 16 + 64 + 128;	// check for magic cookie	if (*((UInt32*)inMessage->options) == 0x63825363) {		start += 4;	}	end = inSize;	overload = LogDHCPOptions(inMessage, start, end);	if (overload & 1) {		// get options from "file"		start = 28 + 16 + 64;		end = start + 128;		LogDHCPOptions(inMessage, start, end);		}	if (overload & 2) {		// get options from "sname"		start = 28 + 16;		end = start + 64;		LogDHCPOptions(inMessage, start, end);		} else isServerName = true;	if (isServerName) {		text = "\p\r SERVER HOST NAME: ";		gLogAction->LogText(text);		text = inMessage->sname;		gLogAction->LogText(text);	}}// ---------------------------------------------------------------------------//		¥ LogDHCPOptions// ---------------------------------------------------------------------------// Show DHCP options info in log window// return "Overload" option or zero if not presentUInt8CDHCPAction::LogDHCPOptions(DHCPMessage_t* inMessage, UInt32 start, UInt32 end){	UInt8*	dp;		UInt8	option;	UInt8	len;	UInt8	value;	UInt8	result=0;		dp = (UInt8*)inMessage;	option = kOptionPad;	while ((option != kOptionEnd) && (start < end)) {		option = dp[start++];		if ((option != kOptionPad) && (option != kOptionEnd)) {			len = dp[start++];			gLogAction->LogText("\p\r");			value = LogDHCPOption(option, len, &dp[start]);			if (value) result = value;			start += len;		}	}	return result;}// ---------------------------------------------------------------------------//		¥ LogDHCPOption// ---------------------------------------------------------------------------// Show DHCP option in log window// return "Overload" option or zero if not presentUInt8CDHCPAction::LogDHCPOption(UInt8 option, UInt8 len, UInt8* data){	UInt8	value8;	UInt16	value16;	UInt32	value32;	LStr255	text;	Str255	str;	UInt8	i;	UInt8	result = 0;	if (data) {		value8  = *(UInt8*)data;		value16 = *(UInt16*)data;		value32 = *(UInt32*)data;	} else {		value8 = 0;		value16 = 0;		value32 = 0;	}		switch (option) {		case kOptionSubnetMask:			gLogAction->LogText("\p OptionSubnetMask");			if (value32) {				gLogAction->LogText("\p: ");				gLogAction->LogText(IP_NumToStr(value32, str));			}			break;		case kOptionRouters:			gLogAction->LogText("\p OptionRouters");							if (value32) {				gLogAction->LogText("\p:");				for (i=0; i<len; i+=4) {					value32 = *(UInt32*)&data[i];					IP_NumToStr(value32, str);					gLogAction->LogText("\p ");					gLogAction->LogText(str);				}			}			break;		case kOptionDomainServer:			gLogAction->LogText("\p OptionDomainServer");			if (value32) {				gLogAction->LogText("\p:");				for (i=0; i<len; i+=4) {					value32 = *(UInt32*)&data[i];					IP_NumToStr(value32, str);					gLogAction->LogText("\p ");					gLogAction->LogText(str);				}			}			break;		case kOptionHostName:			gLogAction->LogText("\p OptionHostName");			if (data) {				gLogAction->LogText("\p: ");				OTMemcpy(&str[1], data, len);				str[0] = len;				gLogAction->LogText(str);			}			break;		case kOptionDomainName:			gLogAction->LogText("\p OptionDomainName");			if (data) {				gLogAction->LogText("\p: ");				OTMemcpy(&str[1], data, len);				str[0] = len;				gLogAction->LogText(str);			}			break;		case kOptionAddressRequest:			gLogAction->LogText("\p OptionAddressRequest");			if (value32) {				gLogAction->LogText("\p: ");				gLogAction->LogText(IP_NumToStr(value32, str));			}			break;		case kOptionAddressTime:			gLogAction->LogText("\p OptionAddressTime");			NumToString(value32, str);			if (value32) {				gLogAction->LogText("\p: ");				gLogAction->LogText(str);			}			break;		case kOptionOverload:			gLogAction->LogText("\p OptionOverload");			result = value8;			break;		case kOptionDHCPMessageType:			gLogAction->LogText("\p OptionMessageType: ");			MsgTypeToString(value8, str);			gLogAction->LogText(str);			break;		case kOptionDHCPServerID:			gLogAction->LogText("\p OptionDHCPServerID");			if (value32) {				gLogAction->LogText("\p: ");				gLogAction->LogText(IP_NumToStr(value32, str));			}			break;		case kOptionParameterList:			UInt8	listItem;			text = "\p OptionParameterList: ";			gLogAction->LogText(text);			for (i=0; i<len; i++) {				listItem = data[i];				NumToString(listItem, str);				text = "\p\r  ";				text += str;				text += "\p  ";				gLogAction->LogText(text);				LogDHCPOption(listItem, 0, nil);			}			break;		case kOptionDHCPMessage:			gLogAction->LogText("\p OptionDHCPMessage");			if (data) {				gLogAction->LogText("\p: ");				OTMemcpy(&str[1], data, len);				str[0] = len;				gLogAction->LogText(str);			}			break;		case kOptionDHCPMaxMsgSize:			gLogAction->LogText("\p OptionDHCPMaxMsgSize");			::NumToString(value16, str);			if (value16) {				gLogAction->LogText("\p: ");				gLogAction->LogText(str);			}			break;		case kOptionRenewalTime:			gLogAction->LogText("\p OptionRenewalTime");			::NumToString(value32, str);			if (value32) {				gLogAction->LogText("\p: ");				gLogAction->LogText(str);			}			break;		case kOptionRebindingTime:			gLogAction->LogText("\p OptionRebindingTime");			::NumToString(value32, str);			if (value32) {				gLogAction->LogText("\p: ");				gLogAction->LogText(str);			}			break;		case kOptionClassID:			gLogAction->LogText("\p OptionClassID");			if (data) {				gLogAction->LogText("\p: ");				OTMemcpy(&str[1], data, len);				str[0] = len;				gLogAction->LogText(str);			}			break;		case kOptionClientID:			gLogAction->LogText("\p OptionClientID");			if (data) {				Str255 outStr;				gLogAction->LogText("\p: ");				OTMemcpy(&str[1], data, len);				str[0] = len;				EncodeHexStr(str, outStr);				gLogAction->LogText(outStr);			}			break;		default:			gLogAction->LogText("\pUnrecognized DHCP option: ", option);			break;	}	return result;}// ---------------------------------------------------------------------------//		¥ MsgTypeToString// ---------------------------------------------------------------------------StringPtrCDHCPAction::MsgTypeToString(UInt8 inType, Str31 outStr){	switch (inType) {		case kDHCPDiscover:			LString::CopyPStr("\pDISCOVER", outStr, 30);			break;		case kDHCPOffer:			LString::CopyPStr("\pOFFER", outStr, 30);			break;		case kDHCPRequest:			LString::CopyPStr("\pREQUEST", outStr, 30);			break;		case kDHCPDecline:			LString::CopyPStr("\pDECLINE", outStr, 30);			break;		case kDHCPAck:			LString::CopyPStr("\pACK", outStr, 30);			break;		case kDHCPNack:			LString::CopyPStr("\pNACK", outStr, 30);			break;		case kDHCPRelease:			LString::CopyPStr("\pRELEASE", outStr, 30);			break;		case kDHCPInform:			LString::CopyPStr("\pINFORM", outStr, 30);			break;		case kDHCPBootP:			LString::CopyPStr("\pBOOTP", outStr, 30);			break;				default:			NumToString(inType, outStr);	}	return outStr;}#pragma mark --- Handle Requests ---// ---------------------------------------------------------------------------//		¥ Receive Data// ---------------------------------------------------------------------------//	Handle data that arrived from the network.voidCDHCPAction::ReceiveData(LDataArrived* inMessage){	dhcp_request_t		dhcpRequest;	LInternetAddress*	inRemoteAddress;	LEndpoint*		theEndpoint;	// test which endpoint message is from	theEndpoint = inMessage->GetEndpoint();	if (theEndpoint != mUDPEndpoint) {		// message is not from UDP Endpoint, handle as ICMP		ReceiveICMP(inMessage);		return;	}	// initialize dhcpRequest structure	OTMemzero(&dhcpRequest, sizeof(dhcp_request_t));	// setup access to message data and addresses	dhcpRequest.data = (UInt8*)inMessage->GetDataBuffer();	dhcpRequest.size = inMessage->GetDataSize();	dhcpRequest.offset = 0;	// remote address	inRemoteAddress = inMessage->GetRemoteAddress();	dhcpRequest.remoteAddr = inRemoteAddress->GetIPAddress();	dhcpRequest.remotePort = inRemoteAddress->GetHostPort();	// Get local interface address from end of message	::OTMemcpy(&dhcpRequest.localAddr, &dhcpRequest.data[dhcpRequest.size], 4);	::OTMemcpy(&dhcpRequest.localTarget, &dhcpRequest.data[dhcpRequest.size+4], 4);	// Process Request	ProcessRequest(&dhcpRequest);	}// ---------------------------------------------------------------------------//		¥ ProcessRequest// ---------------------------------------------------------------------------//	Process DHCP requestvoidCDHCPAction::ProcessRequest(dhcp_request_t* inRequest){	dhcp_response_t		dhcpResponse;	DHCPMessage_t*		msg;	ArrayIndexT			index;	UInt32              netInterface;	Boolean				result;	Boolean				requestNotValid;	DHCPLeaseDataEntry_t leaseDataEntry;	// Make sure DHCP is enabled on the local interface that received	// this request.  Save the corresponding netMask and netNumber.	// Use giaddr as netInterface if specified.	msg = (DHCPMessage*)inRequest->data;	requestNotValid = false;	do {		index = FindLeaseData(inRequest->localAddr);		if (gDHCPData->GetDataDHCPLeaseDataArray(index, &leaseDataEntry)) {			if (!leaseDataEntry.isEnabled) {				requestNotValid = true;				break;			}			if (msg->giaddr == 0) {				netInterface = inRequest->localAddr;				inRequest->netMask = leaseDataEntry.netMask;				inRequest->netNumber = netInterface & inRequest->netMask;			} else {				netInterface = msg->giaddr;				index = FindLeaseData(netInterface);				if (gDHCPData->GetDataDHCPLeaseDataArray(index, &leaseDataEntry)) {					if (!leaseDataEntry.isEnabled) {						requestNotValid = true;						break;					}					inRequest->netMask = leaseDataEntry.netMask;					inRequest->netNumber = netInterface & inRequest->netMask;				} else {					// no record of this interface being DHCP enabled					requestNotValid = true;					break;				}			}		} else {			// no record of this interface being DHCP enabled			requestNotValid = true;			break;		}	} while (false);		// switch on message type to build response	// BOOTP request?	if ((msg->op == kBootRequest) && (!requestNotValid)) {    	// get options    	UInt32	start, end;    	UInt8*	dp;    	start = 28 + 16 + 64 + 128;    	// check for magic cookie    	dp = inRequest->data;    	if (*((UInt32*)&msg->options) == 0x63825363) {    		start += 4;    	}    	end = inRequest->size;    	// Find options in message    	FindDHCPOptions(inRequest, start, end);    	// check for overloaded options    	if (inRequest->overload.option) {    		UInt8 value;    		value = dp[inRequest->overload.offset];    		if (value & 1) {    			// get options from "file"    			start = 28 + 16 + 64;    			end = start + 128;    			FindDHCPOptions(inRequest, start, end);    		}    		if (value & 2) {    			// get options from "sname"    			start = 28 + 16;    			end = start + 64;    			FindDHCPOptions(inRequest, start, end);    		}    	}		// Show user what we got		LogDHCPRequest(inRequest);		// handle each DHCP message type as a separate case		switch (inRequest->dhcpMessageType) {			case kDHCPDiscover:				// find a lease addr				result = FindLeaseAddr(inRequest);				if (!result) {					result = BuildResponse(inRequest, &dhcpResponse, kDHCPNack);					SendQResponse(&dhcpResponse);					break;				}				// find lease time				result = FindLeaseTime(inRequest);				if (!result) {					result = BuildResponse(inRequest, &dhcpResponse, kDHCPNack);					SendQResponse(&dhcpResponse);					break;				}				// build response				result = BuildResponse(inRequest, &dhcpResponse, kDHCPOffer);				if (!result) break;				// update status entry (lease binding)				result = UpdateLeaseBinding(inRequest, kLeaseOffered);				if (!result) break;									// check if new assigned address and need to ping					// get option setting				Boolean	pingCheck = true;				Str31	str;				::GetIndString(str, rSTRN_OptionSettings, kOptionDHCPPingCheck);				if ( BeginsWith(str, "\pDHCPPingCheck") && GetKeywordValue(str, str) ) {					long value;					::StringToNum(str, &value);					pingCheck = value;				}				if ((inRequest->needPing) && pingCheck) {					dhcpResponse.responseState = kRSPing;					// hold in response array until ready to send					OTGetTimeStamp(&dhcpResponse.timeStamp);					mResponseArray->AddItem(&dhcpResponse, sizeof(dhcp_response_t));					mIdleDelay = kIdleData;		// reduce idle time for data					SendPing(inRequest->yiaddr);					LThread::Yield();					break;				}				SendQResponse(&dhcpResponse);				break;			case kDHCPRequest:				// if serverID does not match, cancel offer if any and ignore				if (!CheckServerID(inRequest->dhcpServerID)) {					result = UpdateLeaseBinding(inRequest, kLeaseExpired);					gLogAction->LogText(							"\p\rCDHCPAction: Request with non-matching ServerID ignored.");					break;				}				// if INIT-REBOOT and invalid request for this network				do {					// test for INIT-REBOOT state					if ((inRequest->dhcpServerID != 0) ||						(inRequest->addressRequest == 0)) break;	// work around bug in Mac client (ciaddr != 0)						//(inRequest->addressRequest == 0) ||						//(msg->ciaddr != 0)) break;					// client is in INIT-REBOOT state					// check that request address is valid for this network					if (inRequest->netNumber != (inRequest->addressRequest & inRequest->netMask)) {						// lease addr is not valid for this request						requestNotValid = true;						result = BuildResponse(inRequest, &dhcpResponse, kDHCPNack);						SendQResponse(&dhcpResponse);						LStr255 text;						Str31	str;						text = "\p\rCDHCPAction: request addr ";						IP_NumToStr(inRequest->addressRequest, str);						text += str;						text += "\p is not valid for this network.";						gLogAction->LogText(text);						break;					}				} while (false);				if (requestNotValid) break;				// check that we have a lease binding for this request				index = FindLeaseStatus(inRequest);				if (index == 0) {					// no previous binding for this request, remain silent					gLogAction->LogText(						"\p\rCDHCPAction: no previous binding for this request.");					break;				}				do {					// find a lease addr					result = FindLeaseAddr(inRequest);					if (!result)  {						// no lease available for this request						result = BuildResponse(inRequest, &dhcpResponse, kDHCPNack);						gLogAction->LogText(							"\p\rCDHCPAction: no lease available for this request.");						break;					}					// find lease time					result = FindLeaseTime(inRequest);					if (!result) {						// lease has expired						result = BuildResponse(inRequest, &dhcpResponse, kDHCPNack);													gLogAction->LogText(							"\p\rCDHCPAction: lease has expired.");						break;					}					// build response					result = BuildResponse(inRequest, &dhcpResponse, kDHCPAck);					if (!result) break;					// update status entry (lease binding)					result = UpdateLeaseBinding(inRequest, kLeaseBound);					if (!result) break;					// commit to non-volatile storage					WriteStatusFile();				} while (false);				SendQResponse(&dhcpResponse);				break;			case kDHCPDecline:				// client has declined lease				UpdateLeaseBinding(inRequest, kLeaseDeclined);				// tell user				{					LStr255 text;					Str31	str;					IP_NumToStr(inRequest->addressRequest, str);					text = "\p\rClient has declined IP address: ";					text += str;					gLogAction->LogText(text);				}								break;			case kDHCPRelease:				// client is releasing lease				UpdateLeaseBinding(inRequest, kLeaseReleased);				break;			case kDHCPInform:				// like Request, but omit address and lease time				// build response				result = BuildResponse(inRequest, &dhcpResponse, kDHCPAck);				if (!result) break;				SendQResponse(&dhcpResponse);				break;			case kDHCPBootP:		// BOOTP, no message type, handle like discover				// find a lease addr				result = FindLeaseAddr(inRequest);				if (!result) break;				// find lease time				//result = FindLeaseTime(inRequest);				//if (!result) break;				inRequest->leaseTime = kLeaseReclaimPeriod;	// BOOTP has no time limit, use 60 days				// build response				result = BuildResponse(inRequest, &dhcpResponse, kDHCPOffer);				if (!result) break;				// update status entry (lease binding)				result = UpdateLeaseBinding(inRequest, kLeaseBootP);				if (!result) break;									SendQResponse(&dhcpResponse);				break;		}	// end switch	}	// end bootp request}// ---------------------------------------------------------------------------//		¥ SendQResponse// ---------------------------------------------------------------------------//	Try to send response, add to response queue if SendThread is busyvoidCDHCPAction::SendQResponse(dhcp_response_t* inResponse){	// set response state	inResponse->responseState = kRSReady;	// try to send response	if ( !SendResponse(inResponse) ) {		// hold in response array until ready to try again		OTGetTimeStamp(&inResponse->timeStamp);		mResponseArray->AddItem(inResponse, sizeof(dhcp_response_t));		mIdleDelay = kIdleData;		// reduce idle time for data	}}// ---------------------------------------------------------------------------//		¥ SendResponse// ---------------------------------------------------------------------------//	Send DHCP Response//	Try to send response, return false if SendThread is busyBooleanCDHCPAction::SendResponse(dhcp_response_t* inResponse){	ArpEntry_t 		arpEntry;	DHCPMessage_t*	msg;	Boolean			result;	msg = (DHCPMessage*)inResponse->buf;		// if thread is ready, send it	result = mSendUDPThread->IsReady();	if (result) {		// where to?		LInternetAddress address((UInt16)kDHCPClientPort);		switch (inResponse->respondVia) {			case kViaUnicast:				address.SetIPAddress(inResponse->ciaddr);				break;			case kViaBroadcast:				address.SetIPAddress(kBroadcastAddr);				break;			case kViaHardwareUnicast:				// if chaddr is not zero				if (( *(UInt32*)&msg->chaddr[0] != 0) || ( *(UInt16*)&msg->chaddr[4] != 0)) {					// stuff ARP cache					OTMemzero(&arpEntry, sizeof(ArpEntry_t));					gInterfacesData->InterfaceAddrToName(inResponse->localAddr, arpEntry.interfaceName);					arpEntry.protocolAddr = msg->yiaddr;					arpEntry.protocolMask = 0xFFFFFFFF;					OTMemcpy(&arpEntry.hardwareAddr, &msg->chaddr, 6);					gArpAction->ArpAddEntry(&arpEntry);					// then send it					address.SetIPAddress(msg->yiaddr);				} else {					// otherwise try to broadcast					inResponse->respondVia = kViaBroadcast;					address.SetIPAddress(kBroadcastAddr);				}				break;			case kViaRelayAgent:				address.SetIPAddress(msg->giaddr);				// we send to the server port on the Relay Agent per RFC 1541				address.SetHostPort(kDHCPServerPort);				gLogAction->LogText("\p\rRespond via Relay Agent on port:", kDHCPServerPort);				break;		}		mSendUDPThread->SendUData(address, &inResponse->buf[0], inResponse->dataLen);		// tell user what we did		LogDHCPResponse(inResponse);	}	return result;}// ---------------------------------------------------------------------------//		¥ SendPing// ---------------------------------------------------------------------------BooleanCDHCPAction::SendPing(UInt32 inPingAddress){	Boolean result = false;		// setup to send packet	LInternetAddress address(inPingAddress, 0);	UInt8 data[64];	icmpheader *icmp_header;	// Initialize ICMP header	icmp_header = (icmpheader*)&data[0];	icmp_header->type = 8;	// echo request	icmp_header->code = 0;	icmp_header->checksum = 0;	mPingCounter += 1;	icmp_header->identifier = mPingCounter;	icmp_header->sequence_number = kDHCPServerSN;		// ICMP data	OTStrCopy((char*)&data[8], "© Sustainable Softworks.");	icmp_header->checksum = IpSum((UInt16*)&data[0], (UInt16*)&data[32]);	// send data	// check to be sure thread hasn't died unexpectedly	if (mSendICMPThread) {		result = mSendICMPThread->SendUData(address, data, 32);	}	return result;}// ---------------------------------------------------------------------------//		¥ FindDHCPOptions// ---------------------------------------------------------------------------voidCDHCPAction::FindDHCPOptions(dhcp_request_t* inRequest, UInt32 start, UInt32 end){	UInt8*	dp;		UInt8	option;	UInt8	len;		dp = (UInt8*)inRequest->data;	option = kOptionPad;	while ((option != kOptionEnd) && (start < end)) {		option = dp[start++];		switch (option) {			case kOptionPad:				break;			case kOptionEnd:				break;			case kOptionSubnetMask:				len = dp[start++];				inRequest->subnetMask.option	= option;				inRequest->subnetMask.len		= len;				inRequest->subnetMask.offset	= start;				start += len;				break;			case kOptionHostName:				len = dp[start++];								inRequest->hostName.option = option;				inRequest->hostName.len = len;				inRequest->hostName.offset = start;				start += len;				break;			case kOptionAddressRequest:				len = dp[start++];								inRequest->addressRequest = *(UInt32*)&dp[start];				start += len;				break;			case kOptionAddressTime:				len = dp[start++];								inRequest->addressTime.option = option;				inRequest->addressTime.len = len;				inRequest->addressTime.offset = start;				start += len;				break;			case kOptionOverload:				len = dp[start++];				inRequest->overload.option	= option;				inRequest->overload.len		= len;				inRequest->overload.offset	= start;				start += len;				break;			case kOptionDHCPMessageType:				len = dp[start++];				inRequest->dhcpMessageType = dp[start];				start += len;				break;			case kOptionDHCPServerID:				len = dp[start++];				inRequest->dhcpServerID = *(UInt32*)&dp[start];				start += len;				break;			case kOptionParameterList:				len = dp[start++];				inRequest->parameterList.option	= option;				inRequest->parameterList.len = len;				inRequest->parameterList.offset	= start;								start += len;				break;			case kOptionDHCPMessage:				len = dp[start++];								inRequest->dhcpMessage.option = option;				inRequest->dhcpMessage.len = len;				inRequest->dhcpMessage.offset = start;				start += len;				break;			case kOptionDHCPMaxMsgSize:				len = dp[start++];								inRequest->dhcpMaxMsgSize.option = option;				inRequest->dhcpMaxMsgSize.len = len;				inRequest->dhcpMaxMsgSize.offset = start;				start += len;				break;			case kOptionRenewalTime:				len = dp[start++];								inRequest->renewalTime.option = option;				inRequest->renewalTime.len = len;				inRequest->renewalTime.offset = start;				start += len;				break;			case kOptionRebindingTime:				len = dp[start++];								inRequest->rebindingTime.option = option;				inRequest->rebindingTime.len = len;				inRequest->rebindingTime.offset = start;				start += len;				break;			case kOptionClassID:				len = dp[start++];				inRequest->classID.option	= option;				inRequest->classID.len		= len;				inRequest->classID.offset	= start;				start += len;				break;			case kOptionClientID:				len = dp[start++];				inRequest->clientID.option	= option;				inRequest->clientID.len		= len;				inRequest->clientID.offset	= start;				start += len;				break;			default:				len = dp[start++];				//gLogAction->LogText("\p\rFindOptions - Unrecognized DHCP option: ", option);				start += len;				break;		}	}}// ---------------------------------------------------------------------------//		¥ FindLeaseStatus// ---------------------------------------------------------------------------// Search the DHCP status array to find the corresponding lease record// if any and return its index.  Return zero if not found.//// Records are matched based on the unique lease identifier consisting of// "client HW addr" or "clientID" and network number of the attached network.// Notice it is possible for a single client to have more than one lease binding// if it is moved from one network to another managed by the same DHCP server.ArrayIndexTCDHCPAction::FindLeaseStatus(dhcp_request_t* inRequest){	UInt32			inLeaseAddr;	MACAddr_t		inHardwareAddr;	Str255			clientID;	DHCPMessage_t*	msg;	UInt8*			dp;	DHCPStatusEntry_t statusEntry;	ArrayIndexT		index, count;	ArrayIndexT		result=0;	do {		// get key from request		msg = (DHCPMessage*)inRequest->data;		dp = inRequest->data;			// get client ID if any		clientID[0] = 0;		inRequest->useClientID = false;		if (inRequest->clientID.option) {			clientID[0] = inRequest->clientID.len;			OTMemcpy(&clientID[1], &dp[inRequest->clientID.offset], clientID[0]);			// default to use clientID if present			inRequest->useClientID = true;		}			// otherwise use HW addr		OTMemcpy(&inHardwareAddr, &msg->chaddr, 6);			// use requested IP addr if present		inLeaseAddr = inRequest->addressRequest;				// search DHCP status array		count = gDHCPData->GetDataCountDHCPStatus();		// for each lease record		for (index=1; index<=count; index++) {			Boolean useClientID;			// get record data			if (!gDHCPData->GetDataDHCPStatusArray(index, &statusEntry)) continue;			// check clientID (if present) or HW addr			//if ((clientID[0]) || (statusEntry.clientID[0])) {			if (statusEntry.clientID[0]) {				if (!MatchClientID(clientID, statusEntry.clientID)) continue;				useClientID = true;			}			else {				if (!OTMemcmp(&inHardwareAddr, &statusEntry.hardwareAddr, 6)) continue;				useClientID = false;			}			// check if network number matches			if (inRequest->netNumber != (statusEntry.leaseAddr & inRequest->netMask)) continue;			// found a match			result = index;			// override useClientID based on match we actually found			inRequest->useClientID = useClientID;			break;		}			} while (false);		return result;}// ---------------------------------------------------------------------------//		¥ FindLeaseStatus// ---------------------------------------------------------------------------// Search the DHCP status array to find a lease record with this address// if any and return its index.  Return zero if not found.ArrayIndexTCDHCPAction::FindLeaseStatus(UInt32 inLeaseAddr){	DHCPStatusEntry_t statusEntry;	ArrayIndexT		index, count;	ArrayIndexT		result=0;	do {				// check parameters		if (inLeaseAddr == 0) break;		// search DHCP status array		count = gDHCPData->GetDataCountDHCPStatus();		// for each lease record		for (index=1; index<=count; index++) {			// get record data			if (!gDHCPData->GetDataDHCPStatusArray(index, &statusEntry)) continue;			// check if lease addr matches			if (statusEntry.leaseAddr != inLeaseAddr) continue;			// found a match			result = index;			break;		}			} while (false);		return result;}// ---------------------------------------------------------------------------//		¥ FindLeaseData// ---------------------------------------------------------------------------// Find lease data based on interface that received the request// and return its index.  Return zero if not found.ArrayIndexTCDHCPAction::FindLeaseData(dhcp_request_t* inRequest){	DHCPMessage_t*	msg;	UInt8*			dp;	DHCPLeaseDataEntry_t leaseDataEntry;	ArrayIndexT		index;	ArrayIndexT		result=0;	do {		// Make sure DHCP is enabled on the local interface that received		// this request and find corresponding lease data		msg = (DHCPMessage*)inRequest->data;		dp = inRequest->data;		index = FindLeaseData(inRequest->localAddr);		if (gDHCPData->GetDataDHCPLeaseDataArray(index, &leaseDataEntry)) {			if (!leaseDataEntry.isEnabled) break;			if (msg->giaddr) {				index = FindLeaseData(msg->giaddr);				if (gDHCPData->GetDataDHCPLeaseDataArray(index, &leaseDataEntry)) {					if (!leaseDataEntry.isEnabled) break;				} else break;		// no record of this interface being DHCP enabled			}		} else break;		// no record of this interface being DHCP enabled		result = index;	} while (false);		return result;}// ---------------------------------------------------------------------------//		¥ FindLeaseData// ---------------------------------------------------------------------------// Search the DHCP Lease Data array to find a lease record for this interface// if any and return its index.  Return zero if not found.ArrayIndexTCDHCPAction::FindLeaseData(UInt32 inLocalAddr){	DHCPLeaseDataEntry_t leaseDataEntry;	ArrayIndexT		index, count;	ArrayIndexT		result=0;	do {				// check parameters		if (inLocalAddr == 0) break;		// search DHCP lease data array		count = gDHCPData->GetDataCountDHCPLeaseData();		// for each lease record		for (index=1; index<=count; index++) {			// get record data			if (!gDHCPData->GetDataDHCPLeaseDataArray(index, &leaseDataEntry)) continue;			// check if interface addr matches			if ((leaseDataEntry.interfaceAddr & leaseDataEntry.netMask) !=				(inLocalAddr & leaseDataEntry.netMask)) continue;			// found a match			result = index;			break;		}			} while (false);		return result;}// ---------------------------------------------------------------------------//		¥ CheckServerID// ---------------------------------------------------------------------------// Check that ServerID (if present) matches an IP interface on this machine.// Returns false if no match foundBooleanCDHCPAction::CheckServerID(UInt32 inServerID){	InterfaceEntry_t	interfaceEntry;	ArrayIndexT			count, index;	Boolean 			result = false;	do {		if (inServerID == 0) {			// no ServerID specified, treat as match			result = true;			break;		}				// determine number of interfaces		count = gInterfacesData->GetDataCount();		// examine each one to check for match		for (index=1; index<=count; index++) {			if (!gInterfacesData->GetDataInterfacesArray(index, &interfaceEntry)) continue;			// found entry			if (inServerID == interfaceEntry.interfaceAddr) {				result = true;				break;			}		}	} while (false);		return result;}// ---------------------------------------------------------------------------//		¥ CheckStaticPool// ---------------------------------------------------------------------------// Check for address in Static Config pool// return non-zero index if foundArrayIndexTCDHCPAction::CheckStaticPool(UInt32 inLeaseAddr){	DHCPStaticCfgEntry_t staticCfgEntry;	ArrayIndexT		index, count;	ArrayIndexT		result = 0;	// search DHCP static config array	count = gDHCPData->GetDataCountDHCPStaticCfg();	// for each static config record	for (index=1; index<=count; index++) {		// get record data		if (!gDHCPData->GetDataDHCPStaticCfgArray(index, &staticCfgEntry)) continue;		// check if request address matches		if (inLeaseAddr == staticCfgEntry.leaseAddr) {			result = index;			break;		}	}	return result;}// ---------------------------------------------------------------------------//		¥ CheckDynamicPool// ---------------------------------------------------------------------------// Check for address in Dynamic poolArrayIndexTCDHCPAction::CheckDynamicPool(UInt32 inLeaseAddr){	DHCPDynamicCfgEntry_t dynamicCfgEntry;	ArrayIndexT		index, count;	ArrayIndexT		result = 0;	// search DHCP dynamic config array	count = gDHCPData->GetDataCountDHCPDynamicCfg();	// for each dynamic config record	for (index=1; index<=count; index++) {		// get record data		if (!gDHCPData->GetDataDHCPDynamicCfgArray(index, &dynamicCfgEntry)) continue;		// check if request address is in range		if ((inLeaseAddr < dynamicCfgEntry.startLeaseAddr) ||			(dynamicCfgEntry.endLeaseAddr < inLeaseAddr)) continue;		result = index;		break;	}	return result;}// Compare Client_ID strings and return true if they match.// Ignore the first byte if 0 per DHCP convention.BooleanCDHCPAction::MatchClientID(Str255 clientIDA, Str255 clientIDB){	Str255	strA, strB;	UInt8	lenA, lenB;	Boolean	result;		lenA = clientIDA[0];	lenB = clientIDB[0];		// strip leading indicator from clientIDA	if ((lenA >= 2) && (clientIDA[1] == 0)) {		lenA -= 1;		OTMemcpy(&strA[1], &clientIDA[2], lenA);		strA[0] = lenA;	} else {		OTMemcpy(&strA[1], &clientIDA[1], lenA);		strA[0] = lenA;	}		// strip leading indicator from clientIDB	if ((lenB >= 2) && (clientIDB[1] == 0)) {		lenB -= 1;		OTMemcpy(&strB[1], &clientIDB[2], lenB);		strB[0] = lenB;	} else {		OTMemcpy(&strB[1], &clientIDB[1], lenB);		strB[0] = lenB;	}	result = ::EqualString(strA, strB, true, true);	return result;}// ---------------------------------------------------------------------------//		¥ FindLeaseAddr// ---------------------------------------------------------------------------// Find an available lease address if any for this request.// If found, set yiaddr in request and return true,// otherwise return false.BooleanCDHCPAction::FindLeaseAddr(dhcp_request_t* inRequest){	UInt32			inLeaseAddr;	MACAddr_t		inHardwareAddr;	Str255			clientID;	DHCPMessage_t*	msg;	UInt8*			dp;	DHCPStatusEntry_t statusEntry;	DHCPStaticCfgEntry_t staticCfgEntry;	DHCPDynamicCfgEntry_t dynamicCfgEntry;	ArrayIndexT		index, count, found;	UInt32			currentTime;	UInt32			oldUpdate;	UInt32			oldAddr;	Boolean			match = false;	Boolean			inUse = false;	Boolean			result=false;	do {		// get key from request		msg = (DHCPMessage*)inRequest->data;		dp = inRequest->data;			// get client ID if any		clientID[0] = 0;		inRequest->useClientID = false;		if (inRequest->clientID.option) {			clientID[0] = inRequest->clientID.len;			OTMemcpy(&clientID[1], &dp[inRequest->clientID.offset], clientID[0]);			// default to use ClientID if present			inRequest->useClientID = true;		}			// get HW addr		OTMemcpy(&inHardwareAddr, &msg->chaddr, 6);			// get requested IP addr if any		inLeaseAddr = inRequest->addressRequest;				// Get current time for calculating remaining lease time.		// Note time is seconds since midnight, January 1, 1904		// and will fail around 2040.		::GetDateTime(&currentTime);		        //		// (1) Do we have a static config for this request?		// search DHCP static config array			// if message type is DHCPRequest, only match existing lease bindings		if (inRequest->dhcpMessageType != kDHCPRequest) {			found = 0;			count = gDHCPData->GetDataCountDHCPStaticCfg();			// for each static config record			for (index=1; index<=count; index++) {				Boolean useClientID;				// get record data				if (!gDHCPData->GetDataDHCPStaticCfgArray(index, &staticCfgEntry)) continue;				// check clientID (if present) or HW addr				//if (clientID[0] || staticCfgEntry.clientID[0]) {				if (staticCfgEntry.clientID[0]) {					if (!MatchClientID(clientID, staticCfgEntry.clientID)) continue;					useClientID = true;				} else {					if (!OTMemcmp(&inHardwareAddr, &staticCfgEntry.hardwareAddr, 6)) continue;					useClientID = false;				}				// found matching entry, check Network Interface				if (inRequest->netNumber == (staticCfgEntry.interfaceAddr & inRequest->netMask)) {					found = index;					// override useClientID based on match we actually found					inRequest->useClientID = useClientID;					break;				}				else {					if (staticCfgEntry.interfaceAddr == 0) {	// lock out this client						found = -1;						gLogAction->LogText("\p\rCDHCPAction: Static address=0, do not respond to this client.");						break;					}					gLogAction->LogText("\p\rCDHCPAction: static config address is not valid for this interface.");				}			}			if (found == -1) break;			if (found) {				// found a static config, check lease addr is not in use				index = FindLeaseStatus(staticCfgEntry.leaseAddr);				if (gDHCPData->GetDataDHCPStatusArray(index, &statusEntry)) {					// found a lease record					if ((statusEntry.leaseState == kLeaseBound) ||						(statusEntry.leaseState == kLeaseBootP)) {						// does the clientID or chaddr match?						match = false;						//if ((clientID[0]) || (statusEntry.clientID[0])) {						if (statusEntry.clientID[0]) {							if (MatchClientID(clientID, statusEntry.clientID)) match = true;						} else {							if (OTMemcmp(&inHardwareAddr, &statusEntry.hardwareAddr, 6)) match = true;						}						if (match) {							// yes, we can use it							inRequest->yiaddr = staticCfgEntry.leaseAddr;							result = true;							break;						} else {							gLogAction->LogText("\p\rCDHCPAction: static config address for this client");							gLogAction->LogText("\p is already bound to a different client.");						}					}					else {						// ClientID doesn't match, but it's not bound so we can use it						if ((statusEntry.leaseState != kLeaseDeclined) ||							(statusEntry.leaseState != kLeaseInUse)) {							inRequest->yiaddr = staticCfgEntry.leaseAddr;							result = true;							if (msg->ciaddr != inRequest->yiaddr) inRequest->needPing = true;							break;						}					}				} else {					// no lease record so we can use it					inRequest->yiaddr = staticCfgEntry.leaseAddr;					if (msg->ciaddr != inRequest->yiaddr) inRequest->needPing = true;					result = true;					break;				}			}		}						// 		// (2) Do we already have a lease binding for this request?			// look for matching lease record		index = FindLeaseStatus(inRequest);		if (gDHCPData->GetDataDHCPStatusArray(index, &statusEntry)) {			// clientID and network number matches			Boolean inDynamicPool=true;			// remember existing lease state			inRequest->leaseState = statusEntry.leaseState;			switch (statusEntry.leaseState) {				case kLeaseBound:				case kLeaseBootP:				case kLeaseOffered:					// set your addr and return true					inRequest->yiaddr = statusEntry.leaseAddr;					// get remaining time on this lease for reference					if (statusEntry.expireTime > currentTime) {						inRequest->leaseTime = statusEntry.expireTime - currentTime;					}					result = true;					break;				case kLeaseExpired:				case kLeaseReleased:					// did client request a different address?					if (inRequest->addressRequest != statusEntry.leaseAddr) {					    gDHCPData->RemoveDataDHCPStatusArray(index);					    break;					}					// lease has expired or been released, check if still valid					if (CheckDynamicPool(statusEntry.leaseAddr)) {						// set your addr						inRequest->yiaddr = statusEntry.leaseAddr;						// get remaining time on this lease for reference						if (statusEntry.expireTime > currentTime) {							inRequest->leaseTime = statusEntry.expireTime - currentTime;						}														// set to ping since it was released or expired						if (msg->ciaddr != inRequest->yiaddr) inRequest->needPing = true;						result = true;					} else {						gDHCPData->RemoveDataDHCPStatusArray(index);					}					break;			}			if (result) break;	// return		}		// search on requestAddr alone 		index = FindLeaseStatus(inLeaseAddr);		if (gDHCPData->GetDataDHCPStatusArray(index, &statusEntry)) {			// we found a matching lease Addr, but clientID doesn't match			// if lease is bound remember it's in use.			if ((statusEntry.leaseState == kLeaseBound) ||				(statusEntry.leaseState == kLeaseBootP) ||				(statusEntry.leaseState == kLeaseDeclined) ||				(statusEntry.leaseState == kLeaseInUse)) {				inUse = true;			}		}		// if message type is DHCPRequest, only match existing lease bindings		if (inRequest->dhcpMessageType == kDHCPRequest) break;		// 		// (3) Do we have a dynamic address for this request?		if (inRequest->dhcpMessageType == kDHCPBootP) {			// check option setting			Boolean	dynamicBOOTP = true;			Str31	str;			::GetIndString(str, rSTRN_OptionSettings, kOptionDynamicBOOTP);			if ( BeginsWith(str, "\pDynamicBOOTP") && GetKeywordValue(str, str) ) {				long value;				::StringToNum(str, &value);				dynamicBOOTP = value;			}			if (dynamicBOOTP) {				gLogAction->LogText("\p\rWARNING: no static configuration found for BOOTP request.");				gLogAction->LogText("\p\r IPNetRouter will try to assign a dynamic address,");				gLogAction->LogText("\p\r the BOOTP client may not release this upon lease expiration.");			}			else break;		}		// search DHCP dynamic config array			// is there a request address that's not already bound?		if (inLeaseAddr && !inUse) {			// yes, see if we own it			// search DHCP dynamic config array			index = CheckDynamicPool(inLeaseAddr);			if (gDHCPData->GetDataDHCPDynamicCfgArray(index, &dynamicCfgEntry)) {				// we own it, check for matching Network Interface				if (inRequest->netNumber == (dynamicCfgEntry.interfaceAddr & inRequest->netMask)) {					inRequest->yiaddr = inLeaseAddr;					if (msg->ciaddr != inRequest->yiaddr) inRequest->needPing = true;					result = true;					break;				}			}		}		// no request addr or in use, look for a new addr		// search DHCP dynamic config array		oldAddr = 0;		oldUpdate = 0xFFFFFFFF;	// time infinity		count = gDHCPData->GetDataCountDHCPDynamicCfg();		// for each dynamic config record		for (index=1; index<=count; index++) {			// get record data			if (!gDHCPData->GetDataDHCPDynamicCfgArray(index, &dynamicCfgEntry)) continue;			// check for matching interface			if (inRequest->netNumber != (dynamicCfgEntry.interfaceAddr & inRequest->netMask)) continue;			// try each possible address			if (dynamicCfgEntry.startLeaseAddr <= dynamicCfgEntry.endLeaseAddr) {				UInt32 leaseAddr;				for (leaseAddr=dynamicCfgEntry.startLeaseAddr;					leaseAddr<=dynamicCfgEntry.endLeaseAddr;					leaseAddr++) {					// check lease record					found = FindLeaseStatus(leaseAddr);					if (gDHCPData->GetDataDHCPStatusArray(found, &statusEntry)) {						// found a lease record						if ((statusEntry.leaseState == kLeaseReleased) ||							(statusEntry.leaseState == kLeaseExpired)) {							// remember oldest released addr available							if (statusEntry.lastUpdate < oldUpdate) {								oldUpdate = statusEntry.lastUpdate;								oldAddr = leaseAddr;							}						}					} else {						// no lease record						// check that leaseAddr is valid for this network						if (inRequest->netNumber != (leaseAddr & inRequest->netMask)) break;						// check it's not a static config						if (CheckStaticPool(leaseAddr) != 0) continue;						// use it						inRequest->yiaddr = leaseAddr;						if (msg->ciaddr != inRequest->yiaddr) inRequest->needPing = true;						result = true;						break;												}				}				if (result) break;			}		}		if (result) break;		// We didn't find an address without a lease record		// Use the oldest released, or offerred address we found		if (oldAddr) {			inRequest->yiaddr = oldAddr;			if (msg->ciaddr != inRequest->yiaddr) inRequest->needPing = true;			result = true;		}	} while (false);		// if we got an address, return true	result = (inRequest->yiaddr != 0);	return result;}// ---------------------------------------------------------------------------//		¥ FindLeaseTime// ---------------------------------------------------------------------------// Find an appropriate lease time for this requestBooleanCDHCPAction::FindLeaseTime(dhcp_request_t* inRequest){	DHCPMessage_t*	msg;	UInt8*			dp;	DHCPLeaseDataEntry_t leaseDataEntry;	ArrayIndexT		index;	UInt32			inAddressTime=0;	Boolean			result=false;	do {		// Make sure DHCP is enabled on the local interface that received		// this request and find corresponding lease data		msg = (DHCPMessage*)inRequest->data;		dp = inRequest->data;		index = FindLeaseData(inRequest->localAddr);		if (gDHCPData->GetDataDHCPLeaseDataArray(index, &leaseDataEntry)) {			if (!leaseDataEntry.isEnabled) break;			if (msg->giaddr) {				index = FindLeaseData(msg->giaddr);				if (gDHCPData->GetDataDHCPLeaseDataArray(index, &leaseDataEntry)) {					if (!leaseDataEntry.isEnabled) break;				} else break;		// no record of this interface being DHCP enabled			}		} else break;		// no record of this interface being DHCP enabled		// Get requested addressTime if any		if (inRequest->addressTime.option) {			inAddressTime = *(UInt32*)&dp[inRequest->addressTime.offset];			// is request acceptable?			if (120 < inAddressTime) {	// ignore less than 2 minutes				if (inAddressTime < leaseDataEntry.leaseMaxTime) {					// yes, use it					inRequest->leaseTime = inAddressTime;					result = true;					break;				} else {					// use maximum time allowed					inRequest->leaseTime = leaseDataEntry.leaseMaxTime;						result = true;					break;				}			}		}		// no explicit request		// client is in RENEWING or REBINDING state		if ((inRequest->dhcpMessageType == kDHCPRequest) &&			(inRequest->dhcpServerID == 0) &&			(inRequest->addressRequest == 0) &&			(msg->ciaddr == inRequest->yiaddr)) {			// use default lease time			inRequest->leaseTime = leaseDataEntry.leaseDefaultTime;			result = true;			gLogAction->LogText("\p\r RENEW or REBIND, lease time extended");			break;						}		if (inRequest->dhcpMessageType == kDHCPDiscover) {			if (((inRequest->leaseState == kLeaseBound) ||				 (inRequest->leaseState == kLeaseOffered)) &&				(inRequest->leaseTime)) {				// use previously assigned expiration time or maximum allowed whichever is less				// if previously assigned expiration time is less than 2 minutes, use default				if (inRequest->leaseTime < 120) inRequest->leaseTime = leaseDataEntry.leaseDefaultTime;				if (inRequest->leaseTime > leaseDataEntry.leaseMaxTime) {					inRequest->leaseTime = leaseDataEntry.leaseMaxTime;					}				result = true;				break;			}			else {							// use default lease time				inRequest->leaseTime = leaseDataEntry.leaseDefaultTime;				result = true;				break;			}			}		// use remaining time if any (from previously bound or offered lease)		if (inRequest->leaseTime) result = true;	} while (false);		// return true if we can assign a lease time	return result;}// ---------------------------------------------------------------------------//		¥ FindRespondVia// ---------------------------------------------------------------------------// Determine how we should send a response to this request// Upon return set "respondVia" in inResponseUInt8CDHCPAction::FindRespondVia(dhcp_response_t* inResponse){	DHCPMessage_t*	msg;	UInt8			result = kViaNone;		do {		// setup access to message data		msg = (DHCPMessage*)inResponse->buf;		// if giaddr is nonzero, send to relay agent		if (msg->giaddr != 0) {			result = kViaRelayAgent;			// if message type is NAK, set Broadcast flag in response			if (inResponse->dhcpMessageType == kDHCPNack) {				msg->flags |= kBroadcastFlag;			}			break;		}		// use broadcast if requested		if (msg->flags & kBroadcastFlag) {			result = kViaBroadcast;			break;		}		// giaddr=0; always broadcast NAKs		if (inResponse->dhcpMessageType == kDHCPNack) {			result = kViaBroadcast;			break;		}		// use ciaddr if present		if (inResponse->ciaddr != 0) {			result = kViaUnicast;			// Override if (ciaddr != yiaddr)			// Defensive: some clients include a nonconforming ciaddr			if (inResponse->ciaddr != inResponse->yiaddr) {				result = kViaBroadcast;			}			break;		}		// giaddr and ciaddr are 0		// broadcast bit is not set				// default to hardware unicast		result = kViaHardwareUnicast;				// if it didn't work the last time, try to broadcast		if ((inResponse->leaseState == kLeaseOffered) &&			(inResponse->dhcpMessageType == kDHCPOffer)) {			// lease binding was previously offerred and not received			// use broadcast to send subsequent offer			result = kViaBroadcast;		}		if (((inResponse->leaseState == kLeaseBound) || (inResponse->leaseState == kLeaseBootP)) &&			(inResponse->dhcpMessageType == kDHCPAck)) {			// lease is already in bound state and we're sending an Ack			DHCPStatusEntry_t	statusEntry;			ArrayIndexT			index;			UInt32				currentTime;			// find status entry (lease binding)			index = FindLeaseStatus(inResponse->yiaddr);			if (gDHCPData->GetDataDHCPStatusArray(index, &statusEntry)) {				// get current time				::GetDateTime(&currentTime);				if (currentTime-statusEntry.lastUpdate < 60) {					// if last update was less than a minute ago					// use broadcast to send subsequent ACK					result = kViaBroadcast;				}			}		}	} while (false);		return result;}// ---------------------------------------------------------------------------//		¥ Build DHCP Response// ---------------------------------------------------------------------------//	Build specified DHCP response from collected informationBooleanCDHCPAction::BuildResponse(				dhcp_request_t* inRequest,				dhcp_response_t* outResponse,				UInt8 responseType){	DHCPLeaseDataEntry_t leaseDataEntry;	DHCPMessage_t*	inMsg;	DHCPMessage_t*	outMsg;	UInt8*			inDP;	UInt8*			outDP;	Boolean			result = false;	// setup access to inRequest	inMsg = (DHCPMessage*)inRequest->data;	inDP = inRequest->data;	outMsg = (DHCPMessage*)&outResponse->buf[0];	outDP = &outResponse->buf[0];	// initialize the response data structure	OTMemzero(outResponse, sizeof(dhcp_response_t));		// set max len	outResponse->maxLen = kMaxResponseLen;		// use Max Message Size option if specified	if (inRequest->dhcpMaxMsgSize.option) {		outResponse->maxLen = *(UInt16*)&inDP[inRequest->dhcpMaxMsgSize.offset];	}		// set response ID for reference	outResponse->xid = inMsg->xid;		// copy ciaddr and localAddr for reference	outResponse->ciaddr = inMsg->ciaddr;	outResponse->localAddr = inRequest->localAddr;	outResponse->remoteAddr = inRequest->remoteAddr;	outResponse->leaseState = inRequest->leaseState;		// remember message type	outResponse->dhcpMessageType = responseType;		do {		// begin loading response based on request		// start with those parts that are message type independent		outMsg->op		= kBootReply;		outMsg->htype	= inMsg->htype;		outMsg->hlen	= inMsg->hlen;		outMsg->hops	= 0;		outMsg->xid		= inMsg->xid;		outMsg->secs	= 0;		outMsg->ciaddr	= 0;		if (responseType == kDHCPAck) outMsg->ciaddr = inMsg->ciaddr;		outMsg->flags	= inMsg->flags;		outMsg->giaddr	= inMsg->giaddr;		OTMemcpy(&outMsg->chaddr, &inMsg->chaddr, 6);		//OTStrCopy(&outMsg-sname, &inMsg->sname);				// begin setting options		UInt16 offset;		offset = (UInt8*)&outMsg->options[0] - (UInt8*)&outMsg->op;		// required options			// magic cookie		UInt32 cookie = 0x63825363;		OTMemcpy(&outDP[offset], &cookie, 4);		offset += 4;			// message type		PutOption(outDP, &offset, kOptionDHCPMessageType, 1, &responseType);			// server ID		PutOption(outDP, &offset, kOptionDHCPServerID, 4, (UInt8*)&inRequest->localAddr);				// load parts based on response type		if (responseType == kDHCPNack) {			// DHCPNAK			outMsg->yiaddr = 0;			outMsg->siaddr = 0;		} else {			if (inRequest->dhcpMessageType != kDHCPInform) {				// DHCPOFFER or DHCPACK					// lease address				outResponse->yiaddr = inRequest->yiaddr;				outMsg->yiaddr = inRequest->yiaddr;				outMsg->siaddr = 0;	// unknown				// lease time				PutOption(outDP, &offset, kOptionAddressTime, 4, (UInt8*)&inRequest->leaseTime);			}			// get lease data entry			ArrayIndexT index;			index = FindLeaseData(inRequest);			if (!gDHCPData->GetDataDHCPLeaseDataArray(index, &leaseDataEntry)) {				gLogAction->LogText("\p\rCDHCPAction::BuildResponse - no lease data");				break;			}			// remember which options we've seen			Boolean seenSubnetMask = false;			Boolean seenRouters = false;			Boolean seenDomainServer = false;			Boolean seenDomainName = false;			// additional options as requested then any defaults			if (inRequest->parameterList.option) {				UInt8 len, i, option, nameLen;				len = inRequest->parameterList.len;				for (i=0; i<len; i++) {					option = inDP[inRequest->parameterList.offset + i];					switch(option) {						case kOptionSubnetMask:							PutOption(outDP, &offset, option, 4, (UInt8*)&leaseDataEntry.netMask);							seenSubnetMask = true;							break;						case kOptionRouters:							PutAddrList(outDP, &offset, option, (UInt8*)leaseDataEntry.routerAddrStr);							seenRouters = true;							break;						case kOptionDomainServer:							PutAddrList(outDP, &offset, option, leaseDataEntry.nameServerAddrStr);													seenDomainServer = true;							break;						case kOptionDomainName:							nameLen = leaseDataEntry.domainNameStr[0];							if (nameLen) {								PutOption(outDP, &offset, option,  nameLen, (UInt8*)&leaseDataEntry.domainNameStr[1]);								seenDomainName = true;							}							break;						default:						    // allow any additional options from "DHCP" resource                            {                            	OSErr		err;                            	short		stringID;                            	Handle		h;                            	UInt16      size;                            	// Get option data from resource if any                            	stringID = kPortStart + option;                            	err = ECGetResource('DHCP', stringID, &h);                             	if (err == noErr) {                            		// return resource data as option value        						    size = ::GetHandleSize(h);        							if ((0 < size) && (size < 256)) {        								PutOption(outDP, &offset, option, (UInt8)size, (UInt8*)*h);        							}                            		::ReleaseResource(h);                            	}                            }						    break;					}				}			}			// continue with any default options we haven't seen			if (!seenSubnetMask)				PutOption(outDP, &offset, kOptionSubnetMask, 4, (UInt8*)&leaseDataEntry.netMask);			if (!seenRouters)				PutAddrList(outDP, &offset, kOptionRouters, leaseDataEntry.routerAddrStr);			if (!seenDomainServer)				PutAddrList(outDP, &offset, kOptionDomainServer, leaseDataEntry.nameServerAddrStr);									if (!seenDomainName) {				UInt8 nameLen;				nameLen = leaseDataEntry.domainNameStr[0];				if (nameLen) {					PutOption(outDP, &offset, kOptionDomainName, nameLen, &leaseDataEntry.domainNameStr[1]);					seenDomainName = true;				}			}		}		// if NAK or ACK include user message		Str255 str;		if (responseType == kDHCPNack) {			GetIndString (str, rDHCPMessageStrings , kDHCPStrUserNakMessage);			if (str[0] > 0) PutOption(outDP, &offset, kOptionDHCPMessage, str[0], &str[1]);		}		else if (responseType == kDHCPAck) {			GetIndString (str, rDHCPMessageStrings , kDHCPStrUserAckMessage);			if (str[0] > 0) PutOption(outDP, &offset, kOptionDHCPMessage, str[0], &str[1]);		}		// finish with "END" option		outDP[offset++] = kOptionEnd;		if ((offset & 0x0001)) outDP[offset++] = kOptionPad;	// pad (length=offset-1) to even number		outDP[offset++] = kOptionPad;		// find where to send response		outResponse->respondVia = FindRespondVia(outResponse);		// record message length		outResponse->dataLen = offset-1;		result = true;	} while (false);	return result;}// ---------------------------------------------------------------------------//		¥ PutOption// ---------------------------------------------------------------------------//	Put DHCP option in message, update offset to one past optionvoidCDHCPAction::PutOption(UInt8* buffer, UInt16* ioOffset,	UInt8 optionCode, UInt8 optionLen, UInt8* optionData){	UInt16 offset;	offset = *ioOffset;		buffer[offset++] = optionCode;	buffer[offset++] = optionLen;	OTMemcpy(&buffer[offset], optionData, optionLen);	offset += optionLen;		*ioOffset = offset;}// ---------------------------------------------------------------------------//		¥ PutAddrList// ---------------------------------------------------------------------------//	Put text address list in message option//	If (optionCode == kOptionDomainServer) replace 0 with current DNSBooleanCDHCPAction::PutAddrList(UInt8* buffer, UInt16* ioOffset,	UInt8 optionCode, Str255 inList){	UInt32	addr[16];	// upto 16 routers or servers	UInt16	offset, start;	LStr255 text;	UInt8	pos, j, last;	Boolean	result = false;		text = inList;	// convert each addr to an integer	for (j=1; j<16; j++) {		addr[j] = IP_StrToInt(text);		// treat DNS=0 as a special case to be replaced with current DNS		if ((optionCode == kOptionDomainServer) && (addr[j] == 0)) {			Str255 addrStr;			gInterfacesAction->GetDNSAddress(addrStr);			addr[j] = IP_StrToInt(addrStr);		}		// is there another address?		pos = text.Find( '\r', 1 );		if (pos != 0) text.Assign( text, pos+1, 255 );		else {			last = j;			break;		}	}	// write out option	offset = *ioOffset;	start = offset;	buffer[offset++] = optionCode;	buffer[offset++] = last*4;	for (j=1; j<=last; j++) {		if (addr[j]) {			// if valid addr, add to list			OTMemcpy(&buffer[offset], &addr[j], 4);			offset += 4;		} else buffer[start+1] -= 4;	// otherwise adjust option len	}	if (offset > start+2) {		*ioOffset = offset;		result = true;	}	return result;}// ---------------------------------------------------------------------------//		¥ UpdateLeaseBinding// ---------------------------------------------------------------------------// Update entry in DHCP status table based on collected info and new stateBooleanCDHCPAction::UpdateLeaseBinding(dhcp_request_t* inRequest, UInt8 leaseState){	DHCPMessage_t*	inMsg;	UInt8*			dp;	DHCPStatusEntry_t	statusEntry;	ArrayIndexT		index;	UInt32			currentTime;	Str255			clientID;	Boolean			result = false;	// Setup access to request data	inMsg = (DHCPMessage*)inRequest->data;	dp = inRequest->data;	// get current time	::GetDateTime(&currentTime);		switch (leaseState) {		case kLeaseOffered:		case kLeaseBound:		case kLeaseBootP:					// find status entry (lease binding)			index = FindLeaseStatus(inRequest->yiaddr);			if (!gDHCPData->GetDataDHCPStatusArray(index, &statusEntry)) {				// if no previous entry, just create one				index = gDHCPData->GetDataCountDHCPStatus() + 1;				OTMemzero(&statusEntry, sizeof(DHCPStatusEntry_t));			}			// set corresponding fields				// lease addr			statusEntry.leaseAddr = inRequest->yiaddr;					// hw addr			OTMemcpy(&statusEntry.hardwareAddr, &inMsg->chaddr, 6);				// clientID			clientID[0] = 0;			if (inRequest->clientID.option && inRequest->useClientID) {				clientID[0] = inRequest->clientID.len;				OTMemcpy(&clientID[1], &dp[inRequest->clientID.offset], clientID[0]);			}			LString::CopyPStr(clientID, statusEntry.clientID, 255);				// expire time			statusEntry.expireTime = currentTime + inRequest->leaseTime;				// last update time			statusEntry.lastUpdate = currentTime;				// lease state			statusEntry.leaseState = leaseState;			// write entry				gDHCPData->SetDataDHCPStatusArray(index, &statusEntry);			result = true;			break;		case kLeaseReleased:			index = FindLeaseStatus(inRequest);			if (gDHCPData->GetDataDHCPStatusArray(index, &statusEntry)) {				// last update time				statusEntry.lastUpdate = currentTime;				// lease state				statusEntry.leaseState = leaseState;				// write entry					gDHCPData->SetDataDHCPStatusArray(index, &statusEntry);				result = true;			}			break;		case kLeaseExpired:			// used to cancel offer if DHCPRequest for another server			inRequest->addressRequest = 0;	// ignore request Addr			index = FindLeaseStatus(inRequest);			if (gDHCPData->GetDataDHCPStatusArray(index, &statusEntry)) {				if (statusEntry.leaseState == kLeaseOffered) {					// last update time					statusEntry.lastUpdate = currentTime;					// lease state					statusEntry.leaseState = leaseState;					// write entry						gDHCPData->SetDataDHCPStatusArray(index, &statusEntry);					result = true;				}			}			break;		case kLeaseDeclined:			index = FindLeaseStatus(inRequest);			if (gDHCPData->GetDataDHCPStatusArray(index, &statusEntry)) {				// reset the Client_ID for this entry so the client who Declined				// this lease will no longer match it.				statusEntry.clientID[0] = 0;				bzero((UInt8*)&statusEntry.hardwareAddr, 6);				// last update time				statusEntry.lastUpdate = currentTime;				// lease state				statusEntry.leaseState = leaseState;				// write entry					gDHCPData->SetDataDHCPStatusArray(index, &statusEntry);				result = true;			}			break;	}	return result;}