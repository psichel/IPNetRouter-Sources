// ===========================================================================//	CIPTable.cp				© 1996 Sustainable Softworks. All rights reserved.//		Based on//	LTable.cp					   © 1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	A two-dimensional array of rectangular cells.//	Use LTable to keep it simple.//		Adds adjustable widths, cell borders, and custom cell types#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include "CIPTable.h"#include "AGAColors.h"#include "CScroller.h"#include "IPSupport.h"#include "UDragAndDropUtils.h"#include <LStream.h>#include <UDrawingState.h>#include <UDrawingUtils.h>#include <LString.h>#include <Icons.h>#ifndef __LOWMEM__#include <LowMem.h>#endif#ifndef __TOOLUTILS__#include <ToolUtils.h>#endif// ---------------------------------------------------------------------------//		¥ CreateTableStream [static]// ---------------------------------------------------------------------------//	Return a new Table object initialized using data from a StreamCIPTable*CIPTable::CreateIPTableStream(	LStream	*inStream){	return (new CIPTable(inStream));}// ---------------------------------------------------------------------------//		¥ CIPTable(LStream*)// ---------------------------------------------------------------------------//	Construct from the data in a StreamCIPTable::CIPTable(	LStream	*inStream)		: LTable(inStream),		LDragAndDrop( UQDGlobals::GetCurrentPort(), this ){	// initialize adjustable widths to the default fixed width	for (TableIndexT col=1; col<=kMaxCols; col++)		mMultiColWidth[col] = mColWidth;	// mark edit field as undefined	mIPEditField = nil;	mEditField = nil;	mPopupMenu = nil;	mEditCell.row = 0;	// indicate not editing (Edit != Selected != any valid cell)	mEditCell.col = 1;	mSelectedCell.row = 1;	mSelectedCell.col = 0;	mDropCell.row = 0;	// Drag and Drop destination undefined	mCommentData = nil;	// Initialize for no comment data		// initialize table data	TableCellT	tCell;	IPNumItem	tData;	tData.a = 0;	tData.b = 0;	DisplayItem	uData;	LString::CopyPStr("\pS", uData.a);	LString::CopyPStr("\pS", uData.b);	for (tCell.row=1; tCell.row<=mRows; tCell.row++) {		for (tCell.col=1; tCell.col<=mCols; tCell.col++) {			if (tCell.col == 1) SetCellData( tCell, &uData );			else SetCellData( tCell, &tData );		}	}}CIPTable::~CIPTable(){	if (mCommentData) delete mCommentData;}voidCIPTable::SetIPEditField(	LEditField	*inEditField){	mIPEditField = inEditField;}voidCIPTable::SetEditField(	LEditField	*inEditField){	mEditField = inEditField;}voidCIPTable::SetPopupMenu(	LStdPopupMenu	*inPopupMenu){	mPopupMenu = inPopupMenu;}// ---------------------------------------------------------------------------//		¥ Set Comment Data Size// ---------------------------------------------------------------------------// Create DynamicArray for holding comment data// mCommentData must not already be allocatedvoidCIPTable::SetCommentDataSize(	Int32	inCommentDataSize){	if ((mCommentData == nil) && (inCommentDataSize > 0)) {		mCommentData = new LArray(inCommentDataSize);		mCommentData->InsertItemsAt(mRows*2, 1, "\p ", 2); // (numItems, inAt, *item, itemSize)	}}// ---------------------------------------------------------------------------//		¥ Set Column Type// ---------------------------------------------------------------------------//	Set the column display typevoidCIPTable::SetColType(	Int32		inHowMany,	TableIndexT	inAfterCol,	ColType		inType,	ColType		inOption){	Assert_( (inAfterCol+inHowMany) <= mCols );	DisplayItem	tData;	tData.a[0] = inType;	tData.a[1] = inOption;	tData.b[0] = inType;	tData.b[1] = inOption;	TableCellT	theCell;	theCell.row = mRows;	for (theCell.col = (inAfterCol + 1);		 theCell.col <= (inAfterCol+inHowMany);		 theCell.col++) {		SetCellData(theCell, &tData);	}}// ---------------------------------------------------------------------------//		¥ Get Column Type// ---------------------------------------------------------------------------//	Get the column display typevoidCIPTable::GetColType(TableIndexT inCol, ColType &outType, ColType &outOption){	Assert_( inCol<= mCols );	DisplayItem	tData;	TableCellT	theCell;	theCell.row = mRows;	theCell.col = inCol;	GetCellData(theCell, &tData);	outType = tData.a[0];	outOption = tData.a[1];}#pragma mark --- Geometry ---// ---------------------------------------------------------------------------//		¥ Insert/Remove Rows// ---------------------------------------------------------------------------voidCIPTable::InsertRows(	Int32		inHowMany,	TableIndexT	inAfterRow,	void		*inCellData){		// +++ Bounds check input params		if (mCellData != nil) {		mCellData->InsertItemsAt(inHowMany * mCols, inAfterRow * mCols + 1,									inCellData);	}	if (mCommentData != nil) {		mCommentData->InsertItemsAt(inHowMany * 2, inAfterRow * 2 + 1, "\p ", 2);	}									mRows += inHowMany;		ResizeImageBy(0, inHowMany * mRowHeight, true);}voidCIPTable::RemoveRows(	Int32		inHowMany,	TableIndexT	inFromRow){		// +++ Bounds check input params		if (mCellData != nil) {		mCellData->RemoveItemsAt(inHowMany * mCols,									(inFromRow - 1) * mCols + 1);	}	if (mCommentData != nil) {		mCommentData->RemoveItemsAt(inHowMany * 2,									(inFromRow - 1) * 2 + 1);	}	mRows -= inHowMany;		ResizeImageBy(0, -inHowMany * mRowHeight, true);}// ---------------------------------------------------------------------------//		¥ Insert Columns// ---------------------------------------------------------------------------voidCIPTable::InsertCols(	Int32		inHowMany,	TableIndexT	inAfterCol,	void		*inCellData){		// +++ Bounds check input params	Assert_( (inAfterCol+inHowMany) <= kMaxCols );		if (mCellData != nil) {		Int32	insertAtIndex = inAfterCol + 1;		for (TableIndexT row = 1; row <= mRows; row++) {			mCellData->InsertItemsAt(inHowMany, insertAtIndex, inCellData);			insertAtIndex += mCols + inHowMany;		}	}		mCols += inHowMany;		Int32	adjWidth = 0;	for (TableIndexT col=inAfterCol+1; col<=inAfterCol+inHowMany; col++) {		adjWidth += mMultiColWidth[col];	}	ResizeImageBy(adjWidth, 0, true);}// ---------------------------------------------------------------------------//		¥ Remove Columns// ---------------------------------------------------------------------------voidCIPTable::RemoveCols(	Int32		inHowMany,	TableIndexT	inFromCol){		// +++ Bounds check input params	Assert_(inHowMany <= mCols);		if (mCellData != nil) {		Int32	removeAtIndex = inFromCol;		for (TableIndexT row = 1; row <= mRows; row++) {			mCellData->RemoveItemsAt(inHowMany, removeAtIndex);			removeAtIndex += (mCols - inHowMany);		}	}		mCols -= inHowMany;		Int32	adjWidth = 0;	for (TableIndexT col=inFromCol; col<inFromCol+inHowMany; col++) {		adjWidth -= mMultiColWidth[col];	}	ResizeImageBy(adjWidth, 0, true);}// ---------------------------------------------------------------------------//		¥ Set Column Width// ---------------------------------------------------------------------------voidCIPTable::SetColWidth(	Int16		inWidth,	TableIndexT	inFromCol,	TableIndexT	inToCol){TableIndexT		col;Int32			adjWidth = 0;	for (col=1; col<=mCols; col++)			// compute total old width		adjWidth += mMultiColWidth[col];	if ((inFromCol <= inToCol) && (inToCol <= kMaxCols)) {		for (col=inFromCol; col<=inToCol; col++)			mMultiColWidth[col] = inWidth;	}	for (col=1; col<=mCols; col++)			// subtract total new width		adjWidth -= mMultiColWidth[col];			ResizeImageBy(adjWidth, 0, true);}// ---------------------------------------------------------------------------//		¥ Get Column Width// ---------------------------------------------------------------------------Int16CIPTable::GetColWidth( TableIndexT inCol ){	return mMultiColWidth[inCol];}// ---------------------------------------------------------------------------//		¥ Fetch Local Cell Frame// ---------------------------------------------------------------------------BooleanCIPTable::FetchLocalCellFrame(	const TableCellT	&inCell,	Rect				&outCellFrame){								// Get Top-Left in Image coordinates	SPoint32	cellImage;	cellImage.h = 0;	for (TableIndexT col=1; col<=(inCell.col-1); col++)		cellImage.h += mMultiColWidth[col];		cellImage.v = (inCell.row - 1) * mRowHeight;									// Check if Cell intersects the Frame	Boolean	intersectsFrame = ImageRectIntersectsFrame(									cellImage.h, cellImage.v,									cellImage.h + mMultiColWidth[inCell.col],									cellImage.v + mRowHeight);									// Convert to Local coordinates	ImageToLocalPoint(cellImage, topLeft(outCellFrame));	outCellFrame.right = outCellFrame.left + mMultiColWidth[inCell.col];	outCellFrame.bottom = outCellFrame.top + mRowHeight;		return intersectsFrame;}// ---------------------------------------------------------------------------//		¥ Fetch Local Content Frame// ---------------------------------------------------------------------------//	Get the content frame leaving room for a cell borderBooleanCIPTable::FetchLocalContentFrame(	const TableCellT	&inCell,	Rect				&outCellFrame){	Boolean	intersectsFrame = FetchLocalCellFrame( inCell, outCellFrame );	outCellFrame.bottom -= 1;	outCellFrame.right -= 1;	return intersectsFrame;}// ---------------------------------------------------------------------------//		¥ Fetch Cell Hit By// ---------------------------------------------------------------------------voidCIPTable::FetchCellHitBy(	const SPoint32	&inImagePt,	TableCellT		&outCell){//	outCell.row = (inImagePt.v - 1) / (mRowHeight+1) + 1;	outCell.row = (inImagePt.v - 1) / mRowHeight + 1;	TableIndexT	cIndex	= 0;	Int32		tWidth	= 0;	while ( (cIndex < mCols) && (inImagePt.h > tWidth) ) {		cIndex += 1;//		tWidth += mMultiColWidth[cIndex] + 1;		tWidth += mMultiColWidth[cIndex];	}	outCell.col = cIndex;}#pragma mark --- Drawing ---// ---------------------------------------------------------------------------//		¥ Hilite Cell// ---------------------------------------------------------------------------voidCIPTable::HiliteCell(	const TableCellT&	inCell){	Rect	cellFrame, rowFrame, theFrame;	TableCellT	tCell;	if (IsValidCell(inCell) &&		FetchLocalContentFrame(inCell, cellFrame)) {		if (inCell.col == 1) {			// if first column, calculate rest of row frame			// get frame of first cell in hilite range			tCell.row = inCell.row;			tCell.col = 2;			FetchLocalContentFrame(tCell, rowFrame);			// set right border to last cell in hilite range			tCell.col = mCols;			FetchLocalContentFrame(tCell, theFrame);			rowFrame.right = theFrame.right;			}				ApplyForeAndBackColors();		if (IsActive()) {			UDrawingUtils::SetHiliteModeOn();			if (EqualCell(inCell, mEditCell)) {				// Hilite edit cell with reverse				mHiliteStyle = kHiliteEdit;				ColType type, option;				GetColType(inCell.col, type, option);				if ((type != kColumnIPNum) &&					(type != kColumnNum) && (type != kColumnComment))	// skip EditFields					::InvertRect(&cellFrame);			} else {				// Hilite selected cell with outline				mHiliteStyle = kHiliteSelect;				StColorPenState::Normalize();				::PenMode(srcXor);				::FrameRect(&cellFrame);			}			// if first column, hilite rest of row			if (inCell.col == 1) {				UDrawingUtils::SetHiliteModeOn();				::InvertRect(&rowFrame);			}		} else {			// hilite for inactive			mHiliteStyle = kHiliteInactive;			InsetRect(&cellFrame, -1, -1);			if (PaneInColor (this)) {				StColorPenState::Normalize();				RGBColor		emptyColor;				emptyColor = gAGAColorArray[6];				::RGBForeColor(&emptyColor);				::FrameRect(&cellFrame);				if (inCell.col == 1) {					InsetRect(&rowFrame, -1, -1);					::FrameRect(&rowFrame);				}			}		}			}}// ---------------------------------------------------------------------------//		¥ Unhilite Cell// ---------------------------------------------------------------------------voidCIPTable::UnhiliteCell(	const TableCellT&	inCell){	Rect	cellFrame, rowFrame, theFrame;	if (IsValidCell(inCell) && FetchLocalContentFrame(inCell, cellFrame)) {		// if first column, calculate rest of row frame		if (inCell.col == 1) {			TableCellT	tCell;			// get frame of first cell in hilite range			tCell.row = inCell.row;			tCell.col = 2;			FetchLocalContentFrame(tCell, rowFrame);			// set right border to last cell in hilite range			tCell.col = mCols;			FetchLocalContentFrame(tCell, theFrame);			rowFrame.right = theFrame.right;		}				switch (mHiliteStyle) {			case kHiliteEdit:				ApplyForeAndBackColors();				UDrawingUtils::SetHiliteModeOn();				ColType type, option;				GetColType(inCell.col, type, option);				if ((type != kColumnIPNum) &&					(type != kColumnNum) && (type != kColumnComment))	// skip EditFields					::InvertRect(&cellFrame);	// Unhilite edit cell with reverse				// handle entire row if first column selected				if (inCell.col == 1) {					UDrawingUtils::SetHiliteModeOn();					::InvertRect(&rowFrame);				}				break;			case kHiliteSelect:				ApplyForeAndBackColors();				UDrawingUtils::SetHiliteModeOn();				StColorPenState::Normalize();	// Unhilite selected cell with outline				//::PenSize(2,2);				::PenMode(srcXor);				::FrameRect(&cellFrame);				// handle entire row if first column selected				if (inCell.col == 1) {					UDrawingUtils::SetHiliteModeOn();					::InvertRect(&rowFrame);				}				break;			case kHiliteInactive:				// Undo inactive hiliting				::InsetRect(&cellFrame, -1, -1);				::PenPat(&UQDGlobals::GetQDGlobals()->gray);				if (PaneInColor (this)) {					StColorState	saveColor;					RGBColor		emptyColor;					emptyColor = gAGAColorArray[6];					::RGBForeColor(&emptyColor);					::FrameRect(&cellFrame);					if (inCell.col == 1) {						InsetRect(&rowFrame, -1, -1);						::FrameRect(&rowFrame);					}				}				::PenPat(&UQDGlobals::GetQDGlobals()->black);				break;			default:				// shouldn't be Unhiliting if no hilite is in effect				Assert_(mHiliteStyle != kHiliteNone);				break;		}	// end switch		mHiliteStyle = kHiliteNone;	}}// ---------------------------------------------------------------------------//		¥ Activate Self// ---------------------------------------------------------------------------voidCIPTable::ActivateSelf(){	FocusDraw();	UnhiliteCell(mSelectedCell);	// Undo inactive hilite	HiliteCell(mSelectedCell);		// Do active hiliting}// ---------------------------------------------------------------------------//		¥ Select Cell// ---------------------------------------------------------------------------//  Handle click in cell.  If inCell.col==0, just refresh previous selectionvoidCIPTable::SelectCell(	const TableCellT	&inCell){	FocusDraw();	// inCell is the cell that was clicked	// mSelectedCell is the previously selected cell	// mEditCell == mSelectedCell indicates if we are currently editing the selected cell.	// 4 Cases	//	inCell == mSelectedCell == mEditCell	! already editing, do nothing	//	inCell == mSelectedCell != mEditCell	! already selected, but not editing, setup to edit	//  inCell != mSelectedCell == mEditCell	! a new selection, was editing, save edited data	//	inCell != mSelectedCell != mEditCell	! a new selection, wasn't editing, just move hilite		if (EqualCell(inCell, mSelectedCell) && !EqualCell(mSelectedCell, mEditCell)) {		// already selected, but not editing, setup to edit or toggle feature cell		ToggleCell();	} else if (!EqualCell(inCell, mSelectedCell) && EqualCell(mSelectedCell, mEditCell)) {		// a new selection, was editing, save edited data		// unhilite previous selection		UnhiliteCell(mSelectedCell);		// set new selection		mSelectedCell = inCell;		// save edit data and hide field		EditCell();					mEditCell.row = 0;	// indicate not editing		// hilite new selection		HiliteCell(mSelectedCell);		MenuCell();		// handle menu cell	} else if (!EqualCell(inCell, mSelectedCell) && !EqualCell(mSelectedCell, mEditCell)) {		// a new selection, wasn't editing, just move hilite		// turn off previous hilite		if (inCell.col != 0) {	// Skip to just redraw previous selection			UnhiliteCell(mSelectedCell);			// hilite new selection			mSelectedCell = inCell;		}		HiliteCell(mSelectedCell);		MenuCell();		// handle menu cell	}}// ---------------------------------------------------------------------------//		¥ Adjust View// ---------------------------------------------------------------------------//	Scroll the image to include the specified cell//		return true if the view was scrolledBooleanCIPTable::AdjustView(const TableCellT &inCell){	Boolean scrolled = false;	// get cell position (local coordinates)	Rect	cellFrame;	FetchLocalCellFrame( inCell, cellFrame );	// get the view frame in local coordinates	Rect	viewFrame;	CalcLocalFrameRect(viewFrame);	// calculate the vertical offset needed to	// include the cellFrame in the viewFrame	//	negative offest means scroll up or backward	SPoint32	scrollAmount;	scrollAmount.h = 0;	scrollAmount.v = 0;	if (cellFrame.top < viewFrame.top) {		scrollAmount.v = cellFrame.top - viewFrame.top;		scrolled = true;	} else if (cellFrame.bottom > viewFrame.bottom) {		scrollAmount.v = cellFrame.bottom - viewFrame.bottom;		scrolled = true;	}	if (scrolled == true) {		// temporarily change window background to match scroll area		// so scolling doesn't flash the window background		RGBColor		foreColor, backColor, tempColor;		//foreColor = gAGAColorArray[B];		//backColor = gAGAColorArray[2];		tempColor = gAGAColorArray[W];		((CScroller *)mSuperView)->GetForeAndBackColors(&foreColor, &backColor);		SetForeAndBackColors(&foreColor, &tempColor);				ScrollImageBy(scrollAmount.h, scrollAmount.v, true);		// Restore window colors		SetForeAndBackColors(&foreColor, &backColor);	}	return scrolled;}// ---------------------------------------------------------------------------//		¥ Refresh Cell// ---------------------------------------------------------------------------//	Cause a table cell to be redrawnvoidCIPTable::RefreshCell(	const TableCellT	&inCell){	// get cell position (local coordinates)	Rect	cellFrame;	if (FetchLocalCellFrame( inCell, cellFrame ) && IsVisible()) {		// convert to port coordinates		LocalToPortPoint(topLeft(cellFrame));		LocalToPortPoint(botRight(cellFrame));		// invalidate the cell in the grafport		InvalPortRect( &cellFrame );	}}// ---------------------------------------------------------------------------//		¥ Refresh Row// ---------------------------------------------------------------------------//	Cause a table row to be redrawnvoidCIPTable::RefreshRow(	const TableIndexT	&inRow){	TableCellT	theCell;	Rect		rowFrame, cellFrame;	theCell.row = inRow;	theCell.col = 1;	// get row frame position (local coordinates)	FetchLocalCellFrame( theCell, rowFrame );	theCell.col = mCols;	FetchLocalCellFrame( theCell, cellFrame );	rowFrame.right = cellFrame.right;	// convert to port coordinates	LocalToPortPoint(topLeft(rowFrame));	LocalToPortPoint(botRight(rowFrame));	// invalidate the cell in the grafport	InvalPortRect( &rowFrame );}// ---------------------------------------------------------------------------//		¥ Draw Cell// ---------------------------------------------------------------------------voidCIPTable::DrawCell(	const TableCellT	&inCell){	Rect	cellFrame;	if (FetchLocalContentFrame(inCell, cellFrame)) {		// draw white background		ApplyForeAndBackColors();		::EraseRect(&cellFrame);		// draw border around cell		::InsetRect(&cellFrame, -1, -1);		::PenPat(&UQDGlobals::GetQDGlobals()->gray);		if (PaneInColor (this)) {			StColorState	saveColor;			RGBColor		emptyColor;			emptyColor = gAGAColorArray[6];			::RGBForeColor(&emptyColor);			::FrameRect(&cellFrame);		} else { ::FrameRect(&cellFrame); }		::PenPat(&UQDGlobals::GetQDGlobals()->black);		if (inCell.row != mRows) {		// draw contents unless last row			TextFont(applFont);			TextSize(9);			MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);					IPNumItem tData;			DisplayItem *tDataP = (DisplayItem *) &tData;			GetCellData( inCell, &tData );			ColType type, option;			GetColType(inCell.col, type, option);						switch (type) {			case kColumnIPNum:				// display IP number cell				if ( !EqualCell(inCell, mEditCell) ) {	// ignore edit field, handled as a special case					if ((option == kOptionMenu) && ((UInt32)tData.a < kMaxRouterPorts)) {						// handle menu option for router ports						DrawString(gRouterPorts[tData.a]);					} else {						Str31 str;						IP_NumToStr( tData.a, str );						DrawString( str );					}				}				break;			case kColumnStatus:			case kColumnFeature:				// display column				if (tDataP->a[1] == 'X') {					// show cross icon (cell frame should be 16x16)					cellFrame.left += 4;					cellFrame.right = cellFrame.left + 16;					OSErr err;					if (type == kColumnStatus)						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Cross);					else						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Check);					Assert_(err == NoError);				} else if ((0 < tDataP->a[0]) && (tDataP->a[0] < 4)) {					// show tData string					MoveTo(cellFrame.left + 6, cellFrame.bottom -4);					DrawString( (ConstStr255Param)tDataP->a );				}				// tData.a[0] == 0, display empty cell				break;			case kColumnNum:				// display number cell				if ( !EqualCell(inCell, mEditCell) ) {	// ignore edit field, handled as a special case					LStr255 numStr;					numStr = tData.a;					DrawString( numStr );				}				break;			case kColumnProtocol:				// display IP protocol names				if ((option == kOptionMenu) && ((UInt32)tData.a < kMaxProtocols)) {					// handle menu option for protocols					DrawString(gProtocols[tData.a]);				}				break;			case kColumnComment:				// display comment if any				if (mCommentData != nil) {					unsigned char commentData[kCommentDataSize];					mCommentData->FetchItemAt( (inCell.row * 2)-1, commentData);					DrawString(commentData);				}				break;			default:									// ### Debugging									// Draw cell row & column number inside									// frame of cell				Str31	str;				NumToString(inCell.row, str);				DrawString(str);				DrawString("\p,");				NumToString(inCell.col, str);				DrawString(str);			}		}	}}// ---------------------------------------------------------------------------//		¥ ApplyForeAndBackColors()// ---------------------------------------------------------------------------// Override to define our own colors separate from superviewvoidCIPTable::ApplyForeAndBackColors(){RGBColor		emptyColor;	emptyColor = gAGAColorArray[B];	::RGBForeColor(&emptyColor);	emptyColor = gAGAColorArray[W];	::RGBBackColor(&emptyColor);}#pragma mark --- Editing ---// ---------------------------------------------------------------------------//		¥ ToggleCell// ---------------------------------------------------------------------------//	Toggle selected cell//		toggle between editing and not editing for cells that can be edited//		toggle between states for enable feature cells//		if last row of table, add another rowvoidCIPTable::ToggleCell(){TableCellT	theCell;	if (mSelectedCell.row == mRows) AddRow();	// last row, insert another	FocusDraw();	DisplayItem tData;	ColType type, option;	GetColType(mSelectedCell.col, type, option);	if (option != kOptionReadOnly) {				switch (type) {		case kColumnIPNum:		case kColumnNum:		case kColumnComment:			// toggle editing state			// turn off old hilite			UnhiliteCell(mSelectedCell);			// indicate editing or not			if (EqualCell(mEditCell, mSelectedCell)) {				// was editing, so switch to not editing				theCell = mSelectedCell;	// save selected cell				mSelectedCell.row = 0;				EditCell();					// update edit field				mEditCell.row = 0;			// indicate not editing				mSelectedCell = theCell;	// restore selected cell			} else {				// not editing, so switch to editing				mEditCell = mSelectedCell;				EditCell();			}			// turn on new hilite			HiliteCell(mSelectedCell);			MenuCell();					// handle popup menu if any			break;		case kColumnStatus:			// toggle status indicator			GetCellData( mSelectedCell, &tData );			// status column, toggle display <blank> "S" "Off" "X"			if (tData.a[0] == 0) LString::CopyPStr("\pS", tData.a);			else if (tData.a[1] == 'S')	LString::CopyPStr("\pOff", tData.a);			else if (tData.a[1] == 'O')	LString::CopyPStr("\pX", tData.a);			else if (tData.a[1] == 'X')	LString::CopyPStr("\pS", tData.a);			SetCellData( mSelectedCell, &tData );			RefreshCell( mSelectedCell );			BroadcastMessage( msg_CellValueChanged, &mSelectedCell );			break;		case kColumnFeature:			// toggle feature state			GetCellData( mSelectedCell, &tData );			// RIP or Def., toggle display <blank> <check>			if (tData.a[0] == 0) LString::CopyPStr("\pX", tData.a);			else {tData.a[0] = 0; tData.a[1] = 0;}			SetCellData( mSelectedCell, &tData );			RefreshCell( mSelectedCell );			BroadcastMessage( msg_CellValueChanged, &mSelectedCell );			break;		}	}}// ---------------------------------------------------------------------------//		¥ AddRow// ---------------------------------------------------------------------------//	Add a new row at the end of the table and initialize itvoidCIPTable::AddRow(){Int32		inHowMany;TableIndexT	inAfterRow;TableCellT	theCell;IPNumItem	tData;	inHowMany = 1;	inAfterRow = mRows - 1;	tData.a = 0;	tData.b = 0;	InsertRows( inHowMany, inAfterRow, &tData);	RefreshRow(mRows-1);	// refresh last two rows	RefreshRow(mRows);	// initialize new row as static route	theCell.col = 1;	theCell.row = mRows - 1;	DisplayItem	uData;	LString::CopyPStr("\pS", uData.a);	LString::CopyPStr("\pX", uData.b);		// init to 'X' so cancel will remove this row	SetCellData(theCell, &uData);}// ---------------------------------------------------------------------------//		¥ InEditCell// ---------------------------------------------------------------------------//	Return whether a cell is being editedBooleanCIPTable::InEditCell(){	Boolean flag = false;	if (EqualCell(mEditCell, mSelectedCell)) flag = true;	return flag;}// ---------------------------------------------------------------------------//		¥ EditCell// ---------------------------------------------------------------------------//	Setup and tear down edit in place field//		if (mEditCell==mSelectedCell) then setup to edit,//		otherwise save edit data and hide edit field to accomodate new selection//		Edit cell must be a valid cell.voidCIPTable::EditCell(){IPNumItem	tData;LEditField	*theEditField;	Assert_(IsValidCell(mEditCell));	// determine type of edit field	ColType type, option;	GetColType(mEditCell.col, type, option);	theEditField = nil;	if (type == kColumnIPNum) theEditField = mIPEditField;	else if (type == kColumnNum) {		theEditField = mEditField;		theEditField->ResizeFrameTo(kWidthNum-4, mRowHeight-3, false);		theEditField->SetKeyFilter((KeyFilterFunc) UKeyFilters::IntegerField);		if (option == kOptionMax15) theEditField->SetMaxChars(2);		else theEditField->SetMaxChars(5);	} else if (type == kColumnComment) {		theEditField = mEditField;		theEditField->ResizeFrameTo(kWidthComment-4, mRowHeight-3, false);		theEditField->SetKeyFilter((KeyFilterFunc) UKeyFilters::PrintingCharField);		theEditField->SetMaxChars(kCommentDataSize-1);	}		if (theEditField != nil) {		// Setup or tear down?		if (EqualCell(mSelectedCell, mEditCell)) {			// setup to edit			// get cell data and put in edit field			if (type == kColumnComment) {				unsigned char commentData[kCommentDataSize];				mCommentData->FetchItemAt( (mEditCell.row * 2)-1, commentData);				theEditField->SetDescriptor( commentData );			} else {				GetCellData( mEditCell, &tData );				theEditField->SetValue( tData.a );			}			// get cell position			Rect	cellFrame;			FetchLocalContentFrame(mEditCell, cellFrame);			// get the view frame in local coordinates			Rect	theView;			CalcLocalFrameRect(theView);			Point	theViewPos;			theViewPos.h = theView.left;			theViewPos.v = theView.top;			// offset the cell position based on the view frame			// in case the view has scrolled			::OffsetRect( &cellFrame, -theViewPos.h, -theViewPos.v );			// display the edit field at the cell position			theEditField->PlaceInSuperFrameAt(cellFrame.left+2, cellFrame.top+1, true);			theEditField->Show();			theEditField->SwitchTarget(theEditField);			theEditField->SelectAll();		} else {			// setup to no longer edit			// transfer edit field data to cell			if (type == kColumnComment) {				unsigned char commentData[kCommentDataSize];				theEditField->GetDescriptor( commentData );				mCommentData->AssignItemsAt(1, (mEditCell.row * 2)-1, commentData, commentData[0]+1);			} else {				// Check edit field in case cell value changed				GetCellData( mEditCell, &tData );				Int32 oldValue = tData.a;				tData.a = theEditField->GetValue();				if (oldValue != tData.a) {					// store new value					SetCellData( mEditCell, &tData );					// tell any listeners the cell's value has changed					BroadcastMessage( msg_CellValueChanged, &mEditCell );				}			}			theEditField->Hide();		}	}}// ---------------------------------------------------------------------------//		¥ MenuCell// ---------------------------------------------------------------------------//	Setup or hide Popup Menu cellvoidCIPTable::MenuCell(){	if (mPopupMenu != nil) {		ColType type, option;		GetColType(mSelectedCell.col, type, option);		if ( (option == kOptionMenu) &&			 (!InEditCell()) && (mSelectedCell.row < mRows) ) {			// initialize popup menu selection			IPNumItem tData;			GetCellData(mSelectedCell, &tData);			if (tData.a < kMaxRouterPorts) mPopupMenu->SetValue(tData.a + 1);			else mPopupMenu->SetValue(0);	// default to "< Gateway >"			// get cell position			Rect	cellFrame;			FetchLocalContentFrame(mSelectedCell, cellFrame);			// get the view frame in local coordinates			Rect	theView;			CalcLocalFrameRect(theView);			Point	theViewPos;			theViewPos.h = theView.left;			theViewPos.v = theView.top;			// offset the cell position based on the view frame			// in case the view has scrolled			::OffsetRect( &cellFrame, -theViewPos.h, -theViewPos.v );			// display the Popup Menu at the cell position			mPopupMenu->PlaceInSuperFrameAt(cellFrame.right-15, cellFrame.top+1, true);			mPopupMenu->Show();		} else mPopupMenu->Hide();	}}// ---------------------------------------------------------------------------//		¥ EditOK// ---------------------------------------------------------------------------//	User has pressed OK, save any new data enteredvoidCIPTable::EditOK(){	TableCellT	tCell;	DisplayItem	tData;	IPNumItem	uData;	unsigned char commentData[kCommentDataSize];		// save data from edit field and hide	if (IsValidCell(mEditCell)) {		// determine type of edit field		ColType type, option;		GetColType(mEditCell.col, type, option);		LEditField *theEditField = nil;		if (type == kColumnIPNum) theEditField = mIPEditField;		else if (type == kColumnNum) theEditField = mEditField;		else if (type == kColumnComment) theEditField = mEditField;		// handle edit field if valid		if (theEditField != nil) {			if (type == kColumnComment) {				theEditField->GetDescriptor( commentData );				mCommentData->AssignItemsAt(1, (mEditCell.row * 2)-1, commentData, commentData[0]+1);			} else {				// test if value has changed				GetCellData( mEditCell, &uData );				Int32 oldValue = uData.a;				uData.a = theEditField->GetValue();				if (oldValue != uData.a) {					// save new value					SetCellData( mEditCell, &uData );					// tell any listeners the cell's value has changed					BroadcastMessage( msg_CellValueChanged, &mEditCell );				}			}			theEditField->Hide();		}		mEditCell.row = 0;	// indicate not Editing	}	if (mPopupMenu != nil) mPopupMenu->Hide();		// remove any rows marked delete	tCell.row = 1;	tCell.col = 1;	while (tCell.row < mRows) {		GetCellData( tCell, &tData );		if (tData.a[1] == 'X')			RemoveRows( 1, tCell.row );		else			tCell.row += 1;	}	// make sure the selection is still valid	if (mSelectedCell.row > mRows) mSelectedCell.row = mRows - 1;	// refresh the view to accomodate moved rows	if (mSuperView != nil) mSuperView->Refresh();	// save current cell values for reference	for (tCell.row=1; tCell.row<=mRows; tCell.row++) {		for (tCell.col=1; tCell.col<=mCols; tCell.col++) {			GetCellData( tCell, &uData );			uData.b = uData.a;			SetCellData( tCell, &uData );		}		if (mCommentData != nil) {			mCommentData->FetchItemAt( (tCell.row * 2)-1, commentData);			mCommentData->AssignItemsAt(1, (tCell.row * 2), commentData, commentData[0]+1);		}	}}// ---------------------------------------------------------------------------//		¥ EditCancel// ---------------------------------------------------------------------------//	User has pressed Cancel, restore previous table datavoidCIPTable::EditCancel(){	TableCellT	tCell;	IPNumItem	tData;	DisplayItem	uData;	unsigned char commentData[kCommentDataSize];		// hide edit fields	if (mIPEditField != nil) mIPEditField->Hide();	if (mEditField != nil) mEditField->Hide();	mEditCell.row = 0;	// indicate not Editing	if (mPopupMenu != nil) mPopupMenu->Hide();		// restore previous cell values for display	for (tCell.row=1; tCell.row<=mRows; tCell.row++) {		for (tCell.col=1; tCell.col<=mCols; tCell.col++) {			GetCellData( tCell, &tData );			tData.a = tData.b;			SetCellData( tCell, &tData );		}		if (mCommentData != nil) {			mCommentData->FetchItemAt( (tCell.row * 2), commentData);			mCommentData->AssignItemsAt(1, (tCell.row * 2)-1, commentData, commentData[0]+1);		}	}		// remove any rows marked delete	tCell.row = 1;	tCell.col = 1;	while (tCell.row < mRows) {		GetCellData( tCell, &uData );		if (uData.a[1] == 'X')			RemoveRows( 1, tCell.row );		else			tCell.row += 1;	}	// make sure the selection is still valid	if (mSelectedCell.row > mRows) mSelectedCell.row = mRows - 1;	// refresh the view to accomodate moved rows	if (mSuperView != nil) mSuperView->Refresh();}#pragma mark --- Drag And Drop ---// ---------------------------------------------------------------------------------//		¥ Click// ---------------------------------------------------------------------------------voidCIPTable::Click(	SMouseDownEvent	&inMouseDown ){	if ( inMouseDown.delaySelect && DragAndDropIsPresent() ) {		// In order to support dragging from an inactive window,		// we must explicitly test for delaySelect and the		// presence of Drag and Drop.		// Convert to a local point.		PortToLocalPoint( inMouseDown.whereLocal );				// Execute click attachments.		if ( ExecuteAttachments( msg_Click, &inMouseDown ) ) {					// Handle the actual click event.			ClickSelf( inMouseDown );		}		} else {		// Call inherited for default behavior.			LTable::Click( inMouseDown );		}}// ---------------------------------------------------------------------------------//		¥ ClickCell// ---------------------------------------------------------------------------------voidCIPTable::ClickCell(	const TableCellT		&inCell,	const SMouseDownEvent	&inMouseDown ){	// Call inherited.	LTable::ClickCell( inCell, inMouseDown );	// this selects the cell	// Test for dragable cell	ColType type, option;	type = kColumnNone;	if (IsValidCell(inCell)) GetColType(inCell.col, type, option);	if ( DragAndDropIsPresent() &&		(type == kColumnIPNum) &&		::WaitMouseMoved( inMouseDown.macEvent.where ) ) {		// Focus.		FocusDropArea();				// Get the cell frame.		Rect	theCellFrame;		FetchLocalCellFrame( inCell, theCellFrame );		// Get the cell data.		Str255		theString;		IPNumItem	tData;		GetCellData(inCell, &tData);		// convert IP Num Data to string		IP_NumToStr(tData.a, theString);				// Create the drag task.		LDragTask	theDragTask( inMouseDown.macEvent, theCellFrame,						1, 'TEXT', &theString[1], StrLength(theString), 0 );				// Invalidate LView's focus cache.		// The port may have changed during the drag.		LView::OutOfFocus( nil );	}}// ---------------------------------------------------------------------------------//		¥ ItemIsAcceptable// ---------------------------------------------------------------------------------BooleanCIPTable::ItemIsAcceptable(	DragReference	inDragRef,	ItemReference	inItemRef ){	Boolean	isAcceptable;	FlavorFlags	theFlags;	// Make sure the table is enabled and	// there's text in the drag data.	isAcceptable = IsEnabled() &&		(::GetFlavorFlags( inDragRef, inItemRef, 'TEXT', &theFlags ) == noErr);	return isAcceptable;}// ---------------------------------------------------------------------------------//		¥ EnterDropArea// ---------------------------------------------------------------------------------voidCIPTable::EnterDropArea(	DragReference	inDragRef,	Boolean			inDragHasLeftSender ){#pragma unused (inDragRef, inDragHasLeftSender)	// Invalidate the last drop cell.	mDropCell.row = 0;	// Switch to not editing	if (InEditCell()) ToggleCell();}// ---------------------------------------------------------------------------------//		¥ LeaveDropArea// ---------------------------------------------------------------------------------voidCIPTable::LeaveDropArea(	DragReference	inDragRef ){	FocusDropArea();	UnhiliteDropArea(inDragRef);	// Invalidate the last drop cell.	mDropCell.row = 0;}// ---------------------------------------------------------------------------------//		¥ InsideDropArea// ---------------------------------------------------------------------------------voidCIPTable::InsideDropArea(	DragReference	inDragRef ){	// Call inherited.	LDragAndDrop::InsideDropArea( inDragRef );	// Focus.	if ( FocusDraw() ) {		// Get the mouse location and		// convert to image coordinates.		Point		thePoint;		SPoint32	theImagePt;		::GetDragMouse( inDragRef, &thePoint, nil );		GlobalToPortPoint( thePoint );		PortToLocalPoint( thePoint );		LocalToImagePoint( thePoint, theImagePt );				// Determine what cell it's in		TableCellT	theCell;		FetchCellHitBy( theImagePt, theCell );				// Test if drop cell has changed		if (!EqualCell(theCell, mDropCell)) {			mDropCell = theCell;			// Yes, hilite new drop target if appropriate			ColType type, option;			type = kColumnNone;			if (IsValidCell( mDropCell)) GetColType(mDropCell.col, type, option);			if ((type == kColumnIPNum) && (option != kOptionReadOnly)) {				HiliteDropArea(inDragRef);			} else {				UnhiliteDropArea(inDragRef);			}		}	}}// ---------------------------------------------------------------------------//		¥ FocusDropArea// ---------------------------------------------------------------------------//	Set up local coordinate system and clipping region for a DropAreavoidCIPTable::FocusDropArea(){	FocusDraw();}// ---------------------------------------------------------------------------------//		¥ HiliteDropArea// ---------------------------------------------------------------------------------voidCIPTable::HiliteDropArea(	DragReference	inDragRef ){	// Get the frame rect.	if (IsValidCell( mDropCell)) {		Rect	theRect;		FetchLocalCellFrame( mDropCell, theRect);		// Show the drag hilite in the drop area.		StColorState::Normalize();		RgnHandle	theRgnH = ::NewRgn();		::RectRgn( theRgnH, &theRect );		::ShowDragHilite( inDragRef, theRgnH, true );		::DisposeRgn( theRgnH );		mIsHilited = true;	}}// ---------------------------------------------------------------------------//		¥ UnhiliteDropArea// ---------------------------------------------------------------------------//	Unhilite a DropArea when a drag leaves the areavoidCIPTable::UnhiliteDropArea(	DragReference	inDragRef){	if (mIsHilited == true) {		::HideDragHilite(inDragRef);		mIsHilited = false;	}}// ---------------------------------------------------------------------------------//		¥ ReceiveDragItem// ---------------------------------------------------------------------------------voidCIPTable::ReceiveDragItem(	DragReference	inDragRef,	DragAttributes	inDragAttrs,	ItemReference	inItemRef,	Rect			&inItemBounds ){#pragma unused( inDragAttrs, inItemBounds )	FocusDropArea();	UnhiliteDropArea(inDragRef);	// unhilite drop area		FlavorFlags	theFlags;	ThrowIfOSErr_( ::GetFlavorFlags( inDragRef, 		inItemRef, 'TEXT', &theFlags ) );	// Get the data.	Size	theDataSize = 255;	Str255	theString;	ThrowIfOSErr_( ::GetFlavorData( inDragRef, inItemRef,		'TEXT', &theString[1], &theDataSize, 0 ) );		// Get the data size and set the string length.	ThrowIfOSErr_( ::GetFlavorDataSize( inDragRef,		inItemRef, 'TEXT', &theDataSize ) );	theString[0] = theDataSize;	// "copy" a field into the table (no "move")	if (IsValidCell(mDropCell)) {		// Check if we can drop into this cell		ColType type, option;		GetColType(mDropCell.col, type, option);		if ((type == kColumnIPNum) && (option != kOptionReadOnly)) {			// Yes, prepare to transfer data			if (mDropCell.row == mRows) AddRow();	// last row, insert another			FocusDropArea();	// update drawing area for new pane size			// trim the string to remove non-digits from the start and end			UInt8	startPos, endPos;			for (startPos = 1; startPos <= theDataSize; startPos++) {				if ( (theString[startPos] >= '0') && (theString[startPos] <= '9') ) break;			}			for (endPos = theDataSize; endPos >= startPos; endPos--) {				if ( (theString[endPos] >= '0') && (theString[endPos] <= '9') ) break;			}			startPos -= 1;			theString[startPos] = endPos - startPos;			// convert the string to an IP address to weed out bad strings			Int32 address;			address = IP_StrToInt( &theString[startPos] );			// update table cell			IPNumItem	tData;			GetCellData(mDropCell, &tData);			tData.a = address;			SetCellData(mDropCell, &tData);			SelectCell(mDropCell);			// select drop cell			RefreshCell(mDropCell);		}			}		// tell the window we dropped in a new value	//BroadcastMessage( msg_CellValueChanged, &mDropCell );}