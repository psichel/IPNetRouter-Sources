// =================================================================================//	CDHCPDynamicCfgTable.cp				©1999 Sustainable Softworks All rights reserved.// =================================================================================//	Table object to display DHCP Status information#include "CDHCPDynamicCfgTable.h"#include "CWindow.h"#include "LEditField.h"#include <PP_Messages.h>#include "AGAColors.h"#include "IPSupport.h"#include "MacSupport.h"//#include "CIPNumberEditField.h"#include <LString.h>// Globalsextern CDHCPData* gDHCPData;// ---------------------------------------------------------------------------------//		¥ CDHCPDynamicCfgTable(LStream*)// ---------------------------------------------------------------------------------CDHCPDynamicCfgTable::CDHCPDynamicCfgTable(	LStream	*inStream )		: CEditTable( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CDHCPDynamicCfgTable// ---------------------------------------------------------------------------------CDHCPDynamicCfgTable::~CDHCPDynamicCfgTable(){}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------//	Finish creating the DHCP table.voidCDHCPDynamicCfgTable::FinishCreateSelf(){	// set column types	SetColType(kColTypeIPAddr, 1, 1);		// network interface	SetColType(kColTypeIPAddr, 2, 2);		// start IP addr	SetColType(kColTypeIPAddr, 3, 3);		// end IP addr	//SetColWidth(120, 1, 3);	// get edit in place field	mEditField = (LEditField*)FindPaneByID( kTableEditField );}// ---------------------------------------------------------------------------------//		¥ GetDHCPDynamicCfgEntry// ---------------------------------------------------------------------------------//	Get DHCPDynamicCfg Entry from TableBooleanCDHCPDynamicCfgTable::GetDHCPDynamicCfgEntry(TableIndexT inRow, DHCPDynamicCfgEntry_t* outEntry){	TableCellT		theCell;	TableItemW	tData;	Boolean			result = true;		do {		// check for valid row entry (has an IP address)		theCell.row = inRow;		theCell.col = kColDHCPDynamicCfgStartIPAddr;		if (!IsValidCell(theCell)) {			result = false;			break;		}		GetCellData(theCell, &tData);		if (tData.hi == 0) {			result = false;			break;		}		// initialize output buffer		bzero((UInt8*)outEntry, sizeof(DHCPDynamicCfgEntry_t));		// get entry			// Network Interface		theCell.col = kColDHCPDynamicCfgInterfaceAddr;		GetCellData(theCell, &tData);		outEntry->interfaceAddr = tData.hi;			// Start IP Addr		theCell.col = kColDHCPDynamicCfgStartIPAddr;		GetCellData(theCell, &tData);		outEntry->startLeaseAddr = tData.hi;			// End IP Addr		theCell.col = kColDHCPDynamicCfgEndIPAddr;		GetCellData(theCell, &tData);		outEntry->endLeaseAddr = tData.hi;		outEntry->isDone = true;				// is done	} while (false);		return result;}// ---------------------------------------------------------------------------------//		¥ SetDHCPDynamicCfgEntry// ---------------------------------------------------------------------------------//	Set DHCPDynamicCfg Entry in Table//	Refresh if entry was changedvoidCDHCPDynamicCfgTable::SetDHCPDynamicCfgEntry(TableIndexT inRow, DHCPDynamicCfgEntry_t* inEntry){	TableCellT		theCell;	TableItemW		tData, uData;	Boolean			result = false;	do {		// check for valid row entry		if (inRow > kMaxDHCPDynamicCfgTableRows) {			result = false;			break;		}		// insert rows if needed		if (inRow > mRows) {			tData.hi = 0;			tData.lo = 0;			InsertRows(inRow-mRows, mRows, &tData);	// how many, after row, *data		}		// set entry		theCell.row = inRow;			// interfaceAddr		theCell.col = kColDHCPDynamicCfgInterfaceAddr;		tData.hi = inEntry->interfaceAddr;		tData.lo = 0;		GetCellData(theCell, &uData);		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}			// leaseAddr		theCell.col = kColDHCPDynamicCfgStartIPAddr;		tData.hi = inEntry->startLeaseAddr;		tData.lo = 0;		GetCellData(theCell, &uData);		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}			// leaseAddr		theCell.col = kColDHCPDynamicCfgEndIPAddr;		tData.hi = inEntry->endLeaseAddr;		tData.lo = 0;		GetCellData(theCell, &uData);		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}	} while (false);	if (result) RefreshRow(inRow);}// ---------------------------------------------------------------------------------//		¥ UpdateTable// ---------------------------------------------------------------------------------//	Update DHCP Status Table from data objectvoidCDHCPDynamicCfgTable::UpdateTable(){	ArrayIndexT			num;	ArrayIndexT			index;	ArrayIndexT			last;	DHCPDynamicCfgEntry_t	entry;		num = gDHCPData->GetDataCountDHCPDynamicCfg();	last = FindLastRow();	if (last > num) num = last;	for (index=1; index<=num; index++) {		if (gDHCPData->GetDataDHCPDynamicCfgArray(index, &entry)) {			SetDHCPDynamicCfgEntry(index, &entry);		} else {			ClearRow(index);		}	}	// inherit behavior	CEditTable::UpdateTable();}// ---------------------------------------------------------------------------------//		¥ UpdateData// ---------------------------------------------------------------------------------//	Update data object from TablevoidCDHCPDynamicCfgTable::UpdateData(){	ArrayIndexT			num;	ArrayIndexT			index;	ArrayIndexT			skip;	DHCPDynamicCfgEntry_t	entry;	// inherit behavior	CEditTable::UpdateData();		//num = gDHCPData->GetDataCountDHCPDynamicCfg();	num = FindLastRow();	skip = 0;	for (index=1; index<=num; index++) {		if (GetDHCPDynamicCfgEntry(index, &entry)) {			gDHCPData->SetDataDHCPDynamicCfgArray(index, &entry);		} else skip += 1;	}	gDHCPData->SetDataCountDHCPDynamicCfg(num-skip);		// restore target	CEditTable::ShowSelf();}// ---------------------------------------------------------------------------//		¥ Draw Cell// ---------------------------------------------------------------------------voidCDHCPDynamicCfgTable::DrawCell(	const TableCellT	&inCell){	Rect		cellFrame;	wide		tData;	OSErr		err = 0;	if (FetchLocalContentFrame(inCell, cellFrame)) {		// draw white background		::PenNormal();		ApplyForeAndBackColors();		::EraseRect(&cellFrame);		// draw border around cell		::InsetRect(&cellFrame, -1, -1);		::PenPat(&UQDGlobals::GetQDGlobals()->gray);		if (PaneInColor (this)) {			StColorState	saveColor;			RGBColor		emptyColor;			emptyColor = gAGAColorArray[6];			::RGBForeColor(&emptyColor);			::FrameRect(&cellFrame);		} else { ::FrameRect(&cellFrame); }		::PenPat(&UQDGlobals::GetQDGlobals()->black);				// draw contents		::TextFont(applFont);		::TextFace(0);	// normal		::TextSize(9);		// Get cell data		GetCellData( inCell, &tData );		// Handle our unique columns				// inherit behavior for common data types		CConfigureTable::DrawCell(inCell);	}}