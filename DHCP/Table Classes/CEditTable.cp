// =================================================================================//	CEditTable.cp				©1999 Sustainable Softworks All rights reserved.// =================================================================================//	Table object that supports edit in place#include "CEditTable.h"#include "CWindow.h"#include <PP_Messages.h>#include "AGAColors.h"#include "IPSupport.h"#include "MacSupport.h"#include "UIPNumKeyFilters.h"//#include "CIPNumberEditField.h"#include <LString.h>// ---------------------------------------------------------------------------------//		¥ CEditTable(LStream*)// ---------------------------------------------------------------------------------CEditTable::CEditTable(	LStream	*inStream )		: CConfigureTable( inStream ){	// mark edit field as undefined	mEditField = nil;	mEditCell.row = 0;	// indicate not editing (Edit != Selected != any valid cell)	mEditCell.col = 1;	mSelectedCell.row = 1;	mSelectedCell.col = 0;	mHiliteStyle = kHiliteNone;}// ---------------------------------------------------------------------------------//		¥ ~CEditTable// ---------------------------------------------------------------------------------CEditTable::~CEditTable(){}#pragma mark --- Drawing ---// ---------------------------------------------------------------------------//		¥ Hilite Cell// ---------------------------------------------------------------------------voidCEditTable::HiliteCell(	const TableCellT&	inCell){	Rect	cellFrame, rowFrame;	if (IsValidCell(inCell) &&		FetchLocalContentFrame(inCell, cellFrame)) {				ApplyForeAndBackColors();		if (IsActive()) {			UDrawingUtils::SetHiliteModeOn();			if (EqualCell(inCell, mEditCell)) {				// Hilite edit cell with reverse				mHiliteStyle = kHiliteEdit;				UInt8 type;				type = GetColType(inCell.col);				if ((type != kColTypeIPAddr) &&					(type != kColTypeHWAddr) &&					(type != kColTypeNumber))	// skip EditFields					::InvertRect(&cellFrame);			} else {				// Hilite selected cell with outline				mHiliteStyle = kHiliteSelect;				StColorPenState::Normalize();				::PenMode(srcXor);				::FrameRect(&cellFrame);			}		} else {			// hilite for inactive			mHiliteStyle = kHiliteInactive;			InsetRect(&cellFrame, -1, -1);			if (PaneInColor (this)) {				StColorPenState::Normalize();				RGBColor		emptyColor;				emptyColor = gAGAColorArray[6];				::RGBForeColor(&emptyColor);				::FrameRect(&cellFrame);				if (inCell.col == 1) {					InsetRect(&rowFrame, -1, -1);					::FrameRect(&rowFrame);				}			}		}			}}// ---------------------------------------------------------------------------//		¥ Unhilite Cell// ---------------------------------------------------------------------------voidCEditTable::UnhiliteCell(	const TableCellT&	inCell){	Rect	cellFrame, rowFrame;//	Rect	theFrame;	if (IsValidCell(inCell) && FetchLocalContentFrame(inCell, cellFrame)) {		// if first column, calculate rest of row frame//		if (inCell.col == 1) {//			TableCellT	tCell;//			// get frame of first cell in hilite range//			tCell.row = inCell.row;//			tCell.col = 2;//			FetchLocalContentFrame(tCell, rowFrame);//			// set right border to last cell in hilite range//			tCell.col = mCols;//			FetchLocalContentFrame(tCell, theFrame);//			rowFrame.right = theFrame.right;//		}				switch (mHiliteStyle) {			case kHiliteEdit:				ApplyForeAndBackColors();				UDrawingUtils::SetHiliteModeOn();				UInt8 type;				type = GetColType(inCell.col);				if ((type != kColTypeIPAddr) &&					(type != kColTypeHWAddr) &&					(type != kColTypeNumber))	// skip EditFields					::InvertRect(&cellFrame);	// Unhilite edit cell with reverse				// handle entire row if first column selected//				if (inCell.col == 1) {//					UDrawingUtils::SetHiliteModeOn();//					::InvertRect(&rowFrame);//				}				break;			case kHiliteSelect:				ApplyForeAndBackColors();				UDrawingUtils::SetHiliteModeOn();				StColorPenState::Normalize();	// Unhilite selected cell with outline				//::PenSize(2,2);				::PenMode(srcXor);				::FrameRect(&cellFrame);				// handle entire row if first column selected				if (inCell.col == 1) {					UDrawingUtils::SetHiliteModeOn();					::InvertRect(&rowFrame);				}				break;			case kHiliteInactive:				// Undo inactive hiliting				::InsetRect(&cellFrame, -1, -1);				::PenPat(&UQDGlobals::GetQDGlobals()->gray);				if (PaneInColor (this)) {					StColorState	saveColor;					RGBColor		emptyColor;					emptyColor = gAGAColorArray[6];					::RGBForeColor(&emptyColor);					::FrameRect(&cellFrame);					if (inCell.col == 1) {						InsetRect(&rowFrame, -1, -1);						::FrameRect(&rowFrame);					}				}				::PenPat(&UQDGlobals::GetQDGlobals()->black);				break;			default:				// shouldn't be Unhiliting if no hilite is in effect				Assert_(mHiliteStyle != kHiliteNone);				break;		}	// end switch		mHiliteStyle = kHiliteNone;	}}// ---------------------------------------------------------------------------//		¥ Show Self// ---------------------------------------------------------------------------//  View has just been made visiblevoidCEditTable::ShowSelf(){	// if editing, set corresponding target	if ( InEditCell() ) {		mEditField->SwitchTarget(mEditField);		HiliteCell(mSelectedCell);	}}#pragma mark --- Editing ---// ---------------------------------------------------------------------------//		¥ Click Cell// ---------------------------------------------------------------------------//  Handle click in cell.voidCEditTable::ClickCell(	const TableCellT		&inCell,	const SMouseDownEvent&	inMouseDown){	FocusDraw();	// inCell is the cell that was clicked	// mSelectedCell is the previously selected cell	// 2 Cases	//	inCell == mSelectedCell == mEditCell	! already editing, do nothing	//  inCell != mSelectedCell == mEditCell	! a new selection, save previous edit data	//											  and setup to edit new selection	if (IsValidCell(inCell)) {		// handle click in valid cell		if (EqualCell(inCell, mSelectedCell)) {			// if not already editing			if ( !InEditCell() ) {				mEditCell = mSelectedCell;				EditCell(true);				HiliteCell(mSelectedCell);		// turn on new hilite			}		} else {			// a new selection					if ( InEditCell() ) { 				// save edited data				EditCell(false);				// unhilite previous selection				UnhiliteCell(mSelectedCell);			}			// set new selection			mSelectedCell = inCell;			mEditCell = mSelectedCell;			// edit new cell			EditCell(true);						// hilite new selection			HiliteCell(mSelectedCell);		}	}	else {		// not a valid cell, turn off editing		if (IsValidCell(mSelectedCell)) {			// save edited data			EditCell(false);			// unhilite previous selection			UnhiliteCell(mSelectedCell);			SwitchTarget(this);		}	}}// ---------------------------------------------------------------------------//		¥ HandleKeyPress// ---------------------------------------------------------------------------//	Return true if the Window handles the keystrokeBooleanCEditTable::HandleKeyPress(	const EventRecord&	inKeyEvent){	Boolean		keyHandled = true;	SInt16		theKey = inKeyEvent.message & charCodeMask;	TableCellT	theCell;	SMouseDownEvent	theMouseDown;	switch (theKey) {		case char_Enter:			theCell = mSelectedCell;			ClickCell(theCell, theMouseDown);			break;		case char_Return:			GetSelectedCell(theCell);			if (inKeyEvent.modifiers & shiftKey) {				// shift return				if (theCell.row > 1) theCell.row -= 1;				if (IsValidCell(theCell)) {					ClickCell(theCell, theMouseDown);				}			} else {				// return				theCell.row += 1;				if (IsValidCell(theCell)) {					ClickCell(theCell, theMouseDown);				}						}						break;			case char_LeftArrow:			GetSelectedCell(theCell);			theCell.col -= 1;			if (IsValidCell(theCell)) {				ClickCell(theCell, theMouseDown);			}			break;		case char_RightArrow:			GetSelectedCell(theCell);			theCell.col += 1;			if (IsValidCell(theCell)) {				ClickCell(theCell, theMouseDown);			}							break;			case char_Tab:			GetSelectedCell(theCell);			if (inKeyEvent.modifiers & shiftKey) {				// backtab				if (IsValidCell(theCell)) {					if (theCell.col > 1) {						theCell.col -= 1;						ClickCell(theCell, theMouseDown);					} else if (theCell.row > 1) {						theCell.row -= 1;						theCell.col = mCols;						ClickCell(theCell, theMouseDown);					}				}			} else {				// forward tab				if (IsValidCell(theCell)) {					if (theCell.col < mCols) {						theCell.col += 1;						ClickCell(theCell, theMouseDown);					} else if (theCell.row < mRows) {						theCell.row += 1;						theCell.col = 1;						ClickCell(theCell, theMouseDown);					}				}							}			break;		default:			keyHandled = CConfigureTable::HandleKeyPress(inKeyEvent);			break;	}	return keyHandled;}// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------voidCEditTable::ListenToMessage(	MessageT	inEventCode,	void		*ioParam ){	TableIndexT index, lastRow;	wide tData;	tData.hi = 0;	tData.lo = 0;	switch ( inEventCode ) {					case kTableInsertButton:			if (InEditCell()) EditCell(false);	// turn off edit						// inHowMany, inAfterRow, *inCellData			InsertRows(1, mSelectedCell.row-1, &tData);			lastRow = FindLastRow();			for (index=mSelectedCell.row; index<=lastRow; index++) {				RefreshRow(index);			}			if (InEditCell()) EditCell(true);	// turn on edit			break;					case kTableDeleteButton:			if (InEditCell()) EditCell(false);	// turn off edit						// inHowMany, inFromRow			lastRow = FindLastRow();			RemoveRows(1, mSelectedCell.row);			for (index=mSelectedCell.row; index<=lastRow; index++) {				RefreshRow(index);			}			if (InEditCell()) EditCell(true);	// turn on edit			break;					default:			//gLogAction->LogText("\p\rCEditTable unknown async message: ", inEventCode);			break;	}}// ---------------------------------------------------------------------------//		¥ FindLastRow// ---------------------------------------------------------------------------// Find last active row in tableTableIndexTCEditTable::FindLastRow(){	TableCellT	theCell;	wide		tData;		theCell.col = 1;	for (theCell.row=mRows; theCell.row>0; theCell.row--) {		GetCellData(theCell, &tData);		if ((tData.hi != 0) || (tData.lo != 0)) break;	}	return theCell.row;}// ---------------------------------------------------------------------------//		¥ AddRow// ---------------------------------------------------------------------------//	Add a new row at the end of the table and initialize itvoidCEditTable::AddRow(){SInt32		inHowMany;TableIndexT	inAfterRow;wide		tData;	inHowMany = 1;	inAfterRow = mRows - 1;	tData.hi = 0;	tData.lo = 0;	InsertRows( inHowMany, inAfterRow, &tData);	RefreshRow(mRows-1);	// refresh last two rows	RefreshRow(mRows);}// ---------------------------------------------------------------------------//		¥ InEditCell// ---------------------------------------------------------------------------//	Return whether a cell is being editedBooleanCEditTable::InEditCell(){	Boolean flag = false;	if (EqualCell(mEditCell, mSelectedCell)) flag = true;	return flag;}// ---------------------------------------------------------------------------------//		¥ UpdateTable// ---------------------------------------------------------------------------------//	Supports Update Table from data objectvoidCEditTable::UpdateTable(){	// if editing, update edit field	if (InEditCell()) {		EditCell(true);	}}// ---------------------------------------------------------------------------------//		¥ UpdateData// ---------------------------------------------------------------------------------//	Supports update data object from tablevoidCEditTable::UpdateData(){	if (InEditCell()) {		EditCell(false);		EditCell(true);	}}// ---------------------------------------------------------------------------//		¥ EditCell// ---------------------------------------------------------------------------//	Setup and tear down edit in place field//		if (inSetup) then setup to edit,//		otherwise save edit data and hide edit field to accomodate new selection//		Edit cell must be a valid cell.voidCEditTable::EditCell(Boolean inSetup){	wide	tData;	Str255	str;	Assert_(IsValidCell(mEditCell));	if (mEditField != nil) {		// adjust size of field to fit table cell		mEditField->ResizeFrameTo(GetColWidth(mEditCell.col)-4, mRowHeight-3, false);		// determine type of edit field to associate properties		UInt8 type;		type = GetColType(mEditCell.col);		switch (type) {			//case kColTypeNone;			//case kColTypeMark;			//case kColTypeSeconds;			//case kColTypeTime;			case kColTypeIPAddr:				if (inSetup) {					mEditField->SetKeyFilter((TEKeyFilterFunc) UIPNumKeyFilters::IPNumField);					mEditField->SetMaxChars(kMaxCharsIPAddr);					GetCellData( mEditCell, &tData );					IP_NumToStr(tData.hi, str);					mEditField->SetDescriptor( str );								} else {					// Check edit field in case cell value changed					GetCellData( mEditCell, &tData );					SInt32 oldValue = tData.hi;					mEditField->GetDescriptor(str);					tData.hi = IP_StrToInt(str);					if (oldValue != tData.hi) {						// store new value						SetCellData( mEditCell, &tData );						// tell any listeners the cell's value has changed					}												}				break;			case kColTypeHWAddr:				if (inSetup) {					mEditField->SetKeyFilter((TEKeyFilterFunc) UKeyFilters::PrintingCharField);					mEditField->SetMaxChars(kMaxCharsHWAddr);					GetCellData( mEditCell, &tData );					HW_NumToHexStr((MACAddr_t*)&tData, str);					mEditField->SetDescriptor( str );								} else {					// Check edit field in case cell value changed					MACAddr_t oldValue;					GetCellData( mEditCell, &tData );					oldValue.first4 = tData.hi;					oldValue.last2 = tData.lo>>16;					mEditField->GetDescriptor(str);					HW_StrToInt(str, (MACAddr_t*)&tData);					if ((oldValue.first4 != tData.hi) || (oldValue.last2 != tData.lo>>16)) {						// store new value						SetCellData( mEditCell, &tData );						// tell any listeners the cell's value has changed					}												}				break;			case kColTypeComment1:			case kColTypeComment2:			case kColTypeComment3:				UInt8 commentID;				commentID = type - kColTypeComment1 + 1;				if (inSetup) {					mEditField->SetKeyFilter((TEKeyFilterFunc) UKeyFilters::PrintingCharField);					mEditField->SetMaxChars(kMaxCharsComment);					GetCommentData(mEditCell.row, commentID, str);					mEditField->SetDescriptor( str );				} else {					// transfer edit field data to cell					mEditField->GetDescriptor( str );					SetCommentData(mEditCell.row, commentID, str);					if (str[0]) tData.hi = kCommentFlag;					else tData.hi = 0;					SetCellData( mEditCell, &tData );				}				break;			default:				break;				}		// Setup or tear down?		if (inSetup) {			// get cell position			Rect	cellFrame;			FetchLocalContentFrame(mEditCell, cellFrame);			// get the view frame in local coordinates			Rect	theView;			CalcLocalFrameRect(theView);			Point	theViewPos;			theViewPos.h = theView.left;			theViewPos.v = theView.top;			// offset the cell position based on the view frame			// in case the view has scrolled			::OffsetRect( &cellFrame, -theViewPos.h, -theViewPos.v );			// display the edit field at the cell position			mEditField->PlaceInSuperFrameAt(cellFrame.left+2, cellFrame.top+1, true);			mEditField->Show();			mEditField->Enable();	// *			mEditField->SwitchTarget(mEditField);			mEditField->SelectAll();		} else {			// setup to no longer edit			mEditField->Hide();			mEditField->Disable();	// *		}	}}