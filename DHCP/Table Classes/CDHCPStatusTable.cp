// =================================================================================//	CDHCPStatusTable.cp				©1999 Sustainable Softworks All rights reserved.// =================================================================================//	Table object to display DHCP Status information#include "CDHCPStatusTable.h"#include "CEditTable.h"#include "CWindow.h"#include <PP_Messages.h>#include "AGAColors.h"#include "IPSupport.h"#include "MacSupport.h"//#include "CIPNumberEditField.h"#include <LString.h>// Globalsextern CDHCPData* gDHCPData;// ---------------------------------------------------------------------------------//		¥ CDHCPStatusTable(LStream*)// ---------------------------------------------------------------------------------CDHCPStatusTable::CDHCPStatusTable(	LStream	*inStream )		: CConfigureTable( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CDHCPStatusTable// ---------------------------------------------------------------------------------CDHCPStatusTable::~CDHCPStatusTable(){}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------//	Finish creating the DHCP table.voidCDHCPStatusTable::FinishCreateSelf(){	// set column types	SetColType(kColTypeIPAddr, 1, 1);		// lease address	SetColType(kColTypeState, 2, 2);		// lease state	SetColType(kColTypeTime, 3, 3);			// last update	SetColType(kColTypeTime, 4, 4);			// expire time	SetColType(kColTypeHWAddr, 5, 5);		// HW addr	SetColType(kColTypeComment1, 6, 6);		// client ID	SetColWidth(kColWidthIPAddr, 1, 1);	SetColWidth(kColWidthState, 2, 2);	SetColWidth(kColWidthTime, 3, 4);	SetColWidth(kColWidthHWAddr, 5, 5);	SetColWidth(500, 6, 6);}// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------voidCDHCPStatusTable::ListenToMessage(	MessageT	inEventCode,	void		*ioParam ){	wide tData;	tData.hi = 0;	tData.lo = 0;	switch ( inEventCode ) {					case kTableDeleteButton:			// inHowMany, inFromRow			gDHCPData->RemoveDataDHCPStatusArray(mSelectedCell.row);//			lastRow = gDHCPData->GetDataCountDHCPStatus();//			RemoveRows(1, mSelectedCell.row);//			for (index=mSelectedCell.row; index<=lastRow; index++) {//				RefreshRow(index);//			}			break;					default:			//gLogAction->LogText("\p\rCEditTable unknown async message: ", inEventCode);			break;	}}// ---------------------------------------------------------------------------//		¥ Click Cell// ---------------------------------------------------------------------------//  Handle click in cell.//	Display table entry in window edit fieldsvoidCDHCPStatusTable::ClickCell(	const TableCellT		&inCell,	const SMouseDownEvent&	inMouseDown){//	DHCPStatusEntry_t	DHCPStatusEntry;	SelectRow(inCell, false);	// ( ,extendFlag)//	if (GetDHCPStatusEntry(inCell.row, &arpEntry))//		((CDHCPWindow*)mWindow)->DisplayDHCPStatusEntry(&arpEntry);}// ---------------------------------------------------------------------------------//		¥ GetDHCPStatusEntry// ---------------------------------------------------------------------------------//	Get DHCPStatus Entry from TableBooleanCDHCPStatusTable::GetDHCPStatusEntry(TableIndexT inRow, DHCPStatusEntry_t* outEntry){	TableCellT		theCell;	TableItemW		tData;	Str255			str;	Boolean			result = true;		do {		// check for valid row entry (has an IP address)		theCell.row = inRow;		theCell.col = kColDHCPStatusIPAddr;		if (!IsValidCell(theCell)) {			result = false;			break;		}		GetCellData(theCell, &tData);		if (tData.hi == 0) {			result = false;			break;		}		// initialize output buffer		bzero((UInt8*)outEntry, sizeof(DHCPStatusEntry_t));		// get entry			// IP Addr		theCell.col = kColDHCPStatusIPAddr;		GetCellData(theCell, &tData);		outEntry->leaseAddr = tData.hi;				// IP Addr			// State		theCell.col = kColDHCPStatusState;		GetCellData(theCell, &tData);		outEntry->leaseState = tData.hi;					// state			// Last Update		theCell.col = kColDHCPStatusLastUpdate;		GetCellData(theCell, &tData);		outEntry->lastUpdate = tData.hi;			// Last Update			// Expire Time		theCell.col = kColDHCPStatusExpireTime;		GetCellData(theCell, &tData);				// Expire Time		outEntry->expireTime = tData.hi;			// HW Addr		theCell.col = kColDHCPStatusHWAddr;		GetCellData(theCell, &tData);				// HW Addr		outEntry->hardwareAddr = *(MACAddr_t*)&tData;			// Client ID		GetCommentData(theCell.row, 1, str);		DecodeHexStr(str, outEntry->clientID);	} while (false);		return result;}// ---------------------------------------------------------------------------------//		¥ SetDHCPStatusEntry// ---------------------------------------------------------------------------------//	Set DHCPStatus Entry in Table//	Refresh if entry was changedvoidCDHCPStatusTable::SetDHCPStatusEntry(TableIndexT inRow, DHCPStatusEntry_t* inEntry){	TableCellT		theCell;	TableItemW		tData, uData;	Str255			str;	Str255			tStr;	Boolean			result = false;	do {		// check for valid row entry		if (inRow > kMaxDHCPStatusTableRows) {			result = false;			break;		}		// insert rows if needed		if (inRow > mRows) {			tData.hi = 0;			tData.lo = 0;			InsertRows(inRow-mRows, mRows, &tData);	// how many, after row, *data		}		// set entry		theCell.row = inRow;			// leaseAddr		theCell.col = kColDHCPStatusIPAddr;		tData.hi = inEntry->leaseAddr;		tData.lo = 0;		GetCellData(theCell, &uData);		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}			// state		theCell.col = kColDHCPStatusState;		tData.hi = inEntry->leaseState;		tData.lo = 0;		GetCellData(theCell, &uData);		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}			// last update		theCell.col = kColDHCPStatusLastUpdate;		tData.hi = inEntry->lastUpdate;		tData.lo = 0;		GetCellData(theCell, &uData);		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}			// expire time		theCell.col = kColDHCPStatusExpireTime;		tData.hi = inEntry->expireTime;		tData.lo = 0;		GetCellData(theCell, &uData);		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}			// hardwareAddr		theCell.col = kColDHCPStatusHWAddr;		tData.hi = inEntry->hardwareAddr.first4;		tData.lo = inEntry->hardwareAddr.last2 << 16;		GetCellData(theCell, &uData);		if ((tData.hi != uData.hi) || (tData.lo != uData.lo)) {			SetCellData(theCell, &tData);			result = true;		}			// ClientID		theCell.row = inRow;		theCell.col = kColDHCPStatusClientID;		GetCommentData(inRow, 1, str);		EncodeHexStr(inEntry->clientID, tStr);		SetCommentData(inRow, 1, tStr);		tData.hi = kCommentFlag;		tData.lo = 0;		SetCellData(theCell, &tData);		if (!EqualString(str, tStr, false, false)) {			result = true;		}	} while (false);	if (result) RefreshRow(inRow);}// ---------------------------------------------------------------------------//		¥ DoCopy// ---------------------------------------------------------------------------// Copy traceroute results to clipboardvoidCDHCPStatusTable::DoCopy(){	TableItemW		tData;	TableCellT		tCell;	Handle 			copyDataH;	UInt32			copyDataL;	Str32			str;	TableIndexT		index, numRows, colOffset, lineOffset;	StringHandle	textPositionH;	OSErr 			err;	copyDataH = nil;	textPositionH = nil;	do {		// get copy data and place in scrap		// figure out how many rows of data we have and allocate space on the heap		numRows = mSelectionEnd - mSelectionStart + 1;		copyDataH = ::NewHandle((numRows+1) * kMaxDHCPSize);		if (copyDataH == nil) break;		copyDataL = 0;		lineOffset = 0;		// clear existing scrap		err = ::ZeroScrap();		if (err != noErr) break;		// get column positions		textPositionH = ::GetString(kDHCPStatusText);		if (textPositionH == nil) break;		// if first row is selected, include headings		if (mSelectionStart == 1) {			// column headings			for (index=1; index<=mCols; index++) {				// get offset to next column				colOffset = *(*textPositionH + index);				// space over to column position				SpaceOver(copyDataH, copyDataL, lineOffset, colOffset);				// get column heading				::GetIndString(str, kDHCPStatusText, index);				AppendString(copyDataH, copyDataL, str);			}			// mark end of line			AppendString(copyDataH, copyDataL, "\p\r");			lineOffset = copyDataL;							}		// convert data for each row		for (index=mSelectionStart; index<=mSelectionEnd; index++) {						// IP Addr			colOffset = *(*textPositionH + kColDHCPStatusIPAddr);			// space over to column, get data, and append it			SpaceOver(copyDataH, copyDataL, lineOffset, colOffset);			tCell.col = kColDHCPStatusIPAddr;			tCell.row = index;			GetCellData( tCell, &tData );			if (tData.hi != kItemNone) {				IP_NumToStr(tData.hi, str);				AppendString(copyDataH, copyDataL, str);			}						// State			colOffset = *(*textPositionH + kColDHCPStatusState);			// space over to column, get data, and append it			SpaceOver(copyDataH, copyDataL, lineOffset, colOffset);			tCell.col = kColDHCPStatusState;	// sent flags			tCell.row = index;			GetCellData( tCell, &tData );			if (tData.hi != kItemNone) {				if (tData.hi == kLeaseOffered) AppendString(copyDataH, copyDataL, kLeaseOfferedStr );				else if (tData.hi == kLeaseBound) AppendString(copyDataH, copyDataL, kLeaseBoundStr );				else if (tData.hi == kLeaseReleased) AppendString(copyDataH, copyDataL, kLeaseReleasedStr );				else if (tData.hi == kLeaseExpired) AppendString(copyDataH, copyDataL, kLeaseExpiredStr );				else if (tData.hi == kLeaseDeclined) AppendString(copyDataH, copyDataL, kLeaseDeclinedStr );				else if (tData.hi == kLeaseInUse) AppendString(copyDataH, copyDataL, kLeaseInUseStr );			}			// Last Update			colOffset = *(*textPositionH + kColDHCPStatusLastUpdate);			// space over to column, get data, and append it			SpaceOver(copyDataH, copyDataL, lineOffset, colOffset);			tCell.col = kColDHCPStatusLastUpdate;			tCell.row = index;			GetCellData( tCell, &tData );			if (tData.hi != kItemNone) {				LStr255 timeDateStr;				// build time string				// setup formatting resource				if (mFormatH == nil) {					OSErr		err;					mFormatH = ::GetIntlResource(0);	// Get 'itl0' resource					err = ::HandToHand(&mFormatH);		// Get a copy					if (err != noErr) mFormatH = nil;					// modify to use 24 hour time					(**(Intl0Hndl)mFormatH).timeCycle = 0;				}				// void DateString (long dateTime,DateFormlongFlag,char *result,Handle intlHandle);				::DateString(tData.hi, shortDate, str, nil);				timeDateStr += str;				timeDateStr += "\p ";				// void TimeString (long dateTime,Boolean wantSeconds,char *result,Handle intlHandle);						::TimeString(tData.hi, true, str, mFormatH);				timeDateStr += str;				AppendString(copyDataH, copyDataL, timeDateStr);			}			// Expire Time			colOffset = *(*textPositionH + kColDHCPStatusExpireTime);			// space over to column, get data, and append it			SpaceOver(copyDataH, copyDataL, lineOffset, colOffset);			tCell.col = kColDHCPStatusExpireTime;			tCell.row = index;			GetCellData( tCell, &tData );			if (tData.hi != kItemNone) {				LStr255 timeDateStr;				// build time string				// setup formatting resource				if (mFormatH == nil) {					OSErr		err;					mFormatH = ::GetIntlResource(0);	// Get 'itl0' resource					err = ::HandToHand(&mFormatH);		// Get a copy					if (err != noErr) mFormatH = nil;					// modify to use 24 hour time					(**(Intl0Hndl)mFormatH).timeCycle = 0;				}				// void DateString (long dateTime,DateFormlongFlag,char *result,Handle intlHandle);				::DateString(tData.hi, shortDate, str, nil);				timeDateStr += str;				timeDateStr += "\p ";				// void TimeString (long dateTime,Boolean wantSeconds,char *result,Handle intlHandle);						::TimeString(tData.hi, true, str, mFormatH);				timeDateStr += str;				AppendString(copyDataH, copyDataL, timeDateStr);			}			// HW Address			colOffset = *(*textPositionH + kColDHCPStatusHWAddr);			// space over to column, get data, and append it			SpaceOver(copyDataH, copyDataL, lineOffset, colOffset);			tCell.col = kColDHCPStatusHWAddr;			tCell.row = index;			GetCellData( tCell, &tData );			if ((tData.hi != kItemNone) || (tData.lo>>16 != kItemNone)) {				HW_NumToHexStr( (MACAddr_t*)&tData, str );				AppendString(copyDataH, copyDataL, str );			}			// ClientID			colOffset = *(*textPositionH + kColDHCPStatusClientID);			// space over to column, get data, and append it			SpaceOver(copyDataH, copyDataL, lineOffset, colOffset);			tCell.row = index;			tCell.col = kColDHCPStatusClientID;			GetCellData( tCell, &tData );			// display comment data if any			if (tData.hi == kCommentFlag) {				if (mCommentData != nil) {					Str255 commentData;					GetCommentData(tCell.row, 1, commentData);					AppendString(copyDataH, copyDataL, commentData);				}			}						// mark end of line			AppendString(copyDataH, copyDataL, "\p\r");			lineOffset = copyDataL;							}		// transfer data to desk scrap		::HLock(copyDataH);		err = ::PutScrap(copyDataL, (ResType)'TEXT', (*copyDataH));		::HUnlock(copyDataH);	} while (false);		if (copyDataH) ::DisposeHandle(copyDataH);	if (textPositionH) ::ReleaseResource((Handle)textPositionH);}// ---------------------------------------------------------------------------------//		¥ UpdateTable// ---------------------------------------------------------------------------------//	Update DHCP Status Table from data objectvoidCDHCPStatusTable::UpdateTable(){	ArrayIndexT			num;	ArrayIndexT			index;	DHCPStatusEntry_t	entry;		num = gDHCPData->GetDataCountDHCPStatus();	for (index=1; index<=num; index++) {		if (gDHCPData->GetDataDHCPStatusArray(index, &entry)) {			SetDHCPStatusEntry(index, &entry);		} else {			ClearRow(index);		}	}}// ---------------------------------------------------------------------------//		¥ Draw Cell// ---------------------------------------------------------------------------voidCDHCPStatusTable::DrawCell(	const TableCellT	&inCell){	Rect		cellFrame;	wide		tData;	UInt8		colType;	OSErr		err = 0;	if (FetchLocalContentFrame(inCell, cellFrame)) {		// draw white background		::PenNormal();		ApplyForeAndBackColors();		::EraseRect(&cellFrame);		// draw border around cell		::InsetRect(&cellFrame, -1, -1);		::PenPat(&UQDGlobals::GetQDGlobals()->gray);		if (PaneInColor (this)) {			StColorState	saveColor;			RGBColor		emptyColor;			emptyColor = gAGAColorArray[6];			::RGBForeColor(&emptyColor);			::FrameRect(&cellFrame);		} else { ::FrameRect(&cellFrame); }		::PenPat(&UQDGlobals::GetQDGlobals()->black);				// draw contents		::TextFont(applFont);		::TextFace(0);	// normal		::TextSize(9);		// Get cell data		GetCellData( inCell, &tData );		// Handle each column based its Column Data Type		colType = GetColType(inCell.col);		switch (colType) {			case kColTypeState:				// display IP Address if not zero				if (tData.hi != kItemNone) {					MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);					if (tData.hi == kLeaseOffered) DrawString( kLeaseOfferedStr );					else if (tData.hi == kLeaseBound) DrawString( kLeaseBoundStr );					else if (tData.hi == kLeaseReleased) DrawString( kLeaseReleasedStr );					else if (tData.hi == kLeaseExpired) DrawString( kLeaseExpiredStr );					else if (tData.hi == kLeaseDeclined) DrawString( kLeaseDeclinedStr );					else if (tData.hi == kLeaseInUse) DrawString( kLeaseInUseStr );					else if (tData.hi == kLeaseBootP) DrawString( kLeaseBootPStr );				}				break;			default:						// inherit behavior for common data types				CConfigureTable::DrawCell(inCell);				break;		}	}}