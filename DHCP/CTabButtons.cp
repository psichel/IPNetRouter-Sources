// =================================================================================//	CTabButtons.cp				©1996 Sustainable Softworks All rights reserved.// =================================================================================//	Display multiple index tab buttons//		Individual button captions are separated by "|" in the descriptor.//		Use SetButtonWidth to adjust button widths.//		Width of zero means no more captions.#include <LView.h>#include "CTabButtons.h"#include "AGAColors.h"// ---------------------------------------------------------------------------------//		¥ CreateTabButtonsStream [static]// ---------------------------------------------------------------------------------CTabButtons *CTabButtons::CreateTabButtonsStream(	LStream	*inStream ){	return new CTabButtons( inStream );}// ---------------------------------------------------------------------------------//		¥ CTabButtons(LStream*)// ---------------------------------------------------------------------------------CTabButtons::CTabButtons(	LStream	*inStream )		: LTextButton( inStream ){	inStream->ReadData(&mTabs, sizeof(mTabs));	inStream->ReadData(&mTabWidth, sizeof(mTabWidth));		// initialize tab views and tab area regions to nil	for (TabIndexT tab=1; tab<=kMaxTabs; tab++) {		mTabView[tab] = nil;		mTabAreaRgn[tab] = nil;	}		mFrameSize.width = mTabWidth * mTabs;		// set width based on tabs	InitTabAreas();		mMinValue = 1;	mMaxValue = mTabs;		// the number tabs we actually have	mValue = 1;				// set initially selected tab}// ---------------------------------------------------------------------------------//		¥ ~CTabButtons// ---------------------------------------------------------------------------------CTabButtons::~CTabButtons(){	for (TabIndexT tab=1; tab<=kMaxTabs; tab++) {		// dispose any allocated regions		if (mTabAreaRgn[tab] != nil) ::DisposeRgn(mTabAreaRgn[tab]);	}}#pragma mark -- Geometry and Setup --// ---------------------------------------------------------------------------------//		¥ InitTabAreas// ---------------------------------------------------------------------------------voidCTabButtons::InitTabAreas(){	Rect		frame;	SInt16		frameEnd;			CalcLocalFrameRect(frame);	frameEnd	= frame.right;	frame.right = frame.left;	for (TabIndexT tab=1; tab<=mTabs; tab++) {		// tab frame contains entire height of pane		frame.left = frame.right;		frame.right = frame.left + mTabWidth;		mTabAreaFrame[tab] = frame;				// tab region contains interior of tab only		// dispose previous region if any		if (mTabAreaRgn[tab] != nil) ::DisposeRgn(mTabAreaRgn[tab]);				// define new region		mTabAreaRgn[tab] = NewRgn();		OpenRgn();			MoveTo(frame.left,    frame.bottom-1);		// leave room for hilite			LineTo(frame.left,    frame.top+3);			LineTo(frame.left+3,  frame.top);			LineTo(frame.right-3, frame.top);			LineTo(frame.right,   frame.top+3);			LineTo(frame.right,   frame.bottom-1);			LineTo(frame.left,    frame.bottom-1);		CloseRgn(mTabAreaRgn[tab]);	}}// ---------------------------------------------------------------------------------//		¥ Set Tab Width// ---------------------------------------------------------------------------------voidCTabButtons::SetTabWidth(SInt16 inWidth){	mTabWidth = inWidth;	mFrameSize.width = mTabWidth * mTabs;		// compute new width	InitTabAreas();								// update tab areas}// ---------------------------------------------------------------------------//		¥ Get Column Width// ---------------------------------------------------------------------------SInt16CTabButtons::GetTabWidth( TabIndexT inTab ){	return mTabWidth;}// ---------------------------------------------------------------------------------//		¥ Set Tab View// ---------------------------------------------------------------------------------voidCTabButtons::SetTabView(LView* inView, TabIndexT inTab){	if ((inTab >= mMinValue) && (inTab <= mMaxValue)) mTabView[inTab] = inView;}#pragma mark -- Control Behaviors --// ---------------------------------------------------------------------------//		¥ FindHotSpot// ---------------------------------------------------------------------------//	Determine which hot spot, if any, contains the specified point////		inPoint is in the local coordinates for the Control////		Valid hot spot numbers are > 0. Return 0 if no hot spot is hit.//		Controls can use any positive integers to number hot spots. Typical//		would be to number hot spots sequentially beginning with 1, and to//		store the hot spot locations in an array of rectangles.SInt16CTabButtons::FindHotSpot(Point inPoint) const{	for (TabIndexT tab=1; tab<=mTabs; tab++) {		if ( ::PtInRect(inPoint, &mTabAreaFrame[tab]) ) return tab;	}	return	0;}// ---------------------------------------------------------------------------//		¥ PointInHotSpot// ---------------------------------------------------------------------------//	Determine if a point is within a specified hot spot////		inPoint is in the local coordinates for the Control//		inHotSpot is the hot spot number////		Return true if the point is within the hot spot////		This function is called to check if the mouse is still within a//		hot spot during mouse down trackingBooleanCTabButtons::PointInHotSpot(	Point 	inPoint,	SInt16	inHotSpot) const{	return ::PtInRect(inPoint, &mTabAreaFrame[inHotSpot]);}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//		¥ HotSpotAction// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//	Toggle between highlighted and plain states, depending on mouse locationvoidCTabButtons::HotSpotAction(	SInt16	inHotSpot,	Boolean	inCurrInside,	Boolean	inPrevInside){	RGBColor	emptyColor;	Rect		frame;	if (inHotSpot != mValue) {		frame = mTabAreaFrame[inHotSpot];		if (inCurrInside) {			if (!inPrevInside) {				//::InvertRect(&mTabAreaFrame[inHotSpot]);				// add shading				::InsetRect(&frame, 1, 1);				emptyColor = gAGAColorArray[kHiliteColor];				::RGBForeColor(&emptyColor);				::MoveTo(frame.left, frame.bottom-2);		// start at lower left				::LineTo(frame.left, frame.top+3);			// left side				::LineTo(frame.left+3, frame.top);			// left slant				::LineTo(frame.right-3, frame.top);			// top			}		} else {			if (inPrevInside) {				//::InvertRect(&mTabAreaFrame[inHotSpot]);				// remove shading				::InsetRect(&frame, 1, 1);				emptyColor = gAGAColorArray[W];				::RGBForeColor(&emptyColor);				::MoveTo(frame.left, frame.bottom-2);		// start at lower left				::LineTo(frame.left, frame.top+3);			// left side				::LineTo(frame.left+3, frame.top);			// left slant				::LineTo(frame.right-3, frame.top);			// top			}		}	}}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//		¥ HotSpotResult// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//	 Update value and send messagevoidCTabButtons::HotSpotResult(SInt16 inHotSpot){	if (mValue != inHotSpot) {		SetValue(inHotSpot);	} else {		HotSpotAction(inHotSpot, true, false);	// Undo hilighting	}}// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//		¥ SetValue// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//	Reset button value, update region, and send messagevoidCTabButtons::SetValue(	SInt32 inValue){	SInt32 oldValue = mValue;		LControl::SetValue(inValue);	if (oldValue != inValue) {		RefreshTab(oldValue);		RefreshTab(inValue);	}}#pragma mark -- Drawing --// ---------------------------------------------------------------------------//		¥ RefreshTab// ---------------------------------------------------------------------------//	Invalidate the area occupied by Tab////	This forces an Update event that, when processed, will redraw the Tab.//	Refresh does nothing if the Pane is not exposed.voidCTabButtons::RefreshTab(TabIndexT inTab){	Rect	refreshRect;		if ( (inTab <= mTabs) &&		 IsVisible()  &&		 CalcPortFrameRect(refreshRect)  &&		 (mSuperView != nil) ) {		refreshRect = mTabAreaFrame[inTab];		// convert to port coordinates		LocalToPortPoint( topLeft(refreshRect) );		LocalToPortPoint( botRight(refreshRect) );				Rect	superRevealed;		mSuperView->GetRevealedRect(superRevealed);		if (::SectRect(&refreshRect, &superRevealed, &refreshRect)) {			InvalPortRect(&refreshRect);		}	}}// ---------------------------------------------------------------------------//		¥ DrawSelf// ---------------------------------------------------------------------------voidCTabButtons::DrawSelf(){	LStr255 	subString;	UInt8		startPos, endPos;		// for each tab	// get the substring to display in this tab	// draw the tab	endPos = 0;	for (TabIndexT tab=1; tab<=mTabs; tab++) {		// get next substring		startPos = endPos + 1;		endPos = mText.Find( '|', startPos );		if (endPos == 0) endPos = startPos;		subString.Assign( mText, startPos, endPos-startPos );				// draw tab		DrawTab(tab, subString);	}}// ---------------------------------------------------------------------------//		¥ DrawTab// ---------------------------------------------------------------------------voidCTabButtons::DrawTab(TabIndexT inTab, ConstStr255Param inText){	StTextState		origTextState;	StColorPenState	origCPenState;	Rect 			frame;	RGBColor		outlineColor, tabColor, textColor, emptyColor;	CalcLocalFrameRect(frame);	// if not beyond last tab	if (inTab <= mTabs) {		// get tab frame		frame = mTabAreaFrame[inTab];			ApplyForeAndBackColors();			// apply superview colors		//::EraseRect(&frame);				// erase to background		::GetForeColor(&textColor);			// setup tab colors		outlineColor = textColor;		::GetBackColor(&tabColor);		if (inTab != mValue) {			tabColor = gAGAColorArray[kFadedTabColor];			outlineColor = gAGAColorArray[kFadedOutlineColor];		}				::RGBForeColor(&tabColor);			// color tab area		::PaintRgn(mTabAreaRgn[inTab]);		// draw tab outline		::RGBForeColor(&outlineColor);		::MoveTo(frame.left, frame.bottom-2);		// start at lower left, leave room for underline		::LineTo(frame.left, frame.top+3);			// left side		::LineTo(frame.left+3, frame.top);			// left slant		::LineTo(frame.right-4, frame.top);			// top		::LineTo(frame.right-1, frame.top+3);		// right slant		::LineTo(frame.right-1, frame.bottom-2);	// right side		// draw bottom as needed		::RGBForeColor(&textColor);		if (inTab != mValue) {			::LineTo(frame.left, frame.bottom-2);			emptyColor = gAGAColorArray[W];			::RGBForeColor(&emptyColor);			::MoveTo(frame.left, frame.bottom);			::LineTo(frame.right, frame.bottom);		}		// add shading		::InsetRect(&frame, 1, 1);		emptyColor = gAGAColorArray[W];		::RGBForeColor(&emptyColor);		::MoveTo(frame.left, frame.bottom-2);		// start at lower left		::LineTo(frame.left, frame.top+3);			// left side		::LineTo(frame.left+3, frame.top);			// left slant		::LineTo(frame.right-4, frame.top);			// top		// Configure the text state.		// If the tab is selected, modify the text style.		SInt16 just = UTextTraits::SetPortTextTraits(mTextTraitsID);		::RGBForeColor(&textColor);		::RGBBackColor(&tabColor);		if (inTab == mValue) {			GrafPtr currPort = UQDGlobals::GetCurrentPort();			SInt16 currStyle = currPort->txFace;			::TextFace(currStyle ^ mSelectedStyle);		}		frame.top += 3;		// adjust vertical position 		UTextDrawing::DrawWithJustification((Ptr)&inText[1], inText[0], frame, just);	}}