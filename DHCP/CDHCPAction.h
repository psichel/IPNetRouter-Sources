// =================================================================================//	CDHCPAction.h	 	©1999 Sustainable Softworks. All rights reserved.// =================================================================================//	DHCP actions#pragma once#include "CDHCPData.h"#include "dhcp.h"		// pick up protocol definitions#include <LCleanupTask.h>#include <LPeriodical.h>#include <LListener.h>#include "CObjectMaster.h"#define kMaxServerDim	4const SInt16 kMaxServerIndex	= 3;const SInt16 kNoServerIndex	    = 255;struct dhcp_option {	UInt8	option;	UInt8	len;	UInt16	offset;};typedef struct dhcp_option dhcp_option_t;// DHCP request (collect DHCP message information)struct dhcp_request {	UInt8*	data;	// pointer to buffer containing DHCP request	UInt32	size;	// size of data in buffer	UInt16	offset;	// offset to next item in buffer	UInt16	remotePort;	UInt32	remoteAddr;	UInt32	localAddr;		// IP_RCVIFADDR	UInt32	localTarget;	// IP_RCVDSTADDR	UInt32  netMask;        // of attached network: from network lease data	UInt32  netNumber;      // of attached network: use giaddr if present, or local target	UInt32	yiaddr;		// address found to assign	UInt32	leaseTime;	// lease Time to assign	UInt8	leaseState;	// previous existing lease state if any	Boolean	useClientID;// remember how we matched client	Boolean	needPing;	// test new address before assigning	// options	UInt8	dhcpMessageType;	UInt32	addressRequest;	UInt32	dhcpServerID;	dhcp_option_t subnetMask;	dhcp_option_t hostName;	dhcp_option_t addressTime;	dhcp_option_t overload;	dhcp_option_t parameterList;	dhcp_option_t dhcpMessage;	dhcp_option_t dhcpMaxMsgSize;	dhcp_option_t renewalTime;	dhcp_option_t rebindingTime;	dhcp_option_t classID;	dhcp_option_t clientID;};typedef struct dhcp_request dhcp_request_t;// DHCP response buffer#define kMaxResponseLen	1460struct dhcp_response {	UInt32	xid;			// identify element	UInt16	dataLen;	UInt16	maxLen;	UInt32	ciaddr;			// copied from request	UInt32	localAddr;		// copied from request	OTTimeStamp	timeStamp;	// time when placed on response array	UInt32	yiaddr;			// assigned address	UInt32	remoteAddr;		// copied from request	UInt8	leaseState;		// previous existing lease state if any, copied from req	UInt8	respondVia;	UInt8	dhcpMessageType;	UInt8	responseState;	// is response ready, waiting for ping, etc...	// data buffer	UInt8	buf[kMaxResponseLen];	// minimum requirement is 576};typedef struct dhcp_response dhcp_response_t;// definitions for respondViaconst SInt16 kViaNone				= 0;const SInt16 kViaUnicast			= 1;	// IP unicast to existing ciaddrconst SInt16 kViaBroadcast			= 2;	// IP local broadcast (all 1's addr)const SInt16 kViaHardwareUnicast	= 3;	// stuff ARP cache, then unicast to MAC addrconst SInt16 kViaRelayAgent		    = 4;	// send response to relay agentconst UInt16 kBroadcastFlag		    = 0x8000;// definitions for responseStatusconst SInt16 kRSNone				= 0;const SInt16 kRSReady				= 1;	// ready to be sentconst SInt16 kRSPing				= 2;	// waiting for ping to timeout// when to check timeoutsconst SInt16 kIdleDefault			= 5000;	// test every 5 secondsconst SInt16 kIdleRestart			= 2000;	// restart after 2 secondconst SInt16 kIdleData				= 250;	// data waiting, every 250 msconst SInt16 kDHCPRetryCount		= 10;	// number times to try restarting// sequence number used to ID our own pingsconst SInt16 kDHCPServerSN			= 0x0328;class CTurboUDPEndpoint;class CReceiveUDPThread;class CSendUDPThread;class LArray;class LComparator;class LFile;class CDHCPAction :	public LPeriodical, LListener, public CObjectMaster {public:								CDHCPAction();	virtual		 				~CDHCPAction();	void				Terminate(Boolean inCanWait=true);	void				UseDefaults();	Boolean				StartServing();	Boolean				StopServing(Boolean inCanWait=true);	virtual void		SpendTime(const EventRecord &inMacEvent);	virtual void		ObjectThreadDied(LThread *inThread);	void				ListenToMessage(							MessageT	inEventCode,							void		*ioParam );	void				ReadStatusFile();	void				WriteStatusFile();	SInt32				ImportFromText(Handle inTextH);	SInt32				ExportToText(Handle inTextH);	void				ReceiveICMP(LDataArrived* inMessage);	void				ReceiveData(LDataArrived* inMessage);protected:	void				ProcessRequest(dhcp_request_t* inRequest);	void				SendQResponse(dhcp_response_t* inResponse);	Boolean				SendResponse(dhcp_response_t* inResponse);	Boolean				SendPing(UInt32 inPingAddress);	void				LogDHCPRequest(dhcp_request_t* inRequest);	void				LogDHCPResponse(dhcp_response_t* inResponse);	void				LogDHCPMessage(DHCPMessage_t* inMessage, UInt16 inSize);	UInt8				LogDHCPOptions(DHCPMessage_t* inMessage, UInt32 start, UInt32 end);	UInt8				LogDHCPOption(UInt8 option, UInt8 len, UInt8* data);	StringPtr			MsgTypeToString(UInt8 inType, Str31 outStr);	void				FindDHCPOptions(dhcp_request_t* inRequest, UInt32 start, UInt32 end);	ArrayIndexT			FindLeaseStatus(dhcp_request_t* inRequest);	ArrayIndexT			FindLeaseStatus(UInt32 inLeaseAddr);	ArrayIndexT			FindLeaseData(dhcp_request_t* inRequest);	ArrayIndexT			FindLeaseData(UInt32 inLocalAddr);	Boolean				CheckServerID(UInt32 inServerID);	ArrayIndexT			CheckDynamicPool(UInt32 inLeaseAddr);	ArrayIndexT			CheckStaticPool(UInt32 inLeaseAddr);	Boolean				MatchClientID(Str255 clientIDA, Str255 clientIDB);	Boolean				FindLeaseAddr(dhcp_request_t* inRequest);	Boolean				FindLeaseTime(dhcp_request_t* inRequest);	UInt8				FindRespondVia(dhcp_response_t* inResponse);	Boolean				BuildResponse(							dhcp_request_t* inRequest,							dhcp_response_t* outResponse,							UInt8 responseType);	void				PutOption(UInt8* buffer, UInt16* ioOffset,							UInt8 optionCode, UInt8 optionLen, UInt8* optionData);	Boolean				PutAddrList(UInt8* buffer, UInt16* ioOffset,							UInt8 optionCode, Str255 inList);	Boolean				UpdateLeaseBinding(dhcp_request_t* inRequest, UInt8 leaseState);	void				LastComplete();	LArray*				mResponseArray;	Boolean				mIsServing;	Boolean				mWaitingToRestart;	UInt8				mDHCPRetryCount;	private:		// UDP query	UInt32				mServerAddr[kMaxServerDim];	CTurboUDPEndpoint*	mUDPEndpoint;				// our UDP network endpoint object	CReceiveUDPThread*	mReceiveUDPThread;	CSendUDPThread*		mSendUDPThread;	CTurboUDPEndpoint*	mICMPEndpoint;				// our UDP network endpoint object	CReceiveUDPThread*	mReceiveICMPThread;	CSendUDPThread*		mSendICMPThread;	UInt32				mStartTime;					// Server start time	OTTimeStamp			mLastStamp;	UInt32				mIdleDelay;					// milliseconds	UInt16				mPingCounter;	// Option Management	TOptMgmt    mReq;	UInt8 		mOptionBuf[kOTFourByteOptionSize];						// define buffer for options, although we only						// use a "1 byte option", we define a "4 byte option"						// buffer to hold the returning options	TOptMgmt    mReq2;	UInt8 		mOptionBuf2[kOTFourByteOptionSize];	};const Str63 kDHCPStatusFileName	= "\pDHCP Server Status";const Str63 kDHCPTempFileName =  "\pDHCP Server Temp";