// =================================================================================//	CDHCPWindow.cp			©1998 Sustainable Softworks All rights reserved.// =================================================================================//	IP DHCP Window#include "CompileFlags.h"#include "CDHCPWindow.h"#include "CDHCPConst.h"#include "CDHCPStatusTable.h"#include "CDHCPStaticCfgTable.h"#include "CDHCPDynamicCfgTable.h"#include "CDHCPLeaseDataView.h"#include "CIPNumberEditField.h"#include "IPRouterCommon.h"#include "CMultiCaption.h"#include "CTabButtons.h"#include "CHelpWindow.h"#include <LMultiPanelView.h>#include "MacSupport.h"#include "IPSupport.h"#include "CLogAction.h"#include <UReanimator.h>#include <LString.h>#include <LPreferencesFile.h>#include <UResourceMgr.h>#include <LArrayIterator.h>#include <OpenTransport.h>#include <OpenTptInternet.h>#include <LInternetMapper.h>#include <LOpenTptInetMapper.h>#include "CDHCPData.h"#include "CDHCPAction.h"#include "CDeviceData.h"#include "CGatewayData.h"// Globalsextern CLogAction*		gLogAction;extern CDHCPData*		gDHCPData;extern CDHCPAction*		gDHCPAction;// ---------------------------------------------------------------------------------//		¥ CDHCPWindow(LStream*)// ---------------------------------------------------------------------------------CDHCPWindow::CDHCPWindow(	LStream	*inStream )		: CWindow( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CDHCPWindow// ---------------------------------------------------------------------------------CDHCPWindow::~CDHCPWindow(){	// disconnect from DHCP data	gDHCPData->RemoveListener(this);}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------//	Finish creating the DHCP window.voidCDHCPWindow::FinishCreateSelf(){		// Link the window (the listener) with the controls in	// the window (the broadcasters).	UReanimator::LinkListenerToControls(		(CDHCPWindow *)this, this, rRidL_DHCPWindow );	// setup pointer to status caption	mStatusCaption = (LCaption*)FindPaneByID( kStatusCaption );	ThrowIfNil_(mStatusCaption);	// get TabButtons	mTabButtons = (CTabButtons*)FindPaneByID( kTabButtons );	ThrowIfNil_(mTabButtons);	// setup multipanel view	mMultiPanelView = (LMultiPanelView*)FindPaneByID( kMultiPanelView );	ThrowIfNil_(mMultiPanelView);		// add DHCP panels to multipanel view	mMultiPanelView->AddPanel(rPPob_StatusPanel, nil, 1);	mMultiPanelView->AddPanel(rPPob_StaticCfgPanel, nil, 2);	mMultiPanelView->AddPanel(rPPob_DynamicCfgPanel, nil, 3);	mMultiPanelView->AddPanel(rPPob_LeaseOptionsPanel, nil, 4);		// create corresponding views and pointers	mMultiPanelView->CreateAllPanels();	mDHCPStatusView			= mMultiPanelView->GetPanel(1);	mDHCPStaticCfgView		= mMultiPanelView->GetPanel(2);	mDHCPDynamicCfgView		= mMultiPanelView->GetPanel(3);	mDHCPLeaseDataView		= (CDHCPLeaseDataView*)mMultiPanelView->GetPanel(4);	mDHCPStatusTable		= (CDHCPStatusTable*)mDHCPStatusView->FindPaneByID(kDHCPTablePane);	mDHCPStaticCfgTable		= (CDHCPStaticCfgTable*)mDHCPStaticCfgView->FindPaneByID(kDHCPTablePane);	mDHCPDynamicCfgTable	= (CDHCPDynamicCfgTable*)mDHCPDynamicCfgView->FindPaneByID(kDHCPTablePane);	mDHCPLeaseDataView->SetWindow(this);		// set table caption widths	CMultiCaption* theCaption;	theCaption = (CMultiCaption*)mDHCPStatusView->FindPaneByID(kDHCPTableCaptionPane);	theCaption->SetWidthFromTable(mDHCPStatusTable);	theCaption->SetColWidth(45, 6, 6);	// client ID caption	theCaption = (CMultiCaption*)mDHCPStaticCfgView->FindPaneByID(kDHCPTableCaptionPane);	theCaption->SetWidthFromTable(mDHCPStaticCfgTable);	theCaption->SetColWidth(180, 4, 4);	theCaption = (CMultiCaption*)mDHCPDynamicCfgView->FindPaneByID(kDHCPTableCaptionPane);	theCaption->SetWidthFromTable(mDHCPDynamicCfgTable);		// set table storage for Client ID string	mDHCPStatusTable->SetCommentDataSize(255, 1);	mDHCPStaticCfgTable->SetCommentDataSize(255, 1);		// get edit buttons	LButton*	theButton;	theButton	= (LButton*)mDHCPStaticCfgView->FindPaneByID(kTableInsertButton);	theButton->AddListener(mDHCPStaticCfgTable);	theButton	= (LButton*)mDHCPStaticCfgView->FindPaneByID(kTableDeleteButton);	theButton->AddListener(mDHCPStaticCfgTable);	theButton	= (LButton*)mDHCPDynamicCfgView->FindPaneByID(kTableInsertButton);	theButton->AddListener(mDHCPDynamicCfgTable);	theButton	= (LButton*)mDHCPDynamicCfgView->FindPaneByID(kTableDeleteButton);	theButton->AddListener(mDHCPDynamicCfgTable);	theButton	= (LButton*)mDHCPStatusView->FindPaneByID(kTableDeleteButton);	theButton->AddListener(mDHCPStatusTable);		// show initial view	mDHCPStatusView->Hide();	mDHCPStaticCfgView->Hide();	mDHCPDynamicCfgView->Hide();	mDHCPLeaseDataView->Hide();	mMultiPanelView->SwitchToPanel(1, false);	// connect to DHCP data	gDHCPData->AddListener(this);	// load the DHCP tables	mDHCPStatusTable->UpdateTable();	mDHCPStaticCfgTable->UpdateTable();	mDHCPDynamicCfgTable->UpdateTable();	mDHCPLeaseDataView->UpdateView(1);	// initialize DHCP Verbose Logging control	mDHCPVerboseLogging = (LStdCheckBox*)FindPaneByID( kDHCPVerboseLoggingCheckBox );	ThrowIfNil_(mDHCPVerboseLogging);	mDHCPVerboseLogging->SetValue(gDHCPData->GetDataDHCPVerboseLogging());	// initialize DHCP Server On control	mDHCPServerOn = (LStdCheckBox*)FindPaneByID( kDHCPServerOnCheckBox );	ThrowIfNil_(mDHCPServerOn);	mDHCPServerOn->SetValue(gDHCPData->GetDataDHCPServerOn());}// ---------------------------------------------------------------------------//		¥ HandleKeyPress// ---------------------------------------------------------------------------//	Handle <Return>, <Enter> passed up from an EditField////	Return true if the Window handles the keystrokeBooleanCDHCPWindow::HandleKeyPress(	const EventRecord&	inKeyEvent){	Boolean		keyHandled = true;	LControl	*keyButton = nil;	SInt16		theKey = inKeyEvent.message & charCodeMask;	switch (theKey) {			//case char_Enter:		//case char_Return:		//	keyButton =  (LControl*) FindPaneByID(kAddButton);		//	break;		case char_UpArrow:			if (inKeyEvent.modifiers & cmdKey) {//				menuChoice = mPortNamePopup->GetValue();//				if (menuChoice > 1) {//					menuChoice -= 1;//					mPortNamePopup->SetValue(menuChoice);//				}			}			break;		case char_DownArrow:			if (inKeyEvent.modifiers & cmdKey) {//				menuChoice = mPortNamePopup->GetValue();//				if (menuChoice < mPortNamePopupMax) {//					menuChoice += 1;//					mPortNamePopup->SetValue(menuChoice);//				}			}			break;		default:			keyHandled = CWindow::HandleKeyPress(inKeyEvent);			break;	}				if (keyButton != nil) {		keyButton->SimulateHotSpotClick(kControlButtonPart);		keyHandled = true;	}		return keyHandled;}// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------voidCDHCPWindow::ListenToMessage(	MessageT	inEventCode,	void		*ioParam ){	OSStatus 			err = noErr;	DHCPStatusEntry_t		statusEntry;	DHCPStaticCfgEntry_t	staticCfgEntry;	DHCPDynamicCfgEntry_t	dynamicCfgEntry;	DHCPLeaseDataEntry_t	leaseDataEntry;	try {		switch ( inEventCode ) {						case msg_SignalDataEvent:							UInt32 dataID = *(UInt32*)ioParam;				// ServerOn setting				if (dataID == DATA_ID(kDHCPStatusData, kDataDHCPServerOn)) {					mDHCPServerOn->SetValue(gDHCPData->GetDataDHCPServerOn());					break;				}				// VerboseLogging setting				if (dataID == DATA_ID(kDHCPStatusData, kDataDHCPVerboseLogging)) {					mDHCPVerboseLogging->SetValue(gDHCPData->GetDataDHCPVerboseLogging());					break;				}				// handle change to DHCPStatusArray				if (dataID>>16 == kDHCPStatusData) {					TableIndexT	row;					row = dataID & 0xFFFF;					if (row > kDataDHCPArrayOffset) {						row -= kDataDHCPArrayOffset;						// try to get data for this row						if (gDHCPData->GetDataDHCPStatusArray(row, &statusEntry)) {							// got it, update table							mDHCPStatusTable->SetDHCPStatusEntry(row, &statusEntry);						}						else {							// no data, row must have been deleted							mDHCPStatusTable->ClearRow(row);						}					}				}				// handle change to DHCPStaticCfgArray				else if (dataID>>16 == kDHCPStaticCfgData) {					TableIndexT	row;					row = dataID & 0xFFFF;					if (row > kDataDHCPArrayOffset) {						row -= kDataDHCPArrayOffset;						// try to get data for this row						if (gDHCPData->GetDataDHCPStaticCfgArray(row, &staticCfgEntry)) {							// got it, update table							mDHCPStaticCfgTable->SetDHCPStaticCfgEntry(row, &staticCfgEntry);						}						else {							// no data, row must have been deleted							mDHCPStaticCfgTable->ClearRow(row);						}					}				}				// handle change to DHCPDynamicCfgArray				else if (dataID>>16 == kDHCPDynamicCfgData) {					TableIndexT	row;					row = dataID & 0xFFFF;					if (row > kDataDHCPArrayOffset) {						row -= kDataDHCPArrayOffset;						// try to get data for this row						if (gDHCPData->GetDataDHCPDynamicCfgArray(row, &dynamicCfgEntry)) {							// got it, update table							mDHCPDynamicCfgTable->SetDHCPDynamicCfgEntry(row, &dynamicCfgEntry);						}						else {							// no data, row must have been deleted							mDHCPDynamicCfgTable->ClearRow(row);						}					}				}				// handle change to DHCPLeaseDataData				else if (dataID>>16 == kDHCPLeaseDataData) {					TableIndexT	row;					row = dataID & 0xFFFF;					if (row > kDataDHCPArrayOffset) {						row -= kDataDHCPArrayOffset;						// try to get data for this row						if (gDHCPData->GetDataDHCPLeaseDataArray(row, &leaseDataEntry)) {							// got it, update table							mDHCPLeaseDataView->SetDHCPLeaseDataEntry(row, &leaseDataEntry);						}						else {							// no data, row must have been deleted							mDHCPLeaseDataView->ClearRow(row);						}						mDHCPLeaseDataView->LoadServerAddrPopup();					}				}				break;			case kTabButtons:				// switch MultiPaneView				mMultiPanelView->ListenToMessage(inEventCode, ioParam);				break;						case kDHCPDefaultsButton:				// setup default configuration for DHCP server				gDHCPAction->UseDefaults();				mDHCPLeaseDataView->LoadServerAddrPopup();				// restore after Default				//mDHCPStatusTable->UpdateTable();				mDHCPStaticCfgTable->UpdateTable();				mDHCPDynamicCfgTable->UpdateTable();								break;			case kDHCPApplyButton:				mDHCPStaticCfgTable->UpdateData();				mDHCPDynamicCfgTable->UpdateData();				mDHCPLeaseDataView->ListenToMessage(inEventCode, ioParam);				// restore after save				mDHCPStatusTable->UpdateTable();				mDHCPStaticCfgTable->UpdateTable();				mDHCPDynamicCfgTable->UpdateTable();				gDHCPData->SignalDataChange();				break;			case kDHCPRestoreButton:				mDHCPStatusTable->UpdateTable();				mDHCPStaticCfgTable->UpdateTable();				mDHCPDynamicCfgTable->UpdateTable();				mDHCPLeaseDataView->ListenToMessage(inEventCode, ioParam);				break;			case kDHCPDoneButton:				AttemptClose();				break;			case kDHCPServerOnCheckBox:				// enable/disable server				gDHCPData->SetDataDHCPServerOn(mDHCPServerOn->GetValue());				gDHCPData->SignalDataChange();				break;			case kDHCPVerboseLoggingCheckBox:				// enable/disable verbose logging				gDHCPData->SetDataDHCPVerboseLogging(mDHCPVerboseLogging->GetValue());				gDHCPData->SignalDataChange();				break;			case msg_HelpButton:											// Create the Help Window				CHelpWindow		*theWindow;				theWindow = (CHelpWindow*)InvokeWindow(kNameHelp, this);				theWindow->Show();				theWindow->LoadTextInWindow(rTEXT_DHCPHelp);				break;			default:				gLogAction->LogText("\p\rCDHCPWindow unknown async message: ", inEventCode);				break;		}	}	catch (const LException& inErr) {		Str31 errStr;		::NumToString( inErr.GetErrorCode(), errStr);		::ParamText(errStr, nil, nil, nil);		UDesktop::Deactivate();		// Alert will swallow Deactivate event		::Alert(ALRT_OTError, nil);		UDesktop::Activate();	} 	catch (...) {		UDesktop::Deactivate();		// Alert will swallow Deactivate event		::Alert(ALRT_Unexpected, nil);		UDesktop::Activate();	}}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	Respond to commandsBooleanCDHCPWindow::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;//	GrafPtr		theWindowP;	LWindow*	theWindow;//	LEditField*	theEditField;//	Str255		str;	switch (inCommand) {		case cmd_SubnetCalculator:			// Create the Subnet Calculator Window			theWindow = InvokeWindow(kNameSubnetCalculator, mSuperCommander);			theWindow->Show();//			theEditField = (LEditField*) this->FindPaneByID( kIPAddressField );//			ThrowIfNil_(theEditField);//			theEditField->GetDescriptor(str);//			((CSubnetCalcWindow*)theWindow)->InvokeSubnetCalcWindow(str);			break;					default:			cmdHandled = CWindow::ObeyCommand(inCommand, ioParam);			break;	}	return cmdHandled;}