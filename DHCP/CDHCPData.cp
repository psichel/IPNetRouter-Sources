// ===========================================================================//	CDHCPData.cp			©1998 Sustainable Softworks, All rights reserved.// ===========================================================================// DHCP Data (corresponds to DHCP window)#include "CDHCPData.h"#include "CDHCPConst.h"#include "CConfigDocument.h"#include "IPSupport.h"#include "MacSupport.h"#include <LString.h>// ---------------------------------------------------------------------------------//		¥ CDHCPData	[Constructor]// ---------------------------------------------------------------------------------CDHCPData::CDHCPData(){	mDHCPStatusArray = nil;	mDHCPStaticCfgArray = nil;	mDHCPDynamicCfgArray = nil;	mDHCPLeaseDataArray = nil;	Init();		// init data arrays		// other init	mDHCPServerOn = false;	mDHCPVerboseLogging = false;	mSeenDHCPServerOn = false;	mSeenDHCPVerboseLogging = false;}// ---------------------------------------------------------------------------------//		¥ ~CDHCPData	[Destructor]// ---------------------------------------------------------------------------------CDHCPData::~CDHCPData(){	if (mDHCPStatusArray) delete mDHCPStatusArray;	if (mDHCPStaticCfgArray) delete mDHCPStaticCfgArray;	if (mDHCPDynamicCfgArray) delete mDHCPDynamicCfgArray;	if (mDHCPLeaseDataArray) delete mDHCPLeaseDataArray;}// ---------------------------------------------------------------------------------//		¥ InitStatus// ---------------------------------------------------------------------------------voidCDHCPData::Init(){	UInt32	count;		// DHCP Status array	if (mDHCPStatusArray == nil) {		// allocate array object if needed		mDHCPStatusArray	= new LArray(sizeof(DHCPStatusEntry_t));		ThrowIfNil_(mDHCPStatusArray);	} else {		// remove any previous elements		count = mDHCPStatusArray->GetCount();		if (count > 0) {			// (inCount, atIndex)			mDHCPStatusArray->RemoveItemsAt(count, 1);		}	}		// DHCP StaticCfg array	if (mDHCPStaticCfgArray == nil) {		// allocate array object if needed		mDHCPStaticCfgArray	= new LArray(sizeof(DHCPStaticCfgEntry_t));		ThrowIfNil_(mDHCPStaticCfgArray);	} else {		// remove any previous elements		count = mDHCPStaticCfgArray->GetCount();		if (count > 0) {			// (inCount, atIndex)			mDHCPStaticCfgArray->RemoveItemsAt(count, 1);		}	}		// DHCP DynamicCfg array	if (mDHCPDynamicCfgArray == nil) {		// allocate array object if needed		mDHCPDynamicCfgArray	= new LArray(sizeof(DHCPDynamicCfgEntry_t));		ThrowIfNil_(mDHCPDynamicCfgArray);	} else {		// remove any previous elements		count = mDHCPDynamicCfgArray->GetCount();		if (count > 0) {			// (inCount, atIndex)			mDHCPDynamicCfgArray->RemoveItemsAt(count, 1);		}	}		// DHCP LeaseData array	if (mDHCPLeaseDataArray == nil) {		// allocate array object if needed		mDHCPLeaseDataArray	= new LArray(sizeof(DHCPLeaseDataEntry_t));		ThrowIfNil_(mDHCPLeaseDataArray);	} else {		// remove any previous elements		count = mDHCPLeaseDataArray->GetCount();		if (count > 0) {			// (inCount, atIndex)			mDHCPLeaseDataArray->RemoveItemsAt(count, 1);		}	}}#pragma mark --- Accessors ---// ---------------------------------------------------------------------------------//		¥ SignalDataChange// ---------------------------------------------------------------------------------// Used to tell our document when data has changedvoidCDHCPData::SignalDataChange(){	SignalDataEvent( DATA_ID(kDHCPStatusData, kDataChange) );}// ---------------------------------------------------------------------------------//		¥ SetDataDHCPServerOn// ---------------------------------------------------------------------------------voidCDHCPData::SetDataDHCPServerOn(Boolean inValue){	if (inValue != mDHCPServerOn) {		mDHCPServerOn = inValue;		SignalDataEvent( DATA_ID(kDHCPStatusData, kDataDHCPServerOn) );	}}BooleanCDHCPData::GetDataDHCPServerOn(){	return mDHCPServerOn;}// ---------------------------------------------------------------------------------//		¥ SetDataDHCPVerboseLogging// ---------------------------------------------------------------------------------voidCDHCPData::SetDataDHCPVerboseLogging(Boolean inValue){	if (inValue != mDHCPVerboseLogging) {		mDHCPVerboseLogging = inValue;		SignalDataEvent( DATA_ID(kDHCPStatusData, kDataDHCPVerboseLogging) );	}}BooleanCDHCPData::GetDataDHCPVerboseLogging(){	return mDHCPVerboseLogging;}#pragma mark - DHCPStatus -// ---------------------------------------------------------------------------------//		¥ SetDataDHCPStatusArray// ---------------------------------------------------------------------------------// Write element to DHCP Status array, insert new element if beyond end of array// and return index of where element was written.ArrayIndexTCDHCPData::SetDataDHCPStatusArray(ArrayIndexT index, DHCPStatusEntry_t* inEntry){	ArrayIndexT	count;	ArrayIndexT	result;		count = mDHCPStatusArray->GetCount();	if (index <= count) {		// assign element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mDHCPStatusArray->AssignItemsAt(1, index, inEntry, sizeof(DHCPStatusEntry_t));	} else {		// insert element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mDHCPStatusArray->InsertItemsAt(1, index, inEntry, sizeof(DHCPStatusEntry_t));	}	SignalDataEvent( DATA_ID(kDHCPStatusData, kDataDHCPArrayOffset + result) );		return result;}// ---------------------------------------------------------------------------------//		¥ GetDataDHCPStatusArray// ---------------------------------------------------------------------------------// Get element from DHCP array at index.// Return false if index is out of range.BooleanCDHCPData::GetDataDHCPStatusArray(ArrayIndexT index, DHCPStatusEntry_t* outEntry){	return mDHCPStatusArray->FetchItemAt(index, outEntry);}// ---------------------------------------------------------------------------------//		¥ RemoveDataDHCPStatusArray// ---------------------------------------------------------------------------------// Remove element from DHCP Status Arra at index.// Return false if index is out of rangeBooleanCDHCPData::RemoveDataDHCPStatusArray(ArrayIndexT index){	ArrayIndexT	i, count;	Boolean result;		count = mDHCPStatusArray->GetCount();	if (index <= count) {		mDHCPStatusArray->RemoveItemsAt(1, index);		for (i=index; i<=count; i++) {			// signal all succeeding elements have changed			SignalDataEvent( DATA_ID(kDHCPStatusData, kDataDHCPArrayOffset + i) );		}		// signal count has changed		SignalDataEvent( DATA_ID(kDHCPStatusData, kDataDHCPCount) );		result = true;	}	else result = false;	return result;}// ---------------------------------------------------------------------------------//		¥ GetDataCountDHCPStatus// ---------------------------------------------------------------------------------//	return number of elements in DHCP arrayArrayIndexTCDHCPData::GetDataCountDHCPStatus(){	return mDHCPStatusArray->GetCount();}// ---------------------------------------------------------------------------------//		¥ SetDataCountDHCPStatus// ---------------------------------------------------------------------------------// Set number of elements in DHCP array.// Remove any elements after specified count and return count of last element// which could be less than the number requested.ArrayIndexTCDHCPData::SetDataCountDHCPStatus(ArrayIndexT count){	ArrayIndexT	num;	ArrayIndexT result;	ArrayIndexT index;		// remove any elements beyond count	result = count;	num = mDHCPStatusArray->GetCount();	if (num < count) {		result = num;	}	else if (num > count) {		// remove extras		// (inCount, atIndex)		mDHCPStatusArray->RemoveItemsAt(num-count, count+1);		// signal corresponding elements have changed		for (index=count+1; index<=num; index++) {			SignalDataEvent( DATA_ID(kDHCPStatusData, kDataDHCPArrayOffset + index) );		}	}		return result;}// ---------------------------------------------------------------------------------//		¥ StatusEntryToString// ---------------------------------------------------------------------------------// Convert DHCP Status Entry to a text string for export.// Returns number of bytes, or zero if text won't fit.UInt32CDHCPData::StatusEntryToText(DHCPStatusEntry_t* inEntry, UInt8* dp, UInt32 maxLen){	UInt32	result;	SInt32	ioPos;	Str255	str;	result = 0;	ioPos = 0;	do {		if (!AppendStr(dp, ioPos, maxLen, kDHCPStatusStr)) break;		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// lease addr		IP_NumToStr(inEntry->leaseAddr, str);		if (!AppendStr(dp, ioPos, maxLen, str)) break;		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// lease state		if (ioPos+8 > maxLen) break;		if (inEntry->leaseState == kLeaseOffered) AppendStr(dp, ioPos, maxLen, kLeaseOfferedStr);		else if (inEntry->leaseState == kLeaseBound) AppendStr(dp, ioPos, maxLen, kLeaseBoundStr);		else if (inEntry->leaseState == kLeaseReleased) AppendStr(dp, ioPos, maxLen, kLeaseReleasedStr);		else if (inEntry->leaseState == kLeaseExpired) AppendStr(dp, ioPos, maxLen, kLeaseExpiredStr);		else if (inEntry->leaseState == kLeaseDeclined) AppendStr(dp, ioPos, maxLen, kLeaseDeclinedStr);		else if (inEntry->leaseState == kLeaseInUse) AppendStr(dp, ioPos, maxLen, kLeaseInUseStr);			if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// last update		::IP_NumToHexStr(inEntry->lastUpdate, str);		if (!AppendStr(dp, ioPos, maxLen, str)) break;		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// expire time		::IP_NumToHexStr(inEntry->expireTime, str);		if (!AppendStr(dp, ioPos, maxLen, str)) break;		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// hardware addr		HW_NumToHexStr(&inEntry->hardwareAddr, str);		if (!AppendStr(dp, ioPos, maxLen, str)) break;		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// clientID		if (inEntry->clientID[0]) {			EncodeHexStr(inEntry->clientID, str);			if (!AppendStr(dp, ioPos, maxLen, str)) break;		}		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;				result = ioPos;	} while (false);	return result;}// ---------------------------------------------------------------------------------//		¥ TextToStatusEntry// ---------------------------------------------------------------------------------// Convert String to DHCP Status Entry for importBooleanCDHCPData::TextToStatusEntry(UInt8* dp, UInt32 start, UInt32 end, DHCPStatusEntry_t* outEntry){	Str255	outStr;	Boolean	result=false;		// initialize out entry	OTMemzero(outEntry, sizeof(DHCPStatusEntry_t));		do {		// +dhcpStatus		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		if (!EqualString(kDHCPStatusStr, outStr, false, false)) break;		// lease addr		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		outEntry->leaseAddr = IP_StrToInt(outStr);		// lease state		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		if (EqualString(kLeaseOfferedStr, outStr, false, false))			outEntry->leaseState = kLeaseOffered;		else if (EqualString(kLeaseBoundStr, outStr, false, false))			outEntry->leaseState = kLeaseBound;		else if (EqualString(kLeaseReleasedStr, outStr, false, false))			outEntry->leaseState = kLeaseReleased;		else if (EqualString(kLeaseExpiredStr, outStr, false, false))			outEntry->leaseState = kLeaseExpired;		else if (EqualString(kLeaseDeclinedStr, outStr, false, false))			outEntry->leaseState = kLeaseDeclined;		else if (EqualString(kLeaseInUseStr, outStr, false, false))			outEntry->leaseState = kLeaseInUse;		// last update		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		outEntry->lastUpdate = HEX_StrToInt(outStr);		// expire time		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		outEntry->expireTime = HEX_StrToInt(outStr);		// hardware addr		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		HW_StrToInt(outStr, &outEntry->hardwareAddr);		// clientID		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		DecodeHexStr(outStr, outEntry->clientID);		result = true;		} while (false);		return result;}#pragma mark - DHCPStaticCfg -// ---------------------------------------------------------------------------------//		¥ SetDataDHCPStaticCfgArray// ---------------------------------------------------------------------------------// Write element to DHCP Status array, insert new element if beyond end of array// and return index of where element was written.ArrayIndexTCDHCPData::SetDataDHCPStaticCfgArray(ArrayIndexT index, DHCPStaticCfgEntry_t* inEntry){	ArrayIndexT	count;	ArrayIndexT	result;		count = mDHCPStaticCfgArray->GetCount();	if (index <= count) {		// assign element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mDHCPStaticCfgArray->AssignItemsAt(1, index, inEntry, sizeof(DHCPStaticCfgEntry_t));	} else {		// insert element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mDHCPStaticCfgArray->InsertItemsAt(1, index, inEntry, sizeof(DHCPStaticCfgEntry_t));	}	SignalDataEvent( DATA_ID(kDHCPStaticCfgData, kDataDHCPArrayOffset + result) );		return result;}// ---------------------------------------------------------------------------------//		¥ GetDataDHCPStaticCfgArray// ---------------------------------------------------------------------------------// Get element from DHCP array at index.// Return false if index is out of range.BooleanCDHCPData::GetDataDHCPStaticCfgArray(ArrayIndexT index, DHCPStaticCfgEntry_t* outEntry){	return mDHCPStaticCfgArray->FetchItemAt(index, outEntry);}// ---------------------------------------------------------------------------------//		¥ GetDataCountDHCPStaticCfg// ---------------------------------------------------------------------------------//	return number of elements in DHCP arrayArrayIndexTCDHCPData::GetDataCountDHCPStaticCfg(){	return mDHCPStaticCfgArray->GetCount();}// ---------------------------------------------------------------------------------//		¥ SetDataCountDHCPStaticCfg// ---------------------------------------------------------------------------------// Set number of elements in DHCP array.// Remove any elements after specified count and return count of last element// which could be less than the number requested.ArrayIndexTCDHCPData::SetDataCountDHCPStaticCfg(ArrayIndexT count){	ArrayIndexT	num;	ArrayIndexT result;	ArrayIndexT index;		// remove any elements beyond count	result = count;	num = mDHCPStaticCfgArray->GetCount();	if (num < count) {		result = num;	}	else if (num > count) {		// remove extras		// (inCount, atIndex)		mDHCPStaticCfgArray->RemoveItemsAt(num-count, count+1);		// signal corresponding elements have changed		for (index=count+1; index<=num; index++) {			SignalDataEvent( DATA_ID(kDHCPStaticCfgData, kDataDHCPArrayOffset + index) );		}	}		return result;}// ---------------------------------------------------------------------------------//		¥ StaticCfgEntryToString// ---------------------------------------------------------------------------------// Convert DHCP StaticCfg Entry to a text string for exportUInt32CDHCPData::StaticCfgEntryToText(DHCPStaticCfgEntry_t* inEntry, UInt8* dp, UInt32 maxLen){	UInt32	result;	SInt32	ioPos;	Str255	str;	result = 0;	ioPos = 0;	do {		if (!AppendStr(dp, ioPos, maxLen, kDHCPStaticCfgStr)) break;		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// interface addr		IP_NumToStr(inEntry->interfaceAddr, str);		if (!AppendStr(dp, ioPos, maxLen, str)) break;		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// lease addr		IP_NumToStr(inEntry->leaseAddr, str);		if (!AppendStr(dp, ioPos, maxLen, str)) break;		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// hardware addr		HW_NumToHexStr(&inEntry->hardwareAddr, str);		if (!AppendStr(dp, ioPos, maxLen, str)) break;		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// clientID		if (inEntry->clientID[0]) {			EncodeHexStr(inEntry->clientID, str);			if (!AppendStr(dp, ioPos, maxLen, str)) break;		}		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		result = ioPos;	} while (false);	return result;}// ---------------------------------------------------------------------------------//		¥ StringToStaticCfgEntry// ---------------------------------------------------------------------------------// Convert String to DHCP Status Entry for importBooleanCDHCPData::TextToStaticCfgEntry(UInt8* dp, UInt32 start, UInt32 end, DHCPStaticCfgEntry_t* outEntry){	Str255	outStr;	Boolean	result=false;		// initialize out entry	OTMemzero(outEntry, sizeof(DHCPStaticCfgEntry_t));		do {		// +dhcpStatic		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		if (!EqualString(kDHCPStaticCfgStr, outStr, false, false)) break;		// interface addr		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		outEntry->interfaceAddr = IP_StrToInt(outStr);		// lease addr		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		outEntry->leaseAddr = IP_StrToInt(outStr);		// hardware addr		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		HW_StrToInt(outStr, &outEntry->hardwareAddr);		// clientID		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		DecodeHexStr(outStr, outEntry->clientID);		result = true;		} while (false);		return result;}#pragma mark - DHCPDynamicCfg -// ---------------------------------------------------------------------------------//		¥ SetDataDHCPDynamicCfgArray// ---------------------------------------------------------------------------------// Write element to DHCP Status array, insert new element if beyond end of array// and return index of where element was written.ArrayIndexTCDHCPData::SetDataDHCPDynamicCfgArray(ArrayIndexT index, DHCPDynamicCfgEntry_t* inEntry){	ArrayIndexT	count;	ArrayIndexT	result;		count = mDHCPDynamicCfgArray->GetCount();	if (index <= count) {		// assign element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mDHCPDynamicCfgArray->AssignItemsAt(1, index, inEntry, sizeof(DHCPDynamicCfgEntry_t));	} else {		// insert element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mDHCPDynamicCfgArray->InsertItemsAt(1, index, inEntry, sizeof(DHCPDynamicCfgEntry_t));	}	SignalDataEvent( DATA_ID(kDHCPDynamicCfgData, kDataDHCPArrayOffset + result) );		return result;}// ---------------------------------------------------------------------------------//		¥ GetDataDHCPDynamicCfgArray// ---------------------------------------------------------------------------------// Get element from DHCP array at index.// Return false if index is out of range.BooleanCDHCPData::GetDataDHCPDynamicCfgArray(ArrayIndexT index, DHCPDynamicCfgEntry_t* outEntry){	return mDHCPDynamicCfgArray->FetchItemAt(index, outEntry);}// ---------------------------------------------------------------------------------//		¥ GetDataCountDHCPDynamicCfg// ---------------------------------------------------------------------------------//	return number of elements in DHCP arrayArrayIndexTCDHCPData::GetDataCountDHCPDynamicCfg(){	return mDHCPDynamicCfgArray->GetCount();}// ---------------------------------------------------------------------------------//		¥ SetDataCountDHCPDynamicCfg// ---------------------------------------------------------------------------------// Set number of elements in DHCP array.// Remove any elements after specified count and return count of last element// which could be less than the number requested.ArrayIndexTCDHCPData::SetDataCountDHCPDynamicCfg(ArrayIndexT count){	ArrayIndexT	num;	ArrayIndexT result;	ArrayIndexT index;		// remove any elements beyond count	result = count;	num = mDHCPDynamicCfgArray->GetCount();	if (num < count) {		result = num;	}	else if (num > count) {		// remove extras		// (inCount, atIndex)		mDHCPDynamicCfgArray->RemoveItemsAt(num-count, count+1);		// signal corresponding elements have changed		for (index=count+1; index<=num; index++) {			SignalDataEvent( DATA_ID(kDHCPDynamicCfgData, kDataDHCPArrayOffset + index) );		}	}		return result;}// ---------------------------------------------------------------------------------//		¥ DynamicCfgEntryToString// ---------------------------------------------------------------------------------// Convert DHCP DynamicCfg Entry to a text string for exportUInt32CDHCPData::DynamicCfgEntryToText(DHCPDynamicCfgEntry_t* inEntry, UInt8* dp, UInt32 maxLen){	UInt32	result;	SInt32	ioPos;	Str31	str;	result = 0;	ioPos = 0;	do {		if (!AppendStr(dp, ioPos, maxLen, kDHCPDynamicCfgStr)) break;		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// interface addr		IP_NumToStr(inEntry->interfaceAddr, str);		if (!AppendStr(dp, ioPos, maxLen, str)) break;		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// start lease addr		IP_NumToStr(inEntry->startLeaseAddr, str);		if (!AppendStr(dp, ioPos, maxLen, str)) break;		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// end lease addr		IP_NumToStr(inEntry->endLeaseAddr, str);		if (!AppendStr(dp, ioPos, maxLen, str)) break;		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;				result = ioPos;	} while (false);	return result;}// ---------------------------------------------------------------------------------//		¥ StringToDynamicCfgEntry// ---------------------------------------------------------------------------------// Convert String to DHCP DynamicCfg Entry for importBooleanCDHCPData::TextToDynamicCfgEntry(UInt8* dp, UInt32 start, UInt32 end, DHCPDynamicCfgEntry_t* outEntry){	Str255	outStr;	Boolean	result=false;		// initialize out entry	OTMemzero(outEntry, sizeof(DHCPDynamicCfgEntry_t));		do {		// +dhcpDynamic		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		if (!EqualString(kDHCPDynamicCfgStr, outStr, false, false)) break;		// interface addr		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		outEntry->interfaceAddr = IP_StrToInt(outStr);		// start lease addr		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		outEntry->startLeaseAddr = IP_StrToInt(outStr);		// end lease addr		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		outEntry->endLeaseAddr = IP_StrToInt(outStr);		result = true;		} while (false);		return result;}#pragma mark - DHCPLeaseData -// ---------------------------------------------------------------------------------//		¥ SetDataDHCPLeaseDataArray// ---------------------------------------------------------------------------------// Write element to DHCP Status array, insert new element if beyond end of array// and return index of where element was written.ArrayIndexTCDHCPData::SetDataDHCPLeaseDataArray(ArrayIndexT index, DHCPLeaseDataEntry_t* inEntry){	ArrayIndexT	count;	ArrayIndexT	result;		count = mDHCPLeaseDataArray->GetCount();	if (index <= count) {		// assign element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mDHCPLeaseDataArray->AssignItemsAt(1, index, inEntry, sizeof(DHCPLeaseDataEntry_t));	} else {		// insert element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mDHCPLeaseDataArray->InsertItemsAt(1, index, inEntry, sizeof(DHCPLeaseDataEntry_t));	}	SignalDataEvent( DATA_ID(kDHCPLeaseDataData, kDataDHCPArrayOffset + result) );		return result;}// ---------------------------------------------------------------------------------//		¥ GetDataDHCPLeaseDataArray// ---------------------------------------------------------------------------------// Get element from DHCP array at index.// Return false if index is out of range.BooleanCDHCPData::GetDataDHCPLeaseDataArray(ArrayIndexT index, DHCPLeaseDataEntry_t* outEntry){	return mDHCPLeaseDataArray->FetchItemAt(index, outEntry);}// ---------------------------------------------------------------------------------//		¥ RemoveDataDHCPLeaseDataArray// ---------------------------------------------------------------------------------// Remove element from DHCP Lease Data at index.// Return false if index is out of rangeBooleanCDHCPData::RemoveDataDHCPLeaseDataArray(ArrayIndexT index){	ArrayIndexT	i, count;	Boolean result;		count = mDHCPLeaseDataArray->GetCount();	if (index <= count) {		mDHCPLeaseDataArray->RemoveItemsAt(1, index);		for (i=index; i<count; i++) {			// signal all succeeding elements have changed			SignalDataEvent( DATA_ID(kDHCPLeaseDataData, kDataDHCPArrayOffset + i) );		}		// signal count has changed		SignalDataEvent( DATA_ID(kDHCPLeaseDataData, kDataDHCPCount) );		result = true;	}	else result = false;	return result;}// ---------------------------------------------------------------------------------//		¥ GetDataCountDHCPLeaseData// ---------------------------------------------------------------------------------//	return number of elements in DHCP arrayArrayIndexTCDHCPData::GetDataCountDHCPLeaseData(){	return mDHCPLeaseDataArray->GetCount();}// ---------------------------------------------------------------------------------//		¥ SetDataCountDHCPLeaseData// ---------------------------------------------------------------------------------// Set number of elements in DHCP array.// Remove any elements after specified count and return count of last element// which could be less than the number requested.ArrayIndexTCDHCPData::SetDataCountDHCPLeaseData(ArrayIndexT count){	ArrayIndexT	num;	ArrayIndexT result;	ArrayIndexT index;		// remove any elements beyond count	result = count;	num = mDHCPLeaseDataArray->GetCount();	if (num < count) {		result = num;	}	else if (num > count) {		// remove extras		// (inCount, atIndex)		mDHCPLeaseDataArray->RemoveItemsAt(num-count, count+1);		// signal corresponding elements have changed		for (index=count+1; index<=num; index++) {			SignalDataEvent( DATA_ID(kDHCPLeaseDataData, kDataDHCPArrayOffset + index) );		}	}		return result;}// ---------------------------------------------------------------------------------//		¥ LeaseDataEntryToString// ---------------------------------------------------------------------------------// Convert DHCP LeaseData Entry to a text string for exportUInt32CDHCPData::LeaseDataEntryToText(DHCPLeaseDataEntry_t* inEntry, UInt8* dp, UInt32 maxLen){	UInt32	result;	SInt32	ioPos;	Str31	str;	UInt32	len, i;	result = 0;	ioPos = 0;	do {		if (inEntry->isEnabled) {			if (!AppendStr(dp, ioPos, maxLen, kDHCPLeaseDataStr)) break;		} else {			if (!AppendStr(dp, ioPos, maxLen, kDHCPmLeaseDataStr)) break;		}		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// interface addr		IP_NumToStr(inEntry->interfaceAddr, str);		if (!AppendStr(dp, ioPos, maxLen, str)) break;		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// net mask		IP_NumToStr(inEntry->netMask, str);		if (!AppendStr(dp, ioPos, maxLen, str)) break;		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// routers			// convert any CRs to commas			{			len = inEntry->routerAddrStr[0];			for (i=1; i<=len; i++) {				if (inEntry->routerAddrStr[i] == '\r') inEntry->routerAddrStr[i] = ',';			}		}		if (inEntry->routerAddrStr[0]) {			if (!AppendStr(dp, ioPos, maxLen, inEntry->routerAddrStr)) break;		}		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// name servers			// convert any CRs to commas			{			len = inEntry->nameServerAddrStr[0];			for (i=1; i<=len; i++) {				if (inEntry->nameServerAddrStr[i] == '\r') inEntry->nameServerAddrStr[i] = ',';			}		}		if (inEntry->nameServerAddrStr[0]) {			if (!AppendStr(dp, ioPos, maxLen, inEntry->nameServerAddrStr)) break;		}		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// default lease time		::IP_NumToHexStr(inEntry->leaseDefaultTime, str);		if (!AppendStr(dp, ioPos, maxLen, str)) break;		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// max lease time		::IP_NumToHexStr(inEntry->leaseMaxTime, str);		if (!AppendStr(dp, ioPos, maxLen, str)) break;		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;		// domain name		if (inEntry->domainNameStr[0]) {			if (!AppendStr(dp, ioPos, maxLen, inEntry->domainNameStr)) break;		}		if (!AppendStr(dp, ioPos, maxLen, kDelimiterStr)) break;			result = ioPos;	} while (false);	return result;}// ---------------------------------------------------------------------------------//		¥ StringToLeaseDataEntry// ---------------------------------------------------------------------------------// Convert String to DHCP LeaseData Entry for importBooleanCDHCPData::TextToLeaseDataEntry(UInt8* dp, UInt32 start, UInt32 end, DHCPLeaseDataEntry_t* outEntry){	Str255	outStr;	UInt32	len, i;	Boolean	result=false;		// initialize out entry	OTMemzero(outEntry, sizeof(DHCPLeaseDataEntry_t));		do {		// +dhcpLeaseOptions		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		if (EqualString(kDHCPLeaseDataStr, outStr, false, false)) outEntry->isEnabled = true;		else if (EqualString(kDHCPmLeaseDataStr, outStr, false, false)) outEntry->isEnabled = false;		else break;		// interface addr		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		outEntry->interfaceAddr = IP_StrToInt(outStr);		// netMask		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		outEntry->netMask = IP_StrToInt(outStr);		// router Addr Str		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		{			len = outStr[0];			for (i=1; i<=len; i++) {				if (outStr[i] == ',') outStr[i] = '\r';			}		}		LString::CopyPStr(outStr, outEntry->routerAddrStr, 255);				// name Server Addr Str		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		{			len = outStr[0];			for (i=1; i<=len; i++) {				if (outStr[i] == ',') outStr[i] = '\r';			}		}		LString::CopyPStr(outStr, outEntry->nameServerAddrStr, 255);		// lease default time		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		outEntry->leaseDefaultTime = HEX_StrToInt(outStr);		// lease max time		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		outEntry->leaseMaxTime = HEX_StrToInt(outStr);		// domain Name Str		start = GetParamString(dp, start, end, kDelimiterChar, outStr);		if (!start) break;		LString::CopyPStr(outStr, outEntry->domainNameStr, 255);				result = true;		} while (false);		return result;}