// =================================================================================//	CSpinButton.cp				©1996 Sustainable Softworks All rights reserved.// =================================================================================// LButton that continously increments a control if held down.  "Spinner"#include "CSpinButton.h"// ---------------------------------------------------------------------------------//		¥ CreateSpinButtonStream [static]// ---------------------------------------------------------------------------------CSpinButton *CSpinButton::CreateSpinButtonStream(	LStream	*inStream ){	return new CSpinButton( inStream );}// ---------------------------------------------------------------------------------//		¥ CSpinButton(LStream*)// ---------------------------------------------------------------------------------CSpinButton::CSpinButton(	LStream	*inStream )		: LButton( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CSpinButton// ---------------------------------------------------------------------------------CSpinButton::~CSpinButton(){}// ---------------------------------------------------------------------------//		¥ HotSpotAction// ---------------------------------------------------------------------------//	Take action during mouse down tracking////	Buttons toggle between two graphics, depending on whether the mouse is//	inside or outside the button.voidCSpinButton::HotSpotAction(	SInt16		/* inHotSpot */,	Boolean		inCurrInside,	Boolean		inPrevInside){									// Draw if cursor moved from IN to OUT									//   or from OUT to IN	if (inCurrInside != inPrevInside) {				ResIDT	theID = mNormalID;	// Pick which graphic to draw		if (inCurrInside) {			theID = mPushedID;		}				FocusDraw();		DrawGraphic(theID);	}		// if just entered button, reset delay and rate tick count	if (inCurrInside && !inPrevInside) {		mMinValue = (SInt32) ::TickCount();		mValue = 0;		}		// if still in button after kRepeatDelay, begin autorepeat	if ( inCurrInside && ((mMinValue + kRepeatDelay) < ::TickCount()) ) {		if (mValue == 0) {			// set rate tick count to begin autorepeat			mValue = (SInt32) ::TickCount();		} else {			// autorepeat every kRepeatRate			if ((mValue + kRepeatRate) < ::TickCount()) {				BroadcastValueMessage();				mValue = (SInt32) ::TickCount();			}		}	}	}