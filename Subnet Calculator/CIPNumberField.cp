// =================================================================================//	CIPNumberField.cp				©1996 Sustainable Softworks All rights reserved.// =================================================================================// Display IP address as a dotted quad in non-editable field// to allow selection, copy, and drag.#include "CIPNumberField.h"// ---------------------------------------------------------------------------------//		¥ CreateIPNumberFieldStream [static]// ---------------------------------------------------------------------------------CIPNumberField *CIPNumberField::CreateIPNumberFieldStream(	LStream	*inStream ){	return new CIPNumberField( inStream );}// ---------------------------------------------------------------------------------//		¥ CIPNumberField(LStream*)// ---------------------------------------------------------------------------------CIPNumberField::CIPNumberField(	LStream	*inStream )		: CIPNumberEditField( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CIPNumberField// ---------------------------------------------------------------------------------CIPNumberField::~CIPNumberField(){}// ---------------------------------------------------------------------------//		¥ FindCommandStatus// ---------------------------------------------------------------------------//	Pass back the status of a CommandvoidCIPNumberField::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	UInt16		&outMark,	Str255		outName){	switch (inCommand) {			case cmd_Cut:				// Cut, Clear disabled		case cmd_Clear:			outEnabled = false;			break;		case cmd_Copy:				// Copy enabled if something is selected			outEnabled = ((**mTextEditH).selStart != (**mTextEditH).selEnd);			break;							case cmd_Paste: 			// Paste disabled			outEnabled = false;			break;				case cmd_SelectAll:			// Check if any characters are present			outEnabled = (**mTextEditH).teLength > 0;			break;					default:			LCommander::FindCommandStatus(inCommand, outEnabled,									outUsesMark, outMark, outName);			break;	}}// ---------------------------------------------------------------------------//		¥ HandleKeyPress// ---------------------------------------------------------------------------//	Handle key stroke directed at an EditField////	Return true if the EditField handles the keystrokeBooleanCIPNumberField::HandleKeyPress(	const EventRecord&	inKeyEvent){	Boolean		keyHandled = true;	EKeyStatus	theKeyStatus = keyStatus_Input;	UInt16		theChar = (UInt16) (inKeyEvent.message & charCodeMask);	LCommander	*theTarget = GetTarget();		if (inKeyEvent.modifiers & cmdKey) {	// Always pass up when the command		theKeyStatus = keyStatus_PassUp;	//   key is down		} else if (mKeyFilter != nil) {			// Filter key stroke											// There should be a key filter.											// Editing keys and undo won't work											// without a proper key filter.		theKeyStatus = (*mKeyFilter)(mTextEditH, (UInt16) inKeyEvent.message,										theChar, inKeyEvent.modifiers);	}		if ((theKeyStatus == keyStatus_PassUp) && (theChar == char_Return)) {		theKeyStatus = keyStatus_Input;		// Special case for return key	}		theKeyStatus = keyStatus_PassUp;		// Disallow editing	StFocusAndClipIfHidden	focus(this);												// Save whether current selection											//   is empty or not	bool beforeSel = (**mTextEditH).selStart == (**mTextEditH).selEnd;		switch (theKeyStatus) {			case keyStatus_Input:				// Check if we are at the character limit				// ### Not two-byte char compatible			if (TooManyCharacters(1)) {				::SysBeep(1);				break;			}						if (mTypingAction == nil) {				mTypingAction = new LTETypingAction(mTextEditH, this, this);				PostAction(mTypingAction);			}			if (mTypingAction != nil) {				mTypingAction->InputCharacter();			} else {				::TEKey((SInt16) theChar, mTextEditH);			}			UserChangedText();			break;					case keyStatus_TEDelete: {			if ((**mTextEditH).selEnd > 0) {				if (mTypingAction == nil) {					mTypingAction = new LTETypingAction(mTextEditH, this, this);					PostAction(mTypingAction);				}				if (mTypingAction != nil) {					mTypingAction->BackwardErase();				} else {					::TEKey(char_Backspace, mTextEditH);				}				UserChangedText();			}			break;		}					case keyStatus_TECursor: {			::TEKey((SInt16) theChar, mTextEditH);			break;		}					case keyStatus_ExtraEdit: {			switch (theChar) {								case char_Home:					::TESetSelect(0, 0, mTextEditH);					break;									case char_End:					::TESetSelect(max_Int16, max_Int16, mTextEditH);					break;									case char_FwdDelete:					if ((**mTextEditH).selStart < (**mTextEditH).teLength) {						if (mTypingAction == nil) {							mTypingAction = new LTETypingAction(mTextEditH, this, this);							PostAction(mTypingAction);						}						if (mTypingAction != nil) {							mTypingAction->ForwardErase();						} else {							if ((**mTextEditH).selStart == (**mTextEditH).selEnd) {								::TESetSelect((**mTextEditH).selStart,									(**mTextEditH).selStart + 1, mTextEditH);							}							::TEDelete(mTextEditH);						}						UserChangedText();					}					break;									default:					keyHandled = LCommander::HandleKeyPress(inKeyEvent);					break;			}			break;		}					case keyStatus_Reject:			::SysBeep(1);			break;					case keyStatus_PassUp:			keyHandled = LCommander::HandleKeyPress(inKeyEvent);			break;	}			// If Target is the same before and after keystroke and		// the selection has changed from empty to not empty or from		// not empty to empty, we need to update menu commands. Some		// command such as Cut and Copy depend on whether or not		// any text is selected.		if ( (theTarget == GetTarget()) &&		 (beforeSel != ((**mTextEditH).selStart == (**mTextEditH).selEnd)) ) {		 		SetUpdateCommandStatus(true);	}		return keyHandled;}