// =================================================================================//	CIPNumberEditField.cp		©1996 Sustainable Softworks All rights reserved.// =================================================================================// EditField IP address as a dotted quad#include "CIPNumberEditField.h"#include "UIPNumKeyFilters.h"#include <LListener.h>#include <LString.h>#include "IPSupport.h"#include "IPRouterCommon.h"#include "AGAColors.h"// ---------------------------------------------------------------------------------//		¥ CIPNumberEditField(LStream*)// ---------------------------------------------------------------------------------CIPNumberEditField::CIPNumberEditField(	LStream	*inStream )		: CEditField( inStream ),		LDragAndDrop( UQDGlobals::GetCurrentPort(), this ){	// Override keyfilter	mKeyFilter = (TEKeyFilterFunc) UIPNumKeyFilters::IPNumField;	// Enable to receive drop	mDropEnabled = true;}// ---------------------------------------------------------------------------------//		¥ ~CIPNumberEditField// ---------------------------------------------------------------------------------CIPNumberEditField::~CIPNumberEditField(){}// ---------------------------------------------------------------------------//		¥ GetValue// ---------------------------------------------------------------------------//	Return the integer value represented by the text of EditField (dotted quad)SInt32CIPNumberEditField::GetValue() const{LStr255 fieldStr;		GetDescriptor(fieldStr);	return IP_StrToInt(fieldStr);}// ---------------------------------------------------------------------------//		¥ GetValue2// ---------------------------------------------------------------------------//	Return second value of address range//	If none specified, same as first address.SInt32CIPNumberEditField::GetValue2() const{LStr255 fieldStr;UInt8	pos;		GetDescriptor(fieldStr);	pos = fieldStr.Find( '-' );	if (pos != 0) fieldStr.Assign( fieldStr, pos+1 );	return IP_StrToInt(fieldStr);}// ---------------------------------------------------------------------------//		¥ GetValueLength// ---------------------------------------------------------------------------//	Return CIDR length if any//	If none specified, return zero//	If "/" but no length,//		determine length from address class and CIDR alignmentUInt8CIPNumberEditField::GetValueLength() const{LStr255 fieldStr;UInt8	pos;SInt32	theValue, theLength;		GetDescriptor(fieldStr);	theValue = IP_StrToInt(fieldStr);	pos = fieldStr.Find( '/' );	if (pos != 0) {		fieldStr.Assign( fieldStr, pos+1, 2);		if ( (fieldStr[0] == 0) || (fieldStr[1] < '0') || (fieldStr[1] > '9') ) {			// found "/" but no length specified			// start with address class			theLength = GetIPAddressClass(theValue, fieldStr);			if (theLength < 8) theLength = 8;			// adjust for CIDR alignment if needed			pos = FindRightBit(theValue);			if (pos > theLength) theLength = pos;			return (UInt8)theLength;		} else {			theLength = fieldStr;		// convert to integer			return (UInt8)theLength;		}	}	return 0;}// ---------------------------------------------------------------------------//		¥ SetValue// ---------------------------------------------------------------------------//	Set EditField to the text representation of an integer IP addressvoidCIPNumberEditField::SetValue(	SInt32	inValue){LStr255 fieldStr;LStr255 numStr;	fieldStr = IP_NumToStr( inValue, fieldStr );	GetDescriptor(numStr);	if (numStr != fieldStr) {		SetDescriptor(fieldStr);		::TESetSelect(0, 0, mTextEditH);	// adjust scrolling		::TESelView(mTextEditH);		::TESetSelect(31, 31, mTextEditH);		if (IsVisible()) {			// Force immediate update for use with Spin button			FocusDraw();			Rect	frame;			CalcLocalFrameRect(frame);			if (mHasBox) ::InsetRect(&frame, 2, 2);			::EraseRect(&frame);			Draw(nil);		}	}}// ---------------------------------------------------------------------------//		¥ SetValueRange// ---------------------------------------------------------------------------//	Set the contents of an EditField to the text representation of an//	integer IP address rangevoidCIPNumberEditField::SetValueRange(SInt32 inValue, SInt32 inValue2){LStr255 fieldStr;LStr255 numStr;	fieldStr = IP_NumToStr( inValue, fieldStr );	fieldStr += "\p-";	IP_NumToStr(inValue2, numStr);	fieldStr += numStr;	GetDescriptor(numStr);	if (numStr != fieldStr) {		SetDescriptor(fieldStr);		::TESetSelect(0, 0, mTextEditH);	// adjust scrolling		::TESelView(mTextEditH);		::TESetSelect(31, 31, mTextEditH);		Refresh();	}}// ---------------------------------------------------------------------------//		¥ SetValueLength// ---------------------------------------------------------------------------//	Set EditField to the text representation of an integer IP address//	and CIDR prefix LengthvoidCIPNumberEditField::SetValueLength(SInt32 inValue, UInt8 inLength){LStr255 fieldStr;LStr255 numStr;	fieldStr = IP_NumToStr( inValue, fieldStr );	fieldStr += "\p/";	NumToString(inLength, numStr);	fieldStr += numStr;	GetDescriptor(numStr);	if (numStr != fieldStr) {		SetDescriptor(fieldStr);		::TESetSelect(0, 0, mTextEditH);	// adjust scrolling		::TESelView(mTextEditH);		::TESetSelect(31, 31, mTextEditH);//		Refresh();		// Force immediate update for use with Spin button		Rect	frame;		CalcLocalFrameRect(frame);		if (mHasBox) ::InsetRect(&frame, 2, 2);		::EraseRect(&frame);		Draw(nil);	}}// ---------------------------------------------------------------------------//		¥ Click// ---------------------------------------------------------------------------//	Override Pane Click function to handle Drag And DropvoidCIPNumberEditField::Click(	SMouseDownEvent	&inMouseDown){	// Get the selection range if any	UInt8	startPos, endPos;	startPos = (**mTextEditH).selStart;	endPos = (**mTextEditH).selEnd;	// Test for drag gesture	if ( DragAndDropIsPresent() && IsTarget() &&										// there is a selection to drag		((startPos == 0) && (endPos >= (**mTextEditH).teLength - 1)) &&		::WaitMouseMoved(inMouseDown.macEvent.where) ) {	// begin drag		// Focus.		FocusDraw();		// get the drag frame		Rect	theFrame;		CalcLocalFrameRect( theFrame );		// get the data		Str255	theString;		GetDescriptor( theString );		// Create the drag task.		LDragTask	theDragTask( inMouseDown.macEvent, theFrame,						1, 'TEXT', &theString[1], StrLength(theString), 0 );		// Check for a drop in the trash.		if ( theDragTask.DropLocationIsFinderTrash() ) {			// just ignore for now		}		} else {		// call inherited Click for default behavior		LEditField::Click(inMouseDown);	}}// ---------------------------------------------------------------------------//		¥ ClickSelf// ---------------------------------------------------------------------------//	Override to select all when field is activatedvoidCIPNumberEditField::ClickSelf(	const SMouseDownEvent	&inMouseDown){	UInt8	startPos, endPos;				// [PAS]	Boolean	newTarget = false;				// [PAS]	if (!IsTarget()) {				// If not the Target, clicking in an									//   EditField makes it the Target.									// Since TEClick will set a new selection									//   range, clear the current selection									//   range to avoid an ugly flash.		FocusDraw();		::TESetSelect(0, 0, mTextEditH);		SwitchTarget(this);		newTarget = true;					// [PAS]	}		if (IsTarget()) {		FocusDraw();		AdjustTextWidth(true);		::TEClick(inMouseDown.whereLocal,					((inMouseDown.macEvent.modifiers & shiftKey) != 0),					mTextEditH);		AdjustTextWidth(false);		// Keep the new selection range if any				startPos = (**mTextEditH).selStart;	// [PAS]		endPos = (**mTextEditH).selEnd;		// [PAS]		if (startPos != endPos) newTarget = false;	// [PAS]	}	if (newTarget) SelectAll();				// [PAS]}// ---------------------------------------------------------------------------------//		¥ ItemIsAcceptable// ---------------------------------------------------------------------------------BooleanCIPNumberEditField::ItemIsAcceptable(	DragReference	inDragRef,	ItemReference	inItemRef ){	// Make sure the field is enabled and	// there's text in the drag data.	FlavorFlags	theFlags;	return IsEnabled() && mDropEnabled &&		(::GetFlavorFlags( inDragRef, inItemRef, 'TEXT', &theFlags ) == noErr);}voidCIPNumberEditField::EnableDrop(){	mDropEnabled = true;}voidCIPNumberEditField::DisableDrop(){	mDropEnabled = false;}// ---------------------------------------------------------------------------------//		¥ HiliteDropArea// ---------------------------------------------------------------------------------voidCIPNumberEditField::HiliteDropArea(	DragReference	inDragRef ){	// Get the frame rect.	Rect	theRect;	CalcLocalFrameRect( theRect );	// Show the drag hilite in the drop area.	RgnHandle	theRgnH = ::NewRgn();	::RectRgn( theRgnH, &theRect );	::ShowDragHilite( inDragRef, theRgnH, true );	::DisposeRgn( theRgnH );}// ---------------------------------------------------------------------------------//		¥ ReceiveDragItem// ---------------------------------------------------------------------------------voidCIPNumberEditField::ReceiveDragItem(	DragReference	inDragRef,	DragAttributes	inDragAttrs,	ItemReference	inItemRef,	Rect			&inItemBounds ){#pragma unused( inDragAttrs, inItemBounds )	FlavorFlags	theFlags;	ThrowIfOSErr_( ::GetFlavorFlags( inDragRef, 		inItemRef, 'TEXT', &theFlags ) );	// Get the data.	Size	theDataSize = 255;	Str255	theString;	ThrowIfOSErr_( ::GetFlavorData( inDragRef, inItemRef,		'TEXT', &theString[1], &theDataSize, 0 ) );		// Get the data size and set the string length.	ThrowIfOSErr_( ::GetFlavorDataSize( inDragRef,		inItemRef, 'TEXT', &theDataSize ) );	theString[0] = theDataSize;	// "copy" entire EditField only (no "move")		// trim the string to remove extraneous characters	UInt8	startPos, endPos;	for (startPos = 1; startPos <= theDataSize; startPos++) {		if	(			((theString[startPos] >= '0') && (theString[startPos] <= '9')) ||			(theString[startPos] == '.') ||			(theString[startPos] == '/')		) break;	}	for (endPos = theDataSize; endPos >= startPos; endPos--) {		if	(			((theString[endPos] >= '0') && (theString[endPos] <= '9')) ||			(theString[endPos] == '.') ||			(theString[endPos] == '/')		) break;	}	// set new length	startPos -= 1;	theString[startPos] = endPos - startPos;	// update EditField (performs refresh)	SetDescriptor( theString );		// tell the window we dropped in a new value	BroadcastMessage( msg_FieldActionKey, this );}