// =================================================================================//	CRoutesWindow.cp				©1996 Sustainable Softworks All rights reserved.// =================================================================================//	Configure Routes Window#include "CRoutesWindow.h"#include "CRoutesConst.h"#include "CResidentIfInfo.h"#include "CRoutesData.h"#include "CRoutesAction.h"#include "CGatewayData.h"#include "CIPNumberEditField.h"#include "IPRouterCommon.h"#include "CSubnetCalcWindow.h"#include "CHelpWindow.h"//#include "CPingWindow.h"//#include "CRoutesTable.h"#include "CMultiCaption.h"#include "MacSupport.h"#include "IPSupport.h"#include "CLogAction.h"#include <UReanimator.h>#include <LString.h>#include <LToggleButton.h>#include <LPreferencesFile.h>#include <UResourceMgr.h>#include <OpenTransport.h>// Globalsextern CLogAction*			gLogAction;extern CResidentIfInfo*		gResInfo;extern CRoutesData*			gRoutesData;extern CRoutesAction*		gRoutesAction;extern CGatewayData*		gGatewayData;// ---------------------------------------------------------------------------------//		¥ CRoutesWindow(LStream*)// ---------------------------------------------------------------------------------CRoutesWindow::CRoutesWindow(	LStream	*inStream )		: CWindow( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CRoutesWindow// ---------------------------------------------------------------------------------CRoutesWindow::~CRoutesWindow(){	// disconnect from routes data	//gRoutesData->RemoveListener(this);}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------//	Finish creating the Routes window.voidCRoutesWindow::FinishCreateSelf(){	// setup up IP interface display table	// get the table view	mRoutesTable = (CRoutesTable*) this->FindPaneByID( kRoutesTablePane );	ThrowIfNil_( mRoutesTable );	mRoutesTable->SetWindow(this);	// tell table it's parent window	// set column widths (inWidth, inFromCol, inToCol)	mRoutesTable->SetColWidth(120, 1, 1);	mRoutesTable->SetColWidth(110, 2, 2);	mRoutesTable->SetColWidth(90, 3, 3);	mRoutesTable->SetColWidth(120, 4, 4);	// setup and init comment data	mRoutesTable->SetCommentDataSize(kCommentDataSize, 1);	// setup up table captions	CMultiCaption	*theCaption;	theCaption = (CMultiCaption*) this->FindPaneByID( kRoutesTableCaptionPane );	ThrowIfNil_( theCaption );	// customize the caption widths to match table outline	theCaption->SetColWidth(120, 1, 1);	theCaption->SetColWidth(110, 2, 2);	theCaption->SetColWidth(90, 3, 3);	theCaption->SetColWidth(120, 4, 4);		// Link the window (the listener) with the controls in	// Link the window (the listener) with the controls in	// the window (the broadcasters).	UReanimator::LinkListenerToControls(		(CRoutesWindow *)this, this, rRidL_RoutesWindow );	// setup Route Type popup	mRouteTypePopup = (LStdPopupMenu*)this->FindPaneByID( kRouteTypePopup );	ThrowIfNil_(mRouteTypePopup);	MenuHandle theMenuH;	theMenuH = mRouteTypePopup->GetMacMenuH();	// count how many items we have and set max value	mRouteTypePopupMax = ::CountMItems(theMenuH);	mRouteTypePopup->SetMaxValue(mRouteTypePopupMax);	mRouteTypePopup->SetValue(0);	// show default value	mRouteTypePopup->SetValue(1);	// setup pointer to status caption	mStatusCaption = (LCaption*)FindPaneByID( kRtStatusCaption );	ThrowIfNil_(mStatusCaption);	// load the IP Routes table	gRoutesAction->UpdateRoutesData();	UpdateTable();	// update Routes entry in Window	RouteEntry_t routesEntry;	gRoutesData->GetDataRouteEntry(&routesEntry);	DisplayRouteEntry(&routesEntry);	// connect to interfaces data	gRoutesData->AddListener(this);}// ---------------------------------------------------------------------------//		¥ HandleKeyPress// ---------------------------------------------------------------------------//	Handle <Return>, <Enter> passed up from an EditField////	Return true if the Window handles the keystrokeBooleanCRoutesWindow::HandleKeyPress(	const EventRecord&	inKeyEvent){	Boolean		keyHandled = true;	LControl	*keyButton = nil;	SInt16		theKey = inKeyEvent.message & charCodeMask;	SInt16		menuChoice;	switch (theKey) {			case char_Enter:		case char_Return:			keyButton =  (LControl*) FindPaneByID(kAddButton);			break;		case char_UpArrow:			if (inKeyEvent.modifiers & cmdKey) {				menuChoice = mRouteTypePopup->GetValue();				if (menuChoice > 1) {					menuChoice -= 1;					mRouteTypePopup->SetValue(menuChoice);				}			}			break;		case char_DownArrow:			if (inKeyEvent.modifiers & cmdKey) {				menuChoice = mRouteTypePopup->GetValue();				if (menuChoice < mRouteTypePopupMax) {					menuChoice += 1;					mRouteTypePopup->SetValue(menuChoice);				}			}			break;		default:			keyHandled = CWindow::HandleKeyPress(inKeyEvent);			break;	}				if (keyButton != nil) {		keyButton->SimulateHotSpotClick(kControlButtonPart);		keyHandled = true;	}		return keyHandled;}// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------voidCRoutesWindow::ListenToMessage(	MessageT	inMessage,	void		*ioParam ){#pragma unused (ioParam)	CIPNumberEditField* theEditField;	RouteEntry_t		routesEntry;	SInt32				routeType;	OTResult			result;	try {		switch ( inMessage ) {			case msg_SignalDataEvent:				// handle change to routes Data				UInt32 dataID = *(UInt32*)ioParam;				if (dataID == DATA_ID(kRoutesData, kDataRouteEntry)) {					// Routes parameter data has changed										gRoutesData->GetDataRouteEntry(&routesEntry);					DisplayRouteEntry(&routesEntry);				}				else if (dataID>>16 == kRoutesData) {					// a row in the routes array has changed					TableIndexT	row;					row = dataID & 0xFFFF;					if (row > kDataRoutesArrayOffset) {						row -= kDataRoutesArrayOffset;						// try to get data for this row						if (gRoutesData->GetDataRoutesArray(row, &routesEntry)) {							// got it, update table and refresh display if needed							mRoutesTable->SetRouteEntry(row, &routesEntry);						}						else {							// no data, row must have been deleted							mRoutesTable->ClearRow(row);						}					}				}				break;						case msg_AddButton:			case msg_RemoveButton:				// zero-out routesEntry				bzero((UInt8*)&routesEntry, sizeof(RouteEntry_t));				// add or delete?				if (inMessage == msg_AddButton) routesEntry.addRoute = true;				routesEntry.isDone = false;									// Get destination address				theEditField = (CIPNumberEditField*)FindPaneByID( kDestinationField );					ThrowIfNil_(theEditField);				routesEntry.destination = theEditField->GetValue();				UInt8 prefixLen = theEditField->GetValueLength();				routesEntry.netMask = 0xFFFFFFFF << (32-prefixLen);				// Get gateway address				theEditField = (CIPNumberEditField*)FindPaneByID( kGatewayField );					ThrowIfNil_(theEditField);				routesEntry.gateway = theEditField->GetValue();				// Get route type				routeType = mRouteTypePopup->GetValue();				switch (routeType) {					case kTypeNetwork:						routesEntry.routeType = IRE_NET;						break;					case kTypeDefaultGateway:						routesEntry.routeType = IRE_GATEWAY;						break;					case kTypeHost:						routesEntry.routeType = IRE_ROUTE_ASSOC;						break;					case kTypeDirect:						routesEntry.routeType = IRE_RESOLVER;						break;					case kTypePointToPoint:						routesEntry.routeType = IRE_SUBNET;						break;				}				// Wamnet				routesEntry.wamnet = false;				// do command				result = gRoutesAction->DoRouteEntry(&routesEntry, true);				IoctlResponse(result);				gRoutesData->SignalDataChange();				break;									case msg_HelpButton:											// Create the Help Window				CHelpWindow		*theWindow;				theWindow = (CHelpWindow*)InvokeWindow(kNameHelp, this);				theWindow->Show();				theWindow->LoadTextInWindow(rTEXT_ConfigureRtHelp);				break;							case kRouteTypePopup:				// Get route type and initialize input fields				routeType = mRouteTypePopup->GetValue();				if (routeType == kTypeDefaultGateway) {					// Set destination address to empty					theEditField = (CIPNumberEditField*)FindPaneByID( kDestinationField );						ThrowIfNil_(theEditField);					theEditField->SetDescriptor("\p");				}				break;		}	}	catch (const LException& inErr) {		Str31 errStr;		::NumToString( inErr.GetErrorCode(), errStr);		::ParamText(errStr, nil, nil, nil);		UDesktop::Deactivate();		// Alert will swallow Deactivate event		::Alert(ALRT_OTError, nil);		UDesktop::Activate();	} 	catch (...) {		gLogAction->LogText("\p\rCRoutesWindow::ListenToMessage unexpected Exception");		::SysBeep(1);	}}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	Respond to commandsBooleanCRoutesWindow::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;	LWindow		*theWindow;	LEditField*	theEditField;	Str255		str;	switch (inCommand) {		case cmd_SubnetCalculator:			// Create the Subnet Calculator Window			theWindow = InvokeWindow(kNameSubnetCalculator, mSuperCommander);			theWindow->Show();			theEditField = (LEditField*) this->FindPaneByID( kGatewayField );			ThrowIfNil_(theEditField);			theEditField->GetDescriptor(str);			((CSubnetCalcWindow*)theWindow)->InvokeSubnetCalcWindow(str);			break;					default:			cmdHandled = CWindow::ObeyCommand(inCommand, ioParam);			break;	}	return cmdHandled;}#pragma mark --- Routes Display ---// ---------------------------------------------------------------------------------//		¥ UpdateTable// ---------------------------------------------------------------------------------//	Update Routes Table from data objectvoidCRoutesWindow::UpdateTable(){	ArrayIndexT		num;	ArrayIndexT		index;	RouteEntry_t	routesEntry;		num = gRoutesData->GetDataCount();	for (index=1; index<=num; index++) {		if (gRoutesData->GetDataRoutesArray(index, &routesEntry)) {			mRoutesTable->SetRouteEntry(index, &routesEntry);		} else {			mRoutesTable->ClearRow(index);		}	}}// ---------------------------------------------------------------------------------//		¥ DisplayRouteEntry// ---------------------------------------------------------------------------------//	Display routes entry in window edit fieldsvoidCRoutesWindow::DisplayRouteEntry(RouteEntry_t* inRouteEntry){	CIPNumberEditField* theEditField;	// try to match the RouteType popupMenu	do {		if (inRouteEntry->routeType == IRE_NET) {			mRouteTypePopup->SetValue(kTypeNetwork);		}		else if (inRouteEntry->routeType == IRE_GATEWAY) {			mRouteTypePopup->SetValue(kTypeDefaultGateway);		}		else if (inRouteEntry->routeType == IRE_ROUTE_ASSOC) {			mRouteTypePopup->SetValue(kTypeHost);		}		else if (inRouteEntry->routeType == IRE_RESOLVER) {			mRouteTypePopup->SetValue(kTypeDirect);		}		else if (inRouteEntry->routeType == IRE_SUBNET) {			mRouteTypePopup->SetValue(kTypePointToPoint);		}		else break;		// no match		// transfer dest and gateway		theEditField = (CIPNumberEditField*)FindPaneByID( kDestinationField );			ThrowIfNil_(theEditField);		theEditField->SetValue(inRouteEntry->destination);		if (inRouteEntry->netMask) {			UInt8 prefixLen;			prefixLen = FindRightBit(inRouteEntry->netMask, 32);			theEditField->SetValueLength(inRouteEntry->destination, prefixLen);		}		theEditField = (CIPNumberEditField*)FindPaneByID( kGatewayField );			ThrowIfNil_(theEditField);		theEditField->SetValue(inRouteEntry->gateway);			} while (false);}// ---------------------------------------------------------------------------------//		¥ IoctlResponse// ---------------------------------------------------------------------------------//	IoctlResponse - an ioctl completed process the resultvoidCRoutesWindow::IoctlResponse(long inResult){	switch (inResult) {		case 3:				// get NDD forwarding unknown result?		case 0:				// no error			mStatusCaption->SetDescriptor("\pOK");			break;		case kOTNotFoundErr:			mStatusCaption->SetDescriptor("\pkOTNotFoundErr.");			break;				case kEINVALErr:			mStatusCaption->SetDescriptor("\pkEINVALErr - Invalid parameter.");			break;		case kOTDuplicateFoundErr:					mStatusCaption->SetDescriptor("\pkOTDuplicateFoundErr.");			break;		case kEBUSYErr:			mStatusCaption->SetDescriptor("\pkEBUSYErr - Device or resource busy.");			break;		case kENETUNREACHErr:			mStatusCaption->SetDescriptor("\pkENETUNREACHErr - Network is unreachable.");			break;		case kENXIOErr:			mStatusCaption->SetDescriptor("\pNo such device or address.");			break;		default:			{				LStr255	status;				status = "\pioctl unexpected result code: ";				Str32 str;				NumToString(inResult, str);				status += str;				mStatusCaption->SetDescriptor( status );			}			break;	}	// end switch}