// =================================================================================//	CRoutesAction.cp				©1996 Sustainable Softworks All rights reserved.// =================================================================================//	Configure Routes Window#include "CompileFlags.h"#include "CRoutesAction.h"#include "CRoutesConst.h"#include "CConfigDocument.h"#include "CResidentIfInfo.h"#include "CRoutesData.h"#include "CGatewayData.h"#include "CInterfacesAction.h"#include "CProxyControl.h"#include "IPRouterCommon.h"#include "MacSupport.h"#include "IPSupport.h"#include "CLogAction.h"#include <UReanimator.h>#include <LString.h>#include <LPreferencesFile.h>#include <UResourceMgr.h>#include "CTurboUDPEndpoint.h"#include <OpenTransport.h>#include <OpenTptInternet.h>#include <OpenTptLinks.h>#include <modnames.h>			// names of the standard OT modules.#include "MyOTInetMultilink.h"#include "MyRoute.h"				// raw Mentat include file#include <miioccom.h>// Globalsextern CLogAction*			gLogAction;extern CResidentIfInfo*		gResInfo;extern CInterfacesAction*	gInterfacesAction;extern CRoutesData*			gRoutesData;extern CGatewayData*		gGatewayData;extern CInterfacesData*		gInterfacesData;extern CProxyControl*		gProxyControl;// ---------------------------------------------------------------------------------//		¥ CRoutesAction()// ---------------------------------------------------------------------------------CRoutesAction::CRoutesAction(){	// more initialization	mStream = nil;	mIoctlState = kIoctlReady;	mIsListener = false;	mNeedInit = true;}// ---------------------------------------------------------------------------------//		¥ ~CRoutesAction// ---------------------------------------------------------------------------------CRoutesAction::~CRoutesAction(){	Terminate();}// ---------------------------------------------------------------------------------//		¥ Terminate// ---------------------------------------------------------------------------------voidCRoutesAction::Terminate(){		// Release the Stream we created	if (mStream != nil) {		::OTStreamClose(mStream);		mStream = nil;	}	mNeedInit = true;}// ---------------------------------------------------------------------------------//		¥ Init// ---------------------------------------------------------------------------------voidCRoutesAction::Init(){	mNeedInit = false;}// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------voidCRoutesAction::ListenToMessage(	MessageT	inMessage,	void		*ioParam ){#pragma unused (ioParam)	try {		switch ( inMessage ) {//			case msg_SnmpData://				SnmpData((SnmpDataMsg_t*)ioParam);//				break;			// Endpoint notifications			case kOTProviderWillClose:				break;			case msg_BroadcasterDied:				break;			default:				gLogAction->LogText("\p\rCRoutesAction unknown async message type: ", inMessage);				break;		}	}	catch (const LException& inErr) {		gLogAction->LogText("\p\rCRoutesAction::ListenToMessage unexpected result from OT: ", inErr.GetErrorCode());		::SysBeep(1);		gLogAction->LogText("\p\r Is TCP/IP configured and OTModl$Proxy in your Extenions Folder?");	} 	catch (...) {		gLogAction->LogText("\p\rCRoutesAction::ListenToMessage unexpected Exception");		::SysBeep(1);	}}#pragma mark --- Configure Routing ---// ---------------------------------------------------------------------------------//		¥ LoadRtConfig// ---------------------------------------------------------------------------------//	Add or Delete routes to match mConfigDataSInt32CRoutesAction::LoadRtConfig(CRoutesData* inRoutesData){	OTResult	result = kOTNoError;	SInt32		numTableE, numConfigE;	TableIndexT	row;	ArrayIndexT index;	SInt32		match;	if (mNeedInit) Init();		do {			RouteEntry_t		rtConfigEntry, rtTableEntry;		// setup access to mConfigData		if (inRoutesData == nil) break;		// nothing to configure		numConfigE = inRoutesData->GetDataCount();		if (numConfigE == 0) break;			// nothing to configure			// Make sure routes data is current!//		UpdateRoutesData();				// setup access to rtTable		numTableE = gRoutesData->GetDataCount();		// Check each existing route to see if it is included		// in the configuration being loaded.  If so, mark		// it as already present, if not try to remove it.				// for each table row from last to first (an existing route)		for (row=numTableE; row>=1; row--) {			// get interface entry from table			if ( !gRoutesData->GetDataRoutesArray(row, &rtTableEntry) ) continue;			// try to match in config			match = inRoutesData->MatchRouteInConfig(&rtTableEntry, inRoutesData, &rtConfigEntry);			if (match == kEntryMatch) {				// yes, mark config as already done				//rtConfigEntry.isDone = true;				//inRoutesData->SetDataRoutesArray(index, &rtConfigEntry);				// transfer WAM!NET parameter if present				if (rtConfigEntry.wamnet) {					rtTableEntry.wamnet = rtConfigEntry.wamnet;					gRoutesData->SetDataRoutesArray(row, &rtTableEntry);				}			}			if ((match == kEntryNoMatch) && !gGatewayData->GetDataAddOnly()) {				// no match was found				// does gateway match DHCP address?				if (gResInfo->mDHCPNet.mask) {					if ((rtTableEntry.gateway & gResInfo->mDHCPNet.mask) ==						(gResInfo->mDHCPNet.address & gResInfo->mDHCPNet.mask)) continue;	// don't remove				}				// try to remove existing route				rtTableEntry.addRoute = false;				result = DoRouteEntry(&rtTableEntry, false);				if (result != kOTNoError) {					// command failed, routes entry has already been updated					// summarize for user					gLogAction->LogText("\p\rRestore routes detected one or more errors");				}			}		}				//if (result == kOTNoError) {		if (true) {			// For each route in the configuration being loaded that is not			// already present, try to create it.					for (index=1; index<=numConfigE; index++) {				// get interface entry from config being loaded				if ( !inRoutesData->GetDataRoutesArray(index, &rtConfigEntry) ) continue;				// already present?				match = gRoutesData->MatchRouteInConfig(&rtConfigEntry, gRoutesData, &rtTableEntry);				if (match != kEntryMatch) {					// does gateway match old DHCP address?					if (gResInfo->mDHCPNet.mask && gResInfo->mDHCPSavedNet.mask) {						if ((rtConfigEntry.gateway & gResInfo->mDHCPSavedNet.mask) ==							(gResInfo->mDHCPSavedNet.address & gResInfo->mDHCPSavedNet.mask)) continue;					}					// try to create route					result = DoRouteEntry(&rtConfigEntry, false);					if (result != kOTNoError) {						// command failed, routes entry has already been updated						// summarize for user						gLogAction->LogText("\p\rRestore routes detected one or more errors");					}				}				}		}				UpdateRoutesData();	} while (false);		return result;}// ---------------------------------------------------------------------------------//		¥ UpdateRoutesData// ---------------------------------------------------------------------------------//	Update Routes Data from IP moduleOTResultCRoutesAction::UpdateRoutesData(){	OTResult	result = kOTNoError;	StreamRef	ipStream = nil;		// Stream to IP module	RouteEntry_t	routeEntry;	UInt8			retryCount;	// temporary object to store existing routes with WAM!NET parameter	CRoutesData		tRoutesData;	RouteEntry_t	tRouteEntry;	ArrayIndexT		count, tCount, i;	do {		struct strioctl	stri;		char	ndCommandBuffer[kNDCommandLength];		UInt32	realDataSize;			// copy existing routes with WAM!NET parameter		tCount = 0;		tRoutesData.Init();		// start with our own routesEntry		gRoutesData->GetDataRouteEntry(&routeEntry);		if (routeEntry.wamnet) {			tCount += 1;			tRoutesData.SetDataRoutesArray(tCount, &routeEntry);		}		// continue with Routes Array		count = gRoutesData->GetDataCount();		for (i=1; i<=count; i++) {			gRoutesData->GetDataRoutesArray(i, &routeEntry);			if (routeEntry.wamnet) {				tCount += 1;				tRoutesData.SetDataRoutesArray(tCount, &routeEntry);			}		}		//	Create a tcp endpoint to force the InetConfigurator to fire		//	(blocks until TCP/IP is ready)		result = gProxyControl->AsyncOpenAndClose();		if (result != noErr) {			gLogAction->LogText("\p\rUpdateRoutesData unexpected result initializing OT: ", result);			break;		}		// create a raw stream to IP.  Do this each time for reliability.		ipStream = ::OTStreamOpen(MI_IP_NAME, 0, &result);		if (result != kOTNoError) {			gLogAction->LogText("\p\rUpdateRoutesData unexpected result creating raw stream to IP: ", result);			break;		}					// Switch the stream in sync/blocking mode.  To make the		// code easier, we're going to do this synchronously.		(void) ::OTStreamSetBlocking(ipStream);		(void) ::OTStreamSetSynchronous(ipStream);		// Copy the name of the ND variable we're trying to get into our buffer.		::OTStrCopy(ndCommandBuffer, IP_IRE_STATUS);		// First get the size of data buffer we need to allocate by		// doing the ioctl with a small buffer and examining the result.		// Initialise the I_STR ioctl structure.		stri.ic_cmd = ND_GET;		stri.ic_timout = 0;		stri.ic_len = kNDCommandLength;		stri.ic_dp = ndCommandBuffer;		// Send the ioctl.		result = OTStreamIoctl(ipStream, I_STR, &stri);		if (result < 0) break;	// return error		if (result <= kNDCommandLength) {			// No data, empty table.			gRoutesData->SetDataCount(0);			result = kOTNoError;			break;		}		retryCount = 3;		while ((result > kNDCommandLength) && (retryCount > 0)) {			retryCount -= 1;			// The first ioctl returned a positive number telling			// us how big the data returned was.  We turn around			// around make the ioctl again, this time passing			// in an appropriately sized buffer.			realDataSize = result + 2048;					StHandleBlock NDReport(realDataSize, false, false);			Handle dataH;			dataH = NDReport.Get();			if (dataH == nil) {				result = memFullErr;				break;					}						// begin scope for locked handle			{				StHandleLocker lock((Handle)dataH);									OTStrCopy(*dataH, IP_IRE_STATUS);				// Initialise the I_STR ioctl structure.				stri.ic_cmd = ND_GET;				stri.ic_timout = 0;				stri.ic_len = realDataSize;				stri.ic_dp = *dataH;				// Send the ioctl.				result = OTStreamIoctl(ipStream, I_STR, &stri);				if (result == kOTNoError) {					// We have the ND report,					// initialize to examine each line					UInt32 start, end, eol, pos;					UInt32 source;					UInt8* dp;					Str63 str;					ArrayIndexT row;					dp = (UInt8*)*dataH;					start = 0;					end = stri.ic_len;	// actual length of report					eol = FindByte(0, dp, start, end);	// end of line					// log each line for debugging if requested					if (false) {						gLogAction->LogCText((char*)&dp[start]);					}					start = eol + 1;	// skip first line of headings					eol = FindByte(0, dp, start, end);	// end of line					row = 0;					while (eol > 0) {						// log each line for debugging if requested						if (false) {							gLogAction->LogCText((char*)&dp[start]);						}						// extract data from line						do {							// initialize addRoute							bzero((UInt8*)&routeEntry, sizeof(RouteEntry_t));							routeEntry.addRoute = true;							routeEntry.isDone = false;								// Mentat IPIF							pos = GetParamString(dp, start, eol, str);							if (pos) routeEntry.mentatIRE = HEX_StrToInt(str);							else break;							start = pos;								// rfq							pos = GetParamString(dp, start, eol, str);							if (!pos) break;							start = pos;								// stq							pos = GetParamString(dp, start, eol, str);							if (!pos) break;							start = pos;								// destination (addr)							pos = GetParamString(dp, start, eol, str);							if (pos) routeEntry.destination = IP_StrToInt(str);							else break;							start = pos;								// mask							pos = GetParamString(dp, start, eol, str);							if (pos) routeEntry.netMask = HEX_StrToInt(str);							else break;							start = pos;								// src							pos = GetParamString(dp, start, eol, str);							if (pos) source = IP_StrToInt(str);							else break;							start = pos;								// gateway (addr)							pos = GetParamString(dp, start, eol, str);							if (pos) routeEntry.gateway = IP_StrToInt(str);							else break;							if (routeEntry.gateway == 0) routeEntry.gateway = source;							gInterfacesData->InterfaceAddrToName(source, routeEntry.interfaceName);							start = pos;								// mxfrg							pos = GetParamString(dp, start, eol, str);							if (!pos) break;							start = pos;								// rtt							pos = GetParamString(dp, start, eol, str);							if (!pos) break;							start = pos;								// ref							pos = GetParamString(dp, start, eol, str);							if (!pos) break;							start = pos;								// in/out/forward							pos = GetParamString(dp, start, eol, str);							if (!pos) break;							start = pos;								// route type							pos = GetParamString(dp, start, eol, str);							if (pos) {								if (::EqualString(str, kStrIRE_BROADCAST, false, false)) {									routeEntry.routeType = IRE_BROADCAST;								} else								if (::EqualString(str, kStrIRE_LOOPBACK, false, false)) {									routeEntry.routeType = IRE_LOOPBACK;								} else								if (::EqualString(str, kStrIRE_MULTICAST, false, false)) {									routeEntry.routeType = IRE_MULTICAST;								} else								if (::EqualString(str, kStrIRE_LOCAL, false, false)) {									routeEntry.routeType = IRE_LOCAL;								} else								if (::EqualString(str, kStrIRE_ROUTE, false, false)) {									routeEntry.routeType = IRE_ROUTE;								} else								if (::EqualString(str, kStrIRE_GATEWAY, false, false)) {									routeEntry.routeType = IRE_GATEWAY;								} else								if (::EqualString(str, kStrIRE_NET, false, false)) {									routeEntry.routeType = IRE_NET;									if (routeEntry.gateway == source) routeEntry.routeType = IRE_RESOLVER;									if (routeEntry.gateway == IP_StrToInt("\p127.0.0.1")) routeEntry.routeType = IRE_LOOPBACK;								} else								if (::EqualString(str, kStrIRE_RESOLVER, false, false)) {									routeEntry.routeType = IRE_RESOLVER;								} else								if (::EqualString(str, kStrIRE_ROUTE_ASSOC, false, false)) {									routeEntry.routeType = IRE_ROUTE_ASSOC;								}							}							else break;							start = pos;							// get WAM!NET state							routeEntry.wamnet = false;			// default to false							tCount = tRoutesData.GetDataCount();							for (i=1; i<=tCount; i++) {			// look for it in temporary array								tRoutesData.GetDataRoutesArray(i, &tRouteEntry);								if (gRoutesData->MatchRouteEntry(&routeEntry, &tRouteEntry) != kEntryNoMatch) {									// transfer wamnet parameter									routeEntry.wamnet = tRouteEntry.wamnet;									break;								}							}							// put corresponding row in table							switch (routeEntry.routeType) {								case IRE_BROADCAST:								case IRE_LOOPBACK:								case IRE_MULTICAST:								case IRE_LOCAL:								case IRE_ROUTE:									break;								case IRE_GATEWAY:								case IRE_NET:								case IRE_RESOLVER:								case IRE_ROUTE_ASSOC:									row += 1;									gRoutesData->SetDataRoutesArray(row, &routeEntry);									break;							}						} while (false);						// prepare to get next line						start = eol +1;						eol = FindByte(0, dp, start, end);	// end of line					}					// set how many rows we found					gRoutesData->SetDataCount(row);				}	// if (result == kOTNoError)			}	// end scope for locked handle		}	// end while (retryCount > 0)	} while (false);	// if all retries failed, warn user in log	if ((retryCount == 0) && (result > 0)) {		// cache report changed size, give up		gLogAction->LogText("\p\rUpdateRoutesData unexpected result reading routes data: ", result);		result = kEAGAINErr;	}	// clean up	if (ipStream != nil) {		(void) OTStreamClose(ipStream);	}			return result;}#define kDelimiterChar ' '// ---------------------------------------------------------------------------------//		¥ GetParamString// ---------------------------------------------------------------------------------// Get param string from array dp// Returns offset to one past end of parameter or zero if not found//	parameter is terminated by a 'kDelimiterChar' or NULL or ending offsetSInt32CRoutesAction::GetParamString(UInt8* dp, SInt32 start, SInt32 end, Str63 outStr){	SInt32	pos, eol, len;	pos = 0;	if (start < end) {		// find end of line		eol = FindByte(0, dp, start, end);		if (eol == 0) eol = end;		// skip any leading spaces		pos = start;		while (dp[pos] == ' ') pos+=1;					start = pos;		// find end of param		pos = FindByte(kDelimiterChar, dp, start, end);		if ((pos == 0) || (pos > eol)) pos = eol;		len = pos - start;		if ((len >= 0) && (len < 255)) {			outStr[0] = len;			::BlockMove(&dp[start], &outStr[1], len);		} else pos = 0;	}	return pos;}// ---------------------------------------------------------------------------------//		¥ DoRouteEntry// ---------------------------------------------------------------------------------//	Add or Delete routes per routesEntry (table or config)OTResultCRoutesAction::DoRouteEntry(RouteEntry_t* inRouteEntry, Boolean inUpdate){	OTResult		result = kOTNoError;	UInt32			cmd;	short			flags;	RouteEntry_t	routesEntry;	ArrayIndexT		numRows, row;	SInt32			match;	Boolean			wamnetFlag;	if (mNeedInit) Init();	do {		// check if route is protected		wamnetFlag = false;		numRows = gRoutesData->GetDataCount();		for (row=1; row<=numRows; row++) {			gRoutesData->GetDataRoutesArray(row, &routesEntry);			match = gRoutesData->MatchRouteEntry(inRouteEntry, &routesEntry);			if (match != kEntryNoMatch) {				// found corresponding route in table				if (routesEntry.wamnet && !inRouteEntry->wamnet) {					// attempt to modify protected route					wamnetFlag = true;					break;				}			}		}		if (wamnetFlag) {			gLogAction->LogText("\p\rAttempt to modify protected route was rejected.");			result = kOTNoError;			break;	// get out		}		// tell user what we're about to do		LStr255	text;		Str255 str;		//text = "\p\rCRoutesAction::DoRouteEntry\r ";		text = "\p\r";		gRoutesData->RouteEntryToString(inRouteEntry, str);		text += str;		gLogAction->LogText(text);				// add or delete?		if (inRouteEntry->addRoute == false) {			cmd = SIOCDELRT;		} else {			cmd = SIOCADDRT;		}				// look at route type and set flags accordingly		flags = 0;		switch (inRouteEntry->routeType) {			case IRE_NET:				flags = RTF_GATEWAY;				break;			case IRE_GATEWAY:				flags = RTF_GATEWAY;				inRouteEntry->destination = 0;				break;			case IRE_ROUTE_ASSOC:				flags = RTF_GATEWAY + RTF_HOST;				break;			case IRE_RESOLVER:				flags = 0;				break;			case IRE_SUBNET:				flags = RTF_HOST;				break;		}				// if gateway is zero, try to create a pseudo-gateway		if (inRouteEntry->gateway == 0) {			gInterfacesAction->RemovePseudoGateway(nil);			// find an acceptable pseudo gateway address (not all 0s or 1s)			inRouteEntry->gateway = CalcPseudoGateway(gResInfo->mPPPlocalAddress);			gResInfo->mPseudoGateway = inRouteEntry->gateway;		}				result = DoConfig(cmd, inRouteEntry->destination, inRouteEntry->netMask,							inRouteEntry->gateway, flags);		if (result == kEINVALErr) {			// add or delete?			if (inRouteEntry->addRoute == false) {				// route not found				gLogAction->LogText("\p\r Remove Route - kEINVALErr did not find route.");				result = kOTNoError;	// exit gracefully			}			else {				gLogAction->LogText("\p\r Add Route - unexpected OT result: ", result);			}					} else {			if (result != kOTNoError) gLogAction->LogText("\p\rCRoutesAction result: ", result);		}	} while (false);		// Set Routes data to show what we did and remember any settings we added	gRoutesData->SetDataRouteEntry(inRouteEntry);	// update routes table	if (inUpdate) UpdateRoutesData();	return result;}// ---------------------------------------------------------------------------------//		¥ DoConfig// ---------------------------------------------------------------------------------//	Add or Delete routesOTResultCRoutesAction::DoConfig(UInt32 cmd, UInt32 destination, UInt32 mask, UInt32 gateway, short inFlags){	OTResult			result;	struct rtentry		rtreq;			// structure to hold SIOC ioctl request	struct strioctl		stri;			// Setup request structure	bzero((UInt8*)&rtreq, sizeof(struct rtentry));	::OTInitInetAddress( (InetAddress*)&rtreq.rt_dst, 0, destination );			::OTInitInetAddress( (InetAddress*)&rtreq.rt_gateway, 0, gateway );	rtreq.rt_subnetmask = mask;	rtreq.rt_flags = inFlags;	// Issue ioctl to add or delete routes	SetupIoctl(&stri, cmd, (char*)&rtreq, sizeof(struct rtentry));	result = DoIoctl(I_STR, &stri);	return result;}// ---------------------------------------------------------------------------------//		¥ DoIoctl// ---------------------------------------------------------------------------------//	Send synchronous ioctl to IP modulesOTResultCRoutesAction::DoIoctl(UInt32 inCmd, void* inData){	OTResult	result;		result = kOTNoError;		do {		// Make sure we have a stream to IP module.		if (!mStream) {			UOpenTptSupport::StartOpenTransport();			mStream = ::OTStreamOpen(MI_IP_NAME, 0, &result);			if (result != kOTNoError) {				break;			}			// Switch the stream in sync/blocking mode.  To make the			// code easier, we're going to do this synchronously.			(void) ::OTStreamSetBlocking(mStream);			(void) ::OTStreamSetSynchronous(mStream);		}		// issue requested ioctl		result = ::OTStreamIoctl(mStream, inCmd, inData);	} while (false);	return result;}