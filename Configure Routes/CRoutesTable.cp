// =================================================================================//	CRoutesTable.cp				©1996 Sustainable Softworks All rights reserved.// =================================================================================//	Table object to display trace route information#include "CRoutesTable.h"#include "CRoutesWindow.h"//#include "CRoutesData.h"#include "CRoutesConst.h"#include "CResidentIfInfo.h"#include "Cwindow.h"#include <PP_Messages.h>#include "AGAColors.h"#include "CIPRouterApp.h"#include "IPRouterCommon.h"#include "IPSupport.h"#include "MacSupport.h"#include "CIPNumberEditField.h"#include <LToggleButton.h>#include <LString.h>#include <Icons.h>#include "MyOTInetMultilink.h"#include "ICAPI.h"// Globalsextern CIPRouterApp* gAppObject;extern ICInstance gICInstance;// ---------------------------------------------------------------------------------//		¥ CRoutesTable(LStream*)// ---------------------------------------------------------------------------------CRoutesTable::CRoutesTable(	LStream	*inStream )		: CConfigureTable( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CRoutesTable// ---------------------------------------------------------------------------------CRoutesTable::~CRoutesTable(){}#pragma mark --- Geometry ---// ---------------------------------------------------------------------------//		¥ Click Cell// ---------------------------------------------------------------------------//  Handle click in cell.//	Display table data in window edit fieldsvoidCRoutesTable::ClickCell(	const TableCellT		&inCell,	const SMouseDownEvent&	inMouseDown){	RouteEntry_t	routesEntry;	SelectRow(inCell, false);	// ( ,extendFlag)		if (GetRouteEntry(inCell.row, &routesEntry))		((CRoutesWindow*)mWindow)->DisplayRouteEntry(&routesEntry);}// ---------------------------------------------------------------------------------//		¥ GetRouteEntry// ---------------------------------------------------------------------------------//	Get Route Entry from TableBooleanCRoutesTable::GetRouteEntry(TableIndexT inRow, RouteEntry_t* outRouteEntry){	TableCellT	theCell;	TableItemW	tData;	Boolean		result = true;		do {		theCell.row = inRow;		theCell.col = kColumnRouteType;		GetCellData(theCell, &outRouteEntry->routeType);	// route type		// valid entry?		if (outRouteEntry->routeType == 0) {			result = false;				break;		}		theCell.col = kColumnDestination;		GetCellData(theCell, &outRouteEntry->destination);	// destination		theCell.col = kColumnGateway;		GetCellData(theCell, &outRouteEntry->gateway);		// gateway		theCell.col = kColumnRtInterfaceName;		GetCellData(theCell, &tData);		if (tData.hi == kCommentFlag) {			outRouteEntry->interfaceName[0] = 0;			GetCommentData(inRow, 1, outRouteEntry->interfaceName);	// name				}		outRouteEntry->addRoute = true;					// addRoute		outRouteEntry->isDone = false;						// is done	} while (false);		return result;}// ---------------------------------------------------------------------------------//		¥ SetRouteEntry// ---------------------------------------------------------------------------------//	Set Routes Entry in Table//	Refresh if entry was changedvoidCRoutesTable::SetRouteEntry(TableIndexT inRow, RouteEntry_t* inEntry){	TableCellT	theCell;	TableItemW	tData, uData;	Str63		interfaceName;	Boolean		result = false;	do {		// check for valid row entry		if (inRow > kMaxRoutesTableRows) {			result = false;			break;		}		// insert rows if needed		if (inRow > mRows) {			tData.hi = 0;			tData.lo = 0;			InsertRows(inRow-mRows, mRows, &tData);	// how many, after row, *data		}		theCell.row = inRow;		// set entry			// route type		theCell.col = kColumnRouteType;		tData.hi = inEntry->routeType;		tData.lo = 0;		GetCellData(theCell, &uData);		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}			// destination		theCell.col = kColumnDestination;		tData.hi = inEntry->destination;		tData.lo = inEntry->netMask;		GetCellData(theCell, &uData);		if ((tData.hi != uData.hi) || (tData.lo != uData.lo)) {			SetCellData(theCell, &tData);			result = true;		}			// gateway		theCell.col = kColumnGateway;		tData.hi = inEntry->gateway;		tData.lo = 0;		GetCellData(theCell, &uData);		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}			// interfaceName		theCell.col = kColumnRtInterfaceName;		GetCellData(theCell, &uData);		interfaceName[0] = 0;		GetCommentData(inRow, 1, interfaceName);		tData.hi = interfaceName[0];		tData.lo = 0;		if ((tData.hi != uData.hi)	||			!::EqualString(inEntry->interfaceName, interfaceName, true, false) ) {			SetCommentData(inRow, 1, inEntry->interfaceName);			tData.hi = kCommentFlag;			SetCellData(theCell, &tData);			result = true;		}	} while (false);	if (result) RefreshRow(inRow);}// ---------------------------------------------------------------------------//		¥ Draw Cell// ---------------------------------------------------------------------------voidCRoutesTable::DrawCell(	const TableCellT	&inCell){	Rect		cellFrame;	TableItemW	tData;	Str31		str;	OSErr		err = NoError;	if (FetchLocalContentFrame(inCell, cellFrame)) {		// draw white background		::PenNormal();		ApplyForeAndBackColors();		::EraseRect(&cellFrame);		// draw border around cell		::InsetRect(&cellFrame, -1, -1);		::PenPat(&UQDGlobals::GetQDGlobals()->gray);		if (PaneInColor (this)) {			StColorState	saveColor;			RGBColor		emptyColor;			emptyColor = gAGAColorArray[6];			::RGBForeColor(&emptyColor);			::FrameRect(&cellFrame);		} else { ::FrameRect(&cellFrame); }		::PenPat(&UQDGlobals::GetQDGlobals()->black);				// draw contents		::TextFont(applFont);		::TextFace(0);	// normal		::TextSize(9);		// Get cell data		GetCellData( inCell, &tData );		// Handle each column		switch (inCell.col) {		case kColumnRouteType:			// Display Route Type			if (tData.hi != 0) {				MoveTo(cellFrame.left + 8, cellFrame.bottom - 4);				switch (tData.hi) {				case IRE_RESOLVER:					DrawString(kStrDirect);					break;				case IRE_SUBNET:					DrawString(kStrPointToPoint);					break;				case IRE_GATEWAY:					DrawString(kStrDefaultGateway);					break;				case IRE_NET:					DrawString(kStrNetwork);					break;				case IRE_ROUTE_ASSOC:					DrawString(kStrHost);				default:					Str31	str;										NumToString(tData.hi, str);									DrawString(str);				}			}			break;		case kColumnDestination:			// fourth column, display IP Address if not zero			if (tData.hi != kItemNone) {				UInt8	prefixLen;				LStr255 text;				MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);				IP_NumToStr( tData.hi, str );				text = str;				if (tData.lo != 0) {					prefixLen = FindRightBit(tData.lo, 32);					text += "\p/";					::NumToString(prefixLen, str);					text += str;				}				DrawString( text );			}			break;		case kColumnGateway:			// fifth column, display Net Mask if not zero			if (tData.hi != kItemNone) {				MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);				IP_NumToStr( tData.hi, str );				DrawString( str );			}			break;		case kColumnRtInterfaceName:			// Display Interface Name			if (tData.hi != 0) {				unsigned char commentData[kCommentDataSize];				if ( GetCommentData(inCell.row, 1, commentData) ) {					MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);					DrawString(commentData);				}			}			break;		default:								// ### Debugging								// Draw cell row & column number inside								// frame of cell			::MoveTo(cellFrame.left + 8, cellFrame.bottom - 4);				Str31	str;			NumToString(inCell.row, str);			DrawString(str);			DrawString("\p,");			NumToString(inCell.col, str);			DrawString(str);		}	}}