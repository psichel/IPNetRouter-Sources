// =================================================================================//	CLogWindow.cp				й1996 Sustainable Softworks All rights reserved.// =================================================================================//	Logging window for displaying router status messages#include "CLogWindow.h"#include "MacSupport.h"#include "IPRouterCommon.h"#include "CLogData.h"const	SInt32	kMaxChars = 31 * 1024;	// stay just under 32k, to be safer// Globalsextern CLogData* 		gLogData;// ---------------------------------------------------------------------------------//		е CLogWindow(LStream*)// ---------------------------------------------------------------------------------CLogWindow::CLogWindow(	LStream	*inStream )		: CWindow( inStream ){}// ---------------------------------------------------------------------------------//		е ~CLogWindow// ---------------------------------------------------------------------------------CLogWindow::~CLogWindow(){	if (gLogData) gLogData->RemoveListener(this);}// ---------------------------------------------------------------------------------//		е FinishCreateSelf// ---------------------------------------------------------------------------------//	Finish creating the Log window.voidCLogWindow::FinishCreateSelf(){	char* outText;	SInt32 outLength;	// Get text edit pane and handle to Mac TE record	mTextEdit = (LTextEditView *) this->FindPaneByID( kTextEditPane );	ThrowIfNil_( mTextEdit );	mTextEditH = mTextEdit->GetMacTEH();		mTextEdit->FocusDraw();				// erase any previous	::TESetSelect(0, 32767, mTextEditH);	::TEDelete(mTextEditH);	// set the insertion point at end of log	::TESetSelect(32767, 32767, mTextEditH);		// put log text in window	gLogData->GetDataAllText(&outText, &outLength);	mTextEdit->SetTextPtr(outText, outLength, nil);//	mTextEdit->Insert(&timeDateStr[1], inLength, nil, true);	// listen to LogData object	gLogData->AddListener(this);}// ---------------------------------------------------------------------------------//		е ListenToMessage// ---------------------------------------------------------------------------------voidCLogWindow::ListenToMessage(	MessageT	inMessage,	void		*ioParam ){	char* outText;	SInt32 outLength;	UInt16	textSize;	switch ( inMessage ) {			case msg_SignalDataEvent:			UInt32 dataID = *(UInt32*)ioParam;			// If Log Data has changed, update window display			if (dataID == DATA_ID(kLogData, kDataChange)) {							mTextEdit->FocusDraw();							textSize = (**mTextEditH).teLength;				// set the insertion point at end of log				::TESetSelect(32767, 32767, mTextEditH);				// get new text				gLogData->GetDataNewText(&outText, &outLength);				// check if there's room				if (textSize+outLength < 31*1024) {					// insert text					mTextEdit->Insert(outText, outLength, nil, true);				}				else {					// erase any previous					::TESetSelect(0, textSize, mTextEditH);					::TEDelete(mTextEditH);					// set the insertion point at end of log					::TESetSelect(0, 0, mTextEditH);					// put log text in window					gLogData->GetDataAllText(&outText, &outLength);					mTextEdit->SetTextPtr(outText, outLength, nil);				}			}	}}// ---------------------------------------------------------------------------//		е AttemptClose// ---------------------------------------------------------------------------//	Try to close a Window as a result of direct user action//	Override to hide window of SuperCommander rejects closevoidCLogWindow::AttemptClose(){									// Get approval from SuperCommander	if ((mSuperCommander == nil) || mSuperCommander->AllowSubRemoval(this)) {		 		 							// Send Close AE for recording only		SendSelfAE(kAECoreSuite, kAEClose, false);		// remember last window position		SaveWindowPosition( this, rPPob_RouterLogWindow );		delete this;//	} else {//		// close was not allowed so just hide//		this->Hide();	}}// ---------------------------------------------------------------------------//		е HandleKeyPress// ---------------------------------------------------------------------------//	Return true if the Window handles the keystrokeBooleanCLogWindow::HandleKeyPress(	const EventRecord&	inKeyEvent){	Boolean		keyHandled = true;	SInt16		theKey = inKeyEvent.message & charCodeMask;	LScroller*	theScroller;	switch (theKey) {			case char_PageUp:			theScroller = (LScroller*)FindPaneByID( kScrollerPane);			if (theScroller) theScroller->VertScroll(kControlPageUpPart);			break;		case char_PageDown:			theScroller = (LScroller*)FindPaneByID( kScrollerPane);			if (theScroller) theScroller->VertScroll(kControlPageDownPart);			break;		default:			keyHandled = LWindow::HandleKeyPress(inKeyEvent);			break;	}		return keyHandled;}// ===========================================================================#pragma mark -#pragma mark ее printing// ---------------------------------------------------------------------------//		е ObeyCommand// ---------------------------------------------------------------------------//	Respond to commandsBooleanCLogWindow::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;	switch (inCommand) {					case cmd_Print:			HandlePrint();			break;		case cmd_PrintOne:			HandlePrintOne();			break;		default:			cmdHandled = CWindow::ObeyCommand(inCommand, ioParam);			break;	}	return cmdHandled;}// ---------------------------------------------------------------------------//		е FindCommandStatus// ---------------------------------------------------------------------------//	Pass back whether a Command is enabled and/or marked (in a Menu)voidCLogWindow::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	UInt16		&outMark,	Str255		outName){	switch (inCommand) {			case cmd_Print:		case cmd_PrintOne:			outEnabled = true;			break;					default:			CWindow::FindCommandStatus(inCommand, outEnabled,									outUsesMark, outMark, outName);			break;	}}// ---------------------------------------------------------------------------//		е DoPrint// ---------------------------------------------------------------------------//	Print window contentsvoidCLogWindow::DoPrint(){	// make printout view	LPrintout* thePrintout = LPrintout::CreatePrintout(rPPob_ToolPrintout);		// set print record	thePrintout->SetPrintSpec(mPrintSpec);	//thePrintout->SetPrintRecord(mPrintRecordH);		// get occupant to install in placeholder	LPlaceHolder* thePlace = (LPlaceHolder*) thePrintout->FindPaneByID(kPlaceHolder1);	mPrintView = mTextEdit;		if (mPrintView != nil) {		thePlace->InstallOccupant(mPrintView, kAlignNone);				// print it		thePrintout->DoPrintJob();	}		// clean up	delete thePrintout;}