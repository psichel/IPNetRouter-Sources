// ===========================================================================//	CLogData.cp			©1998 Sustainable Softworks, All rights reserved.// ===========================================================================//	Data object to hold Logged output text//	This object supports both the Log Window and a Log File#include "CLogData.h"#include <OpenTransport.h>#include "UOpenTptSupport.h"// ---------------------------------------------------------------------------------//		¥ CLogData	[Constructor]// ---------------------------------------------------------------------------------CLogData::CLogData(){	Init();}// ---------------------------------------------------------------------------------//		¥ ~CLogData	[Destructor]// ---------------------------------------------------------------------------------CLogData::~CLogData(){}// ---------------------------------------------------------------------------------//		¥ Init// ---------------------------------------------------------------------------------//	Initialize log data storagevoidCLogData::Init(){	UOpenTptSupport::StartOpenTransport();	mReadIndex = 0;	mWriteIndex = 0;	mNewTextFlag = false;}#pragma mark --- Accessors ---// ---------------------------------------------------------------------------------//		¥ SignalDataChange// ---------------------------------------------------------------------------------// Used to tell our document when data has changedvoidCLogData::SignalDataChange(){	if (mNewTextFlag) SignalDataEvent( DATA_ID(kLogData, kDataChange) );}// ---------------------------------------------------------------------------------//		¥ AddText// ---------------------------------------------------------------------------------// returns length of text added// if !mNewTextFlag, set ReadIndex to start of text added//// The current log window implementation uses TextEdit, so limit// text to 32K maximum, if more text is added, text is automatically// deleted from the start of the log.SInt32CLogData::SetDataAddText(char* inText, SInt32 inLength){	SInt32 len;		// allow up to adjust amount max per call	if (inLength > kTextAdjust) inLength = kTextAdjust;		// check if inText will fit	if ((mWriteIndex + inLength) > kTextDim) {		// no adjust text in buffer to make room for new text		if (mWriteIndex >= kTextAdjust) {			len = mWriteIndex - kTextAdjust;//			::OTMemmove(&mText[0], &mText[kTextAdjust], len);			::BlockMove(&mText[kTextAdjust], &mText[0], len);			mWriteIndex = mWriteIndex - kTextAdjust;			mReadIndex = mReadIndex - kTextAdjust;			if (mReadIndex < 0) mReadIndex = 0;		}	}	// if previous text has been read, reset mReadIndex	// We reset this here so multiple readers can get the	// same new text when notified the data has changed.	if (!mNewTextFlag) mReadIndex = mWriteIndex;	// copy inText to buffer	if (inLength > 0) {		::OTMemcpy(&mText[mWriteIndex], inText, inLength);		mWriteIndex = mWriteIndex + inLength;		mNewTextFlag = true;	}		return inLength;}// ---------------------------------------------------------------------------------//		¥ GetDataAllText// ---------------------------------------------------------------------------------// set outPtr to point to text buffer// return outLengthSInt32CLogData::GetDataAllText(char** outPtr, SInt32 *outLength){	*outPtr = &mText[0];	*outLength = mWriteIndex;		return *outLength;}// ---------------------------------------------------------------------------------//		¥ GetDataNewText// ---------------------------------------------------------------------------------// Set *outPtr to point to new text in buffer// clear new text flag// return outLengthSInt32CLogData::GetDataNewText(char** outPtr, SInt32 *outLength){	if (mWriteIndex > mReadIndex) {		*outPtr = &mText[mReadIndex];		*outLength = mWriteIndex - mReadIndex;		mNewTextFlag = false;	}	else *outLength = 0;		return *outLength;}