// =================================================================================//	CArpTable.cp				©1999 Sustainable Softworks All rights reserved.// =================================================================================//	Table object to display ARP information#include "CArpTable.h"#include "CArpWindow.h"#include "CArpConst.h"//#include "CArpData.h"#include "CWindow.h"#include "CSubnetCalcWindow.h"#include <PP_Messages.h>#include "AGAColors.h"#include "CIPRouterApp.h"#include "IPRouterCommon.h"#include "IPSupport.h"#include "MacSupport.h"#include "CIPNumberEditField.h"#include <LString.h>#include <Icons.h>#include "ICAPI.h"// Globalsextern CIPRouterApp* gAppObject;extern ICInstance gICInstance;// ---------------------------------------------------------------------------------//		¥ CArpTable(LStream*)// ---------------------------------------------------------------------------------CArpTable::CArpTable(	LStream	*inStream )		: CConfigureTable( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CArpTable// ---------------------------------------------------------------------------------CArpTable::~CArpTable(){}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------//	Finish creating the Arp table.voidCArpTable::FinishCreateSelf(){	// set column widths (inWidth, inFromCol, inToCol)	SetColWidth(102, 1, 1);	SetColWidth(90, 2, 3);	SetColWidth(102, 4, 4);	SetColWidth(130, 5, 5);	// setup and init comment data	SetCommentDataSize(kCommentDataSize, 1);	// set column types	SetColType(kColTypeComment1, 1, 1);	SetColType(kColTypeIPAddr, 2, 3);	SetColType(kColTypeHWAddr, 4, 4);}// ---------------------------------------------------------------------------//		¥ Click Cell// ---------------------------------------------------------------------------//  Handle click in cell.//	Display table entry in window edit fieldsvoidCArpTable::ClickCell(	const TableCellT		&inCell,	const SMouseDownEvent&	inMouseDown){	ArpEntry_t	arpEntry;	SelectRow(inCell, false);	// ( ,extendFlag)	if (GetArpEntry(inCell.row, &arpEntry))		((CArpWindow*)mWindow)->DisplayArpEntry(&arpEntry);}// ---------------------------------------------------------------------------------//		¥ GetArpEntry// ---------------------------------------------------------------------------------//	Get Arp Entry from TableBooleanCArpTable::GetArpEntry(TableIndexT inRow, ArpEntry_t* outArpEntry){	TableCellT	theCell;	TableItemW	tData;	Boolean		result = true;		do {		// check for valid row entry		theCell.row = inRow;		theCell.col = kColumnArpInterfaceName;		GetCellData(theCell, &tData);		if (tData.hi != kCommentFlag) {			result = false;			break;		}		// get entry		GetCommentData(inRow, 1, outArpEntry->interfaceName);// interface name		theCell.col = kColumnProtocolAddr;		GetCellData(theCell, &tData);		// protocol address		outArpEntry->protocolAddr = tData.hi;				theCell.col = kColumnProtocolMask;		GetCellData(theCell, &tData);// protocol mask		outArpEntry->protocolMask = tData.hi;		theCell.col = kColumnHardwareAddr;		GetCellData(theCell, &tData);		OTMemcpy(&outArpEntry->hardwareAddr, &tData, 6);				theCell.col = kColumnArpFlags;		GetCellData(theCell, &tData);		outArpEntry->arpFlags = tData.hi;		outArpEntry->isDone = false;									// is done	} while (false);		return result;}// ---------------------------------------------------------------------------------//		¥ SetArpEntry// ---------------------------------------------------------------------------------//	Set Arp Entry in Table//	Refresh if entry was changedvoidCArpTable::SetArpEntry(TableIndexT inRow, ArpEntry_t* inEntry){	TableCellT	theCell;	TableItemW	tData, uData;	Str63		str;	Boolean		result = false;	do {		// check for valid row entry		if (inRow > kMaxArpTableRows) {			result = false;			break;		}		// insert rows if needed		if (inRow > mRows) {			tData.hi = 0;			tData.lo = 0;			InsertRows(inRow-mRows, mRows, &tData);	// how many, after row, *data		}		theCell.row = inRow;			// InterfaceName		theCell.col = kColumnArpInterfaceName;		GetCellData(theCell, &uData);		str[0] = 0;		// get name from table if any		if (uData.hi == kCommentFlag) GetCommentData(inRow, 1, str);		// are they the same?		if (!::EqualString(str, inEntry->interfaceName, true, false) ) {			SetCommentData(inRow, 1, inEntry->interfaceName);			tData.hi = kCommentFlag;			tData.lo = 0;			SetCellData(theCell, &tData);			result = true;		}						// protocol address		theCell.col = kColumnProtocolAddr;		tData.hi = inEntry->protocolAddr;		tData.lo = 0;		GetCellData(theCell, &uData);		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}			// protocol mask		theCell.col = kColumnProtocolMask;		tData.hi = inEntry->protocolMask;		tData.lo = 0;		GetCellData(theCell, &uData);		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}			// hardware address		theCell.col = kColumnHardwareAddr;		OTMemcpy(&tData, &inEntry->hardwareAddr, 6);		GetCellData(theCell, &uData);		if ((tData.hi != uData.hi) || (tData.lo != uData.lo)) {			SetCellData(theCell, &tData);			result = true;		}			// flags		theCell.col = kColumnArpFlags;		tData.hi = inEntry->arpFlags;		tData.lo = 0;		GetCellData(theCell, &uData);		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}	} while (false);	if (result) RefreshRow(inRow);}// ---------------------------------------------------------------------------//		¥ Draw Cell// ---------------------------------------------------------------------------voidCArpTable::DrawCell(	const TableCellT	&inCell){	Rect			cellFrame;	TableItemW		tData;	OSErr			err = 0;	if (FetchLocalContentFrame(inCell, cellFrame)) {		// draw white background		::PenNormal();		ApplyForeAndBackColors();		::EraseRect(&cellFrame);		// draw border around cell		::InsetRect(&cellFrame, -1, -1);		::PenPat(&UQDGlobals::GetQDGlobals()->gray);		if (PaneInColor (this)) {			StColorState	saveColor;			RGBColor		emptyColor;			emptyColor = gAGAColorArray[6];			::RGBForeColor(&emptyColor);			::FrameRect(&cellFrame);		} else { ::FrameRect(&cellFrame); }		::PenPat(&UQDGlobals::GetQDGlobals()->black);				// draw contents		::TextFont(applFont);		::TextFace(0);	// normal		::TextSize(9);		// Get cell data		GetCellData( inCell, &tData );		// Handle our unique columns		switch (inCell.col) {			case kColumnArpFlags:				if (tData.hi != kItemNone) {					LStr255	flagStr;					flagStr = "\p";					if (tData.hi & kArpFlagPermanent) {						flagStr += "\pPerm. ";					}					if (tData.hi & kArpFlagPublish) {						flagStr += "\pPub. ";					}					if (tData.hi & kArpFlagMapping) {						flagStr += "\pMap.";					}					MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);					DrawString( flagStr );							}				break;				default:				// inherit behavior for common data types				CConfigureTable::DrawCell(inCell);		}	}}