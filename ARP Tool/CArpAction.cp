// =================================================================================//	CArpAction.cp			©1998 Sustainable Softworks All rights reserved.// =================================================================================//	Configure Interface Window#include "CompileFlags.h"#include "CArpAction.h"#include "CArpConst.h"#include "CArpData.h"#include "CInterfacesData.h"#include "IPRouterCommon.h"#include "MacSupport.h"#include "IPSupport.h"#include "CLogAction.h"#include <UReanimator.h>#include <LString.h>#include <LPreferencesFile.h>#include <UResourceMgr.h>#include <LArrayIterator.h>#include <UMemoryMgr.h>#include <UOpenTptSupport.h>#include <OpenTransport.h>#include <OpenTptConfig.h>#include <OpenTptInternet.h>#include <OpenTptLinks.h>#include <modnames.h>			// names of the standard OT modules.//#include "OTARPModule.h"		// Constants and types for ARP module messages.#include "MyOTInetMultilink.h"#include <miioccom.h>#define MIOC_ND			'c'		/* ioctl's for Mentat's nd device */#define ND_GET			MIOC_CMD(MIOC_ND, 0)	/* Get a value */#define ND_SET			MIOC_CMD(MIOC_ND, 1)	/* Set a value */// The name of the Name Dispatch variable you have to get in// order to get a dump of the ARP cache.#define ARP_CACHE_REPORT "arp_cache_report"enum {	kARP_CACHE_REPORT_Length = 17			// strlen(ARP_CACHE_REPORT) + 1};// Globalsextern CLogAction*		gLogAction;extern CArpData*		gArpData;extern CInterfacesData*	gInterfacesData;// ---------------------------------------------------------------------------------//		¥ CArpAction()// ---------------------------------------------------------------------------------CArpAction::CArpAction(){	// more initialization	mArpStream = nil;	mNeedInit = true;}// ---------------------------------------------------------------------------------//		¥ ~CArpAction// ---------------------------------------------------------------------------------CArpAction::~CArpAction(){	Terminate();}// ---------------------------------------------------------------------------------//		¥ Terminate// ---------------------------------------------------------------------------------voidCArpAction::Terminate(){	// Release the stream we created	if (mArpStream != nil) {		::OTStreamClose(mArpStream);		mArpStream = nil;	}	mNeedInit = true;}// ---------------------------------------------------------------------------------//		¥ Init// ---------------------------------------------------------------------------------voidCArpAction::Init(){	mNeedInit = false;}// ---------------------------------------------------------------------------------//		¥ UpdateArpData// ---------------------------------------------------------------------------------//	Update Arp Data from ARP moduleOTResultCArpAction::UpdateArpData(){	OTResult result;	struct strioctl stri;	char ndCommandBuffer[kARP_CACHE_REPORT_Length];	UInt32 realDataSize;	if (mNeedInit) Init();	do {		// Copy the name of the ND variable we're trying		// to get into our buffer.		::OTStrCopy(ndCommandBuffer, ARP_CACHE_REPORT);		// The ND_GET ioctl returns a value and sets ic_len.  A negative		//  value is an error and you can give up now (-:  The rule for		//  positive values is a bit weirder.  ic_len is always set		//  to the amount of data that is actually returned.  If the		//  data available exceeds the available buffer space (as		//  defined by the ic_len on input), the ioctl returns		//  a positive number that is the amount of buffer space		//  needed.  So we first call it with a minimal buffer		//  then give it the buffer space it requires.  Obviously		//  there's a concurrency race here, which we conveniently		//  ignore in this sample by return kEAGAINErr.		// First get the size of data buffer we need to allocate by		// doing the ioctl with a small buffer and examining the result.		SetupIoctl(&stri, ND_GET, ndCommandBuffer, kARP_CACHE_REPORT_Length);				result = DoIoctl(I_STR, &stri);				if (result < 0) break;	// return error		if (result < kARP_CACHE_REPORT_Length) {			// No data, empty table.			gArpData->SetDataCount(0);			break;		}				// The first ioctl returned a positive number telling		// us how big the data returned was.  We turn around		// around make the ioctl again, this time passing		// in an appropriately sized buffer.		realDataSize = result + 255;				StHandleBlock cacheReport(realDataSize, false, false);		Handle dataH;		dataH = cacheReport.Get();		if (dataH == nil) {			result = memFullErr;			break;				}				// begin scope for locked handle		{			StHandleLocker lock((Handle)dataH);								OTStrCopy(*dataH, ARP_CACHE_REPORT);			SetupIoctl(&stri, ND_GET, *dataH, realDataSize);			result = DoIoctl(I_STR, &stri);				if (result == kOTNoError) {				// We have the ARP report,				// initialize to examine each line				UInt32 start, end, eol, pos;				UInt8* dp;				ArpEntry_t arpEntry;				Str63 str;				ArrayIndexT row;				dp = (UInt8*)*dataH;				start = 0;				end = stri.ic_len;	// actual length of report				eol = FindByte(0, dp, start, end);	// end of line				start = eol + 1;	// skip first line of headings				eol = FindByte(0, dp, start, end);	// end of line				row = 0;				while (eol > 0) {					// extract data from line					do {							// interfaceName						pos = GetParamString(dp, start, eol, str);						if (pos) LString::CopyPStr(str, arpEntry.interfaceName, sizeof(Str63));						else break;						start = pos;							// protocolAddr						pos = GetParamString(dp, start, eol, str);						if (pos) arpEntry.protocolAddr = IP_StrToInt(str);						else break;						start = pos;							// work around bug in ARP cache report interface name						gInterfacesData->InterfaceAddrToName(arpEntry.protocolAddr, str);						if (str[0]) {							LString::CopyPStr(str, arpEntry.interfaceName, sizeof(Str63));							LString::CopyPStr(str, mInterfaceName, sizeof(Str63));						}						//else LString::CopyPStr(mInterfaceName, arpEntry.interfaceName, sizeof(Str63));							// protocolMask						pos = GetParamString(dp, start, eol, str);						if (pos) arpEntry.protocolMask = IP_StrToInt(str);						else break;						start = pos;							// hardwareAddr						pos = GetParamString(dp, start, eol, str);						if (pos) HW_StrToInt(str, &arpEntry.hardwareAddr);						else break;						start = pos;							// flags						arpEntry.arpFlags = 0;						pos = GetParamString(dp, start, eol, str);						while (pos) {							if (::EqualString(str, "\pPERM", false, false))								arpEntry.arpFlags |= kArpFlagPermanent;							if (::EqualString(str, "\pPUBLISH", false, false))								arpEntry.arpFlags |= kArpFlagPublish;							if (::EqualString(str, "\pMAPPING", false, false))								arpEntry.arpFlags |= kArpFlagMapping;													start = pos;							pos = GetParamString(dp, start, eol, str);						}						// put corresponding row in table						row += 1;						gArpData->SetDataArpArray(row, &arpEntry);					} while (false);					// prepare to get next line					start = eol +1;					eol = FindByte(0, dp, start, end);	// end of line				}				// set how many rows we found				gArpData->SetDataCount(row);			}			else {				// cache report changed size, just get out				result = kEAGAINErr;				break;			}		}	// end scope for locked handle	} while (false);		return result;}const UInt8 kDelimiterChar = ' ';// ---------------------------------------------------------------------------------//		¥ GetParamString// ---------------------------------------------------------------------------------// Get param string from array dp// Returns offset to one past end of parameter or zero if not found//	parameter is terminated by a 'kDelimiterChar' or NULL or ending offsetSInt32CArpAction::GetParamString(UInt8* dp, SInt32 start, SInt32 end, Str63 outStr){	SInt32	pos, eol, len;	pos = 0;	if (start < end) {		// find end of line		eol = FindByte(0, dp, start, end);		if (eol == 0) eol = end;		// skip any leading spaces		pos = start;		while (dp[pos] == ' ') pos+=1;					start = pos;		// find end of param		pos = FindByte(kDelimiterChar, dp, start, end);		if ((pos == 0) || (pos > eol)) pos = eol;		len = pos - start;		if ((len >= 0) && (len < 255)) {			outStr[0] = len;			::BlockMove(&dp[start], &outStr[1], len);		} else pos = 0;	}	return pos;}#pragma mark --- ARP operations ---// ---------------------------------------------------------------------------------//		¥ CopyIntoCommandBuffer// ---------------------------------------------------------------------------------voidCArpAction::CopyIntoCommandBuffer	(char *buffer, UInt32 *currentOffset, void *data, UInt32 dataLength)	// Copy dataLength bytes from data into an ARP command buffer.	// buffer is a pointer to an ARP command block.	// currentOffset comes in as the number of bytes that are currently being	// used in the block, and is adjusted to represent the number of bytes we copied in.	// data is the address of the bytes to copy in.	// dataLength is the number of bytes to copy in.{	OTMemcpy(&buffer[*currentOffset], data, dataLength);	(*currentOffset) += dataLength;}voidCArpAction::CopyInterfaceNameIntoCommandBuffer	(char *buffer, UInt32 *currentOffset, char *interfaceName)	// Copy an interface name into an ARP command buffer.	// buffer is a pointer to an ARP command block.  This is assumed to point	// to at least an arc_t, although the other ARP command structures all	// begin with an arc_t, so it works for the other structures as well.	// currentOffset comes in as the number of bytes that are currently being	// used in the block, and is adjusted to represent the number of bytes we copied in.	// interfaceName is the address of a C string.{	arc_t *arpCommandPtr;	UInt32 interfaceNameLength;		interfaceNameLength = OTStrLength(interfaceName) + 1;	// copy the string and the final null	arpCommandPtr = (arc_t *) buffer;	arpCommandPtr->arc_name_offset = *currentOffset;	arpCommandPtr->arc_name_length = interfaceNameLength;	CopyIntoCommandBuffer(buffer, currentOffset, interfaceName, interfaceNameLength);}voidCArpAction::CopyProtoAddrIntoCommandBuffer	(char *buffer, UInt32 *currentOffset, void *protoAddr, UInt32 protoSize)	// Copy an protocol address into an ARP command buffer.	// buffer is a pointer to an ARP command block.  This is assumed to point	// to at least an arc_t, although the other ARP command structures all	// begin with an arc_t, so it works for the other structures as well.	// currentOffset comes in as the number of bytes that are currently being	// used in the block, and is adjusted to represent the number of bytes we copied in.	// protoAddress is the address of the bytes of the protocol address to copy in.	// protoSize is the number of bytes to copy in.{	arc_t *arpCommandPtr;		arpCommandPtr = (arc_t *) buffer;	arpCommandPtr->arc_proto_addr_offset = *currentOffset;	arpCommandPtr->arc_proto_addr_length = protoSize;	CopyIntoCommandBuffer(buffer, currentOffset, protoAddr, protoSize);}// ---------------------------------------------------------------------------------//		¥ ArpAddEntry// ---------------------------------------------------------------------------------// Add entry to ARP cacheOTResultCArpAction::ArpAddEntry(ArpEntry_t* inArpEntry){	OTResult err;	char arpCommandBuffer[256];	area_t *arpAddCommandPtr;	UInt32 currentOffset;	struct strioctl arpIOControl;	UInt32 len;	UInt32 protoSize = 4;	UInt32 hardwareSize = 6;	if (mNeedInit) Init();	// Initialise the command buffer for this command.	arpAddCommandPtr = (area_t *) &arpCommandBuffer[0];	currentOffset = sizeof(area_t);	// command	arpAddCommandPtr->area_arc.arc_cmd = AR_ENTRY_ADD;	// interface Name	len = inArpEntry->interfaceName[0] + 1;	// one past end of string	inArpEntry->interfaceName[len] = 0;		// add terminating null	CopyInterfaceNameIntoCommandBuffer(arpCommandBuffer, &currentOffset, (char*)&inArpEntry->interfaceName[1]);			// arp protocol	arpAddCommandPtr->area_arc.arc_proto = IP_ARP_PROTO_TYPE;	// protocol address	CopyProtoAddrIntoCommandBuffer(arpCommandBuffer, &currentOffset, (void*)&inArpEntry->protocolAddr, protoSize);	// flags	arpAddCommandPtr->area_arc.arc_flags = inArpEntry->arpFlags;	arpAddCommandPtr->area_arc.arc_client_q = nil;	// ignored by ARP for this command	// protocol mask	arpAddCommandPtr->area_proto_mask_offset = currentOffset;	CopyIntoCommandBuffer(arpCommandBuffer, &currentOffset, (void*)&inArpEntry->protocolMask, protoSize);	// hardware addr	arpAddCommandPtr->area_hw_addr_offset = currentOffset;	arpAddCommandPtr->area_hw_addr_length = hardwareSize;	CopyIntoCommandBuffer(arpCommandBuffer, &currentOffset, (void*)&inArpEntry->hardwareAddr, hardwareSize);	// Initialise the I_STR ioctl structure.	SetupIoctl(&arpIOControl, AR_ENTRY_ADD, &arpCommandBuffer[0], currentOffset);		// Send the ioctl.	err = DoIoctl(I_STR, &arpIOControl);	return (err);}// ---------------------------------------------------------------------------------//		¥ ArpDeleteEntry// ---------------------------------------------------------------------------------// Delete entry from ARP cacheOTResultCArpAction::ArpDeleteEntry(ArpEntry_t* inArpEntry){	OTResult err;	char arpCommandBuffer[256];	arc_t *arpDeleteCommandPtr;	UInt32 currentOffset;	struct strioctl arpIOControl;	UInt32 len;	UInt32 protoSize = 4;	UInt32 hardwareSize = 6;	if (mNeedInit) Init();	// Initialise the command buffer for this command.	arpDeleteCommandPtr = (arc_t *) &arpCommandBuffer[0];	currentOffset = sizeof(area_t);	// command	arpDeleteCommandPtr->arc_cmd = AR_ENTRY_DELETE;	// interface Name	len = inArpEntry->interfaceName[0] + 1;	// one past end of string	inArpEntry->interfaceName[len] = 0;		// add terminating null	CopyInterfaceNameIntoCommandBuffer(arpCommandBuffer, &currentOffset, (char*)&inArpEntry->interfaceName[1]);			// arp protocol	arpDeleteCommandPtr->arc_proto = IP_ARP_PROTO_TYPE;	// protocol address	CopyProtoAddrIntoCommandBuffer(arpCommandBuffer, &currentOffset, (void*)&inArpEntry->protocolAddr, protoSize);	// flags	arpDeleteCommandPtr->arc_flags = 0;			// ignored by ARP for this command	arpDeleteCommandPtr->arc_client_q = nil;	// ignored by ARP for this command	// Initialise the I_STR ioctl structure.	SetupIoctl(&arpIOControl, AR_ENTRY_DELETE, &arpCommandBuffer[0], currentOffset);		// Send the ioctl.	err = DoIoctl(I_STR, &arpIOControl);	return (err);}// ---------------------------------------------------------------------------------//		¥ ArpQueryEntry// ---------------------------------------------------------------------------------// Request address resolution from ARPOTResultCArpAction::ArpQueryEntry(ArpEntry_t* inArpEntry){	OTResult err;	char arpCommandBuffer[256];	areq_t *arpQueryCommandPtr;	UInt32 currentOffset;	struct strioctl arpIOControl;	UInt32 len;	UInt32 protoSize = sizeof(InetHost);    // 4	UInt32 hardwareSize = 6;	InetHost senderAddr;	if (mNeedInit) Init();//#define	AR_ENTRY_QUERY		MIOC_CMD(MIOC_ARP,3)// Look for an entry, either in the cache or by talking on the network.// Use areq_t structure.// In://		areq_arc.arc_cmd = AR_ENTRY_QUERY//		areq_arc.arc_name_offset = offset to name of interface//		areq_arc.arc_name_length = length of name of interface (including zero terminator)//		areq_arc.arc_proto = ARP protocol type (eg IP_ARP_PROTO_TYPE)//		areq_arc.arc_proto_addr_offset = offset to protocol address to look up (eg an InetHost)//		areq_arc.arc_proto_addr_offset = length of protocol address to look up (eg sizeof(InetHost))//		areq_sender_addr_offset = offset to protocol address of sender (eg an InetHost)//		areq_sender_addr_length = length of protocol address of sender (eg sizeof(InetHost))//		areq_xmit_count = number of transmissions before giving up (use 0 for a straight cache lookup)//		areq_xmit_interval = number of milliseconds between transmissions (0 gives a sensible default)//		areq_max_buffered = number of requests to buffer (0 gives a sensible default)//		areq_sap = a SAP to insert into the returned response// Out://		The output is in the form of a DLPI message that you can//		use as the header to a message to the requested host.	// Initialise the command buffer for this command.	arpQueryCommandPtr = (areq_t *) &arpCommandBuffer[0];	currentOffset = sizeof(areq_t);	// command	arpQueryCommandPtr->areq_arc.arc_cmd = AR_ENTRY_QUERY;	// interface Name	len = inArpEntry->interfaceName[0] + 1;	// one past end of string	inArpEntry->interfaceName[len] = 0;		// add terminating null	CopyInterfaceNameIntoCommandBuffer(arpCommandBuffer, &currentOffset, (char*)&inArpEntry->interfaceName[1]);			// arp protocol	arpQueryCommandPtr->areq_arc.arc_proto = IP_ARP_PROTO_TYPE;	// protocol address	CopyProtoAddrIntoCommandBuffer(arpCommandBuffer, &currentOffset, (void*)&inArpEntry->protocolAddr, protoSize);	// flags	arpQueryCommandPtr->areq_arc.arc_flags = 0;			// return value	arpQueryCommandPtr->areq_arc.arc_client_q = nil;	// ignored by ARP for this command	// sender address	senderAddr = gInterfacesData->InterfaceNameToAddr(inArpEntry->interfaceName);	arpQueryCommandPtr->areq_sender_addr_offset = currentOffset;	arpQueryCommandPtr->areq_sender_addr_length = protoSize;	CopyIntoCommandBuffer(arpCommandBuffer, &currentOffset, &senderAddr, protoSize);    // other parameters    arpQueryCommandPtr->areq_xmit_count = 1;    arpQueryCommandPtr->areq_xmit_interval = 0;    arpQueryCommandPtr->areq_max_buffered = 0;//    arpQueryCommandPtr->areq_sap = 0;	// Initialise the I_STR ioctl structure.	SetupIoctl(&arpIOControl, AR_ENTRY_QUERY, &arpCommandBuffer[0], currentOffset);		// Send the ioctl.	err = DoIoctl(I_STR, &arpIOControl);	return (err);}// ---------------------------------------------------------------------------------//		¥ ArpSQueryEntry// ---------------------------------------------------------------------------------// Request address resolution from ARPOTResultCArpAction::ArpSQueryEntry(ArpEntry_t* inArpEntry){	OTResult err;	char arpCommandBuffer[256];	area_t *arpQueryCommandPtr;	UInt32 currentOffset;	struct strioctl arpIOControl;	UInt32 len;	UInt32 protoSize = 4;	UInt32 hardwareSize = 6;	if (mNeedInit) Init();	// Initialise the command buffer for this command.	arpQueryCommandPtr = (area_t *) &arpCommandBuffer[0];	currentOffset = sizeof(area_t);//#define	AR_ENTRY_SQUERY		MIOC_CMD(MIOC_ARP,6)// Look for an entry in the ARP cache.// Use area_t structure.// In://		area_arc.arc_cmd = AR_ENTRY_SQUERY//		area_arc.arc_name_offset = offset to name of interface//		area_arc.arc_name_length = length of name of interface (including zero terminator)//		area_arc.arc_proto = ARP protocol type (eg IP_ARP_PROTO_TYPE)//		area_arc.arc_proto_addr_offset = offset to protocol address to look up (eg an InetHost)//		area_arc.arc_proto_addr_offset = length of protocol address to look up (eg sizeof(InetHost))//		area_hw_addr_offset = offset to buffer to store hardware address//		area_hw_addr_length = length of buffer to store hardware address (eg 6)// Out://		area_arc.arc_flags = flags for this entry//		buffer pointed to by area_hw_addr_offset and area_hw_addr_length = hardware address	// command	arpQueryCommandPtr->area_arc.arc_cmd = AR_ENTRY_SQUERY;	// interface Name	len = inArpEntry->interfaceName[0] + 1;	// one past end of string	inArpEntry->interfaceName[len] = 0;		// add terminating null	CopyInterfaceNameIntoCommandBuffer(arpCommandBuffer, &currentOffset, (char*)&inArpEntry->interfaceName[1]);			// arp protocol	arpQueryCommandPtr->area_arc.arc_proto = IP_ARP_PROTO_TYPE;	// protocol address	CopyProtoAddrIntoCommandBuffer(arpCommandBuffer, &currentOffset, (void*)&inArpEntry->protocolAddr, protoSize);    // setup HW buffer    arpQueryCommandPtr->area_hw_addr_offset = currentOffset;    arpQueryCommandPtr->area_hw_addr_length = hardwareSize;    CopyIntoCommandBuffer(arpCommandBuffer, &currentOffset, &inArpEntry->hardwareAddr, hardwareSize);	// Initialise the I_STR ioctl structure.	SetupIoctl(&arpIOControl, AR_ENTRY_SQUERY, &arpCommandBuffer[0], currentOffset);		// Send the ioctl.	err = DoIoctl(I_STR, &arpIOControl);    // get the hardware address returned    ::BlockMove(&arpCommandBuffer[arpQueryCommandPtr->area_hw_addr_offset], &inArpEntry->hardwareAddr, hardwareSize);    	return (err);}#pragma mark --- ioctl ---// ---------------------------------------------------------------------------------//		¥ DoIoctl// ---------------------------------------------------------------------------------//	Send synchronous ioctl to IP moduleOTResultCArpAction::DoIoctl(UInt32 inCmd, void* inData){	OTResult	result;		result = kOTNoError;		do {		// Make sure we have a stream to IP module.		if (!mArpStream) {			UOpenTptSupport::StartOpenTransport();			mArpStream = ::OTStreamOpen(MI_ARP_NAME, 0, &result);			if (result != kOTNoError) {				break;			}						// Switch the stream in sync/blocking mode.  To make the			// code easier, we're going to do this synchronously.			(void) ::OTStreamSetBlocking(mArpStream);			(void) ::OTStreamSetSynchronous(mArpStream);		}		// issue requested ioctl		result = ::OTStreamIoctl(mArpStream, inCmd, inData);	} while (false);	return result;}