// =================================================================================//	CArpWindow.cp			©1997 Sustainable Softworks All rights reserved.// =================================================================================//	Configure Arp Window#include "CompileFlags.h"#include "CArpWindow.h"#include "CArpConst.h"#include "CArpData.h"#include "CArpAction.h"#include "CLookupConst.h"#include "CHelpWindow.h"#include "CIPNumberEditField.h"#include "IPRouterCommon.h"#include "CSubnetCalcWindow.h"#include "UIPNumKeyFilters.h"//#include "CArpTable.h"#include "CMultiCaption.h"#include "MacSupport.h"#include "IPSupport.h"#include "CLogAction.h"#include <UReanimator.h>#include <LString.h>#include <LPreferencesFile.h>#include <UResourceMgr.h>#include <LArrayIterator.h>#include <OpenTransport.h>#include <LInternetMapper.h>#include <LOpenTptInetMapper.h>// Globalsextern CLogAction*		gLogAction;extern CArpData*		gArpData;extern CArpAction*		gArpAction;// ---------------------------------------------------------------------------------//		¥ CArpWindow(LStream*)// ---------------------------------------------------------------------------------CArpWindow::CArpWindow(	LStream	*inStream )		: CWindow( inStream ){	// more initialization	mMapper = new LOpenTptInetMapper();	ThrowIfNil_(mMapper);	mInetMapperThread = nil;	mBeepAttachment = new LBeepAttachment(msg_Click, false);	mSpinCursor = nil;	mLookupType = kLookupNone;	mPendingLookup = false;	mCanRetry = true;}// ---------------------------------------------------------------------------------//		¥ ~CArpWindow// ---------------------------------------------------------------------------------CArpWindow::~CArpWindow(){	// disconnect from Arp data	gArpData->RemoveListener(this);	if (mInetMapperThread) mInetMapperThread->AbortLookup();	// Wait for threads to abort normally	UInt8 retryLimit = 16;	while (mInetMapperThread != nil) {		LThread::Yield();		retryLimit -= 1;		if (retryLimit == 0) break;	}	// delete threads and provider as best we can	if (mInetMapperThread) {		mInetMapperThread->DeleteThread();		mInetMapperThread = nil;	}	if (mMapper) delete mMapper;	if (mSpinCursor) delete mSpinCursor;	if (mBeepAttachment) delete mBeepAttachment;}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------//	Finish creating the Arp window.voidCArpWindow::FinishCreateSelf(){	// setup up ARP display table	// get the table view	mArpTable = (CArpTable*) this->FindPaneByID( kArpTablePane );	ThrowIfNil_( mArpTable );	mArpTable->SetWindow(this);	// tell table it's parent window	// setup up table captions	CMultiCaption	*theCaption;	theCaption = (CMultiCaption*) this->FindPaneByID( kArpTableCaptionPane );	ThrowIfNil_( theCaption );	// customize the caption widths to match table outline	TableIndexT rows, cols, i;	short width;	mArpTable->GetTableSize(rows, cols);	for (i=1; i<=cols; i++) {		width = mArpTable->GetColWidth(i);		theCaption->SetColWidth(width, i, i);	}		// Link the window (the listener) with the controls in	// the window (the broadcasters).	UReanimator::LinkListenerToControls(		(CArpWindow *)this, this, rRidL_ArpWindow );	// setup pointer to status caption	mStatusCaption = (LCaption*)FindPaneByID( kStatusCaption );	ThrowIfNil_(mStatusCaption);	// setup pointer to Add button	mAddButton = (LControl*) FindPaneByID(kAddButton);	ThrowIfNil_(mAddButton);		// setup SpinCursor attachment	mSpinCursor = new CSpinCursor(this);		// load the ARP table	OTResult result;	result = gArpAction->UpdateArpData();	IoctlResponse(result);	UpdateTable();	// update Arp entry in Window	ArpEntry_t arpEntry;	gArpData->GetDataArpEntry(&arpEntry);	DisplayArpEntry(&arpEntry);	// connect to ARP data	gArpData->AddListener(this);	gArpAction->UpdateArpData();}// ---------------------------------------------------------------------------//		¥ HandleKeyPress// ---------------------------------------------------------------------------//	Handle <Return>, <Enter> passed up from an EditField////	Return true if the Window handles the keystrokeBooleanCArpWindow::HandleKeyPress(	const EventRecord&	inKeyEvent){	Boolean		keyHandled = true;	LControl	*keyButton = nil;	SInt16		theKey = inKeyEvent.message & charCodeMask;	switch (theKey) {			//case char_Enter:		//case char_Return:		//	keyButton =  (LControl*) FindPaneByID(kAddButton);		//	break;		case 'u':		case 'U':			if ((inKeyEvent.modifiers & cmdKey) && !mPendingLookup) {				keyButton =  (LButton*) FindPaneByID(kLookUpButton);			}			break;		default:			if (UKeyFilters::IsCmdPeriod(inKeyEvent)) {				AbortLookup();			} else {				keyHandled = CWindow::HandleKeyPress(inKeyEvent);			}			break;	}				if (keyButton != nil) {		keyButton->SimulateHotSpotClick(kControlButtonPart);		keyHandled = true;	}		return keyHandled;}// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------voidCArpWindow::ListenToMessage(	MessageT	inMessage,	void		*ioParam ){	OSStatus 			result;	ArpEntry_t			arpEntry;	try {		switch ( inMessage ) {						case msg_SignalDataEvent:				UInt32 dataID = *(UInt32*)ioParam;				if (dataID == DATA_ID(kArpData, kDataArpEntry)) {					// Arp parameter data has changed										gArpData->GetDataArpEntry(&arpEntry);					DisplayArpEntry(&arpEntry);				}				else if (dataID>>16 == kArpData) {					// a row in the filter array has changed					TableIndexT	row;					row = dataID & 0xFFFF;					if (row > kDataArpArrayOffset) {						row -= kDataArpArrayOffset;						// try to get data for this row						if (gArpData->GetDataArpArray(row, &arpEntry)) {							// got it, update table and refresh display if needed							mArpTable->SetArpEntry(row, &arpEntry);						}						else {							// no data, row must have been deleted							mArpTable->ClearRow(row);						}					}				}				break;							case msg_AddButton:				ReadArpEntry(&arpEntry);				result = gArpAction->ArpAddEntry(&arpEntry);				IoctlResponse(result);				gArpAction->UpdateArpData();				UpdateTable();								break;							case msg_RemoveButton:				ReadArpEntry(&arpEntry);				result = gArpAction->ArpDeleteEntry(&arpEntry);				IoctlResponse(result);				gArpAction->UpdateArpData();				UpdateTable();								break;							case msg_ArpQueryButton:				ReadArpEntry(&arpEntry);				result = gArpAction->ArpQueryEntry(&arpEntry);//				result = gArpAction->ArpSQueryEntry(&arpEntry);//				DisplayArpEntry(&arpEntry);				IoctlResponse(result);				gArpAction->UpdateArpData();				UpdateTable();								break;							case msg_ArpRefreshButton:				// load the ARP table				result = gArpAction->UpdateArpData();				IoctlResponse(result);				UpdateTable();								break;						case msg_LookUpButton:				{					CIPNumberEditField	*theEditField;					LEditField	*theNameField;					UInt32		targetAddr;					Str255		nameStr;					UInt8 nsAction = kLookupNone;										// don't allow multiples					if (mPendingLookup) break;					// get address and name fields					theEditField = (CIPNumberEditField*) this->FindPaneByID( kProtocolAddrField );					ThrowIfNil_(theEditField);					targetAddr = theEditField->GetValue();					theNameField = (LEditField*) this->FindPaneByID( kProtocolNameField );					ThrowIfNil_(theNameField);					theNameField->GetDescriptor(nameStr);										// Lookup or reverse lookup?					nsAction = kLookupAddressToName;	// lookup name by default					// name field is target?					if (theNameField->IsTarget()) nsAction = kLookupNameToAddress;					// address field is target?					else if (theEditField->IsTarget()) nsAction = kLookupAddressToName;										// name and no address					if ((targetAddr == 0) && (nameStr[0] != 0)) nsAction = kLookupNameToAddress;					// address and no name					else if ((targetAddr != 0) && (nameStr[0] == 0)) nsAction = kLookupAddressToName;										if (nsAction == kLookupNameToAddress) {						LookupBegin();						LookupNameToAddress();					}					if (nsAction == kLookupAddressToName) { 						// get lookup address						mLookupAddress = theEditField->GetValue();						theEditField->SetValue(mLookupAddress);								// start lookup						LookupBegin();						LookupAddressToName();					}				}				break;						case msg_HelpButton:				// test code				//gArpAction->ListenToMessage(kOTProviderWillClose, nil);				//break;				// end of test code											// Create the Help Window				CHelpWindow		*theWindow;				theWindow = (CHelpWindow*)InvokeWindow(kNameHelp, this);				theWindow->Show();				theWindow->LoadTextInWindow(rTEXT_ArpHelp);				break;		}	}	catch (const LException& inErr) {		Str31 errStr;		::NumToString( inErr.GetErrorCode(), errStr);		::ParamText(errStr, nil, nil, nil);		UDesktop::Deactivate();		// Alert will swallow Deactivate event		::Alert(ALRT_OTError, nil);		UDesktop::Activate();	} 	catch (...) {		UDesktop::Deactivate();		// Alert will swallow Deactivate event		::Alert(ALRT_Unexpected, nil);		UDesktop::Activate();	}}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	Respond to commandsBooleanCArpWindow::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;//	GrafPtr		theWindowP;	LWindow*	theWindow;	LEditField*	theEditField;	Str255		str;	switch (inCommand) {		case cmd_SubnetCalculator:			// Create the Subnet Calculator Window			theWindow = InvokeWindow(kNameSubnetCalculator, mSuperCommander);			theWindow->Show();			theEditField = (LEditField*) this->FindPaneByID( kProtocolAddrField );			ThrowIfNil_(theEditField);			theEditField->GetDescriptor(str);			((CSubnetCalcWindow*)theWindow)->InvokeSubnetCalcWindow(str);			break;					default:			cmdHandled = CWindow::ObeyCommand(inCommand, ioParam);			break;	}	return cmdHandled;}#pragma mark --- Arp Table ---// ---------------------------------------------------------------------------------//		¥ UpdateTable// ---------------------------------------------------------------------------------//	Update Arp Table from data objectvoidCArpWindow::UpdateTable(){	ArrayIndexT			num;	ArrayIndexT			index;	ArpEntry_t	arpEntry;		num = gArpData->GetDataCount();	for (index=1; index<=num; index++) {		if (gArpData->GetDataArpArray(index, &arpEntry)) {			mArpTable->SetArpEntry(index, &arpEntry);		} else {			mArpTable->ClearRow(index);		}	}}// ---------------------------------------------------------------------------------//		¥ DisplayArpEntry// ---------------------------------------------------------------------------------//	Display Arp entry in input fieldsvoidCArpWindow::DisplayArpEntry(ArpEntry_t* inArpEntry){	LEditField*			textEditField;	CIPNumberEditField* ipNumEditField;	LStdCheckBox*		theCheckBox;	Str255				str;	// interface name	textEditField = (LEditField*)FindPaneByID(kInterfaceNameField);	ThrowIfNil_(textEditField);	textEditField->SetDescriptor(inArpEntry->interfaceName);	// protocol address	ipNumEditField = (CIPNumberEditField*)FindPaneByID(kProtocolAddrField);	ThrowIfNil_(ipNumEditField);	ipNumEditField->SetValue(inArpEntry->protocolAddr);	// protocol mask	ipNumEditField = (CIPNumberEditField*)FindPaneByID(kProtocolMaskField);	ThrowIfNil_(ipNumEditField);	ipNumEditField->SetValue(inArpEntry->protocolMask);	// hardware address	textEditField = (LEditField*)FindPaneByID(kHardwareAddrField);	ThrowIfNil_(textEditField);	if ((inArpEntry->hardwareAddr.first4 == 0) &&		(inArpEntry->hardwareAddr.last2 == 0)) str[0] = 0;		else HW_NumToHexStr(&inArpEntry->hardwareAddr, str);	textEditField->SetDescriptor(str);	// arp flags	theCheckBox = (LStdCheckBox*)FindPaneByID(kPermanentCheckBox);	ThrowIfNil_(theCheckBox);	theCheckBox->SetValue(inArpEntry->arpFlags & kArpFlagPermanent);		theCheckBox = (LStdCheckBox*)FindPaneByID(kPublishCheckBox);	ThrowIfNil_(theCheckBox);	theCheckBox->SetValue(inArpEntry->arpFlags & kArpFlagPublish);	theCheckBox = (LStdCheckBox*)FindPaneByID(kMappingCheckBox);	ThrowIfNil_(theCheckBox);	theCheckBox->SetValue(inArpEntry->arpFlags & kArpFlagMapping);}// ---------------------------------------------------------------------------------//		¥ ReadArpEntry// ---------------------------------------------------------------------------------//	Read Arp entry in input fieldsvoidCArpWindow::ReadArpEntry(ArpEntry_t* inArpEntry){	LEditField*			textEditField;	CIPNumberEditField* ipNumEditField;	LStdCheckBox*		theCheckBox;	Str255				str;	// interface name	textEditField = (LEditField*)FindPaneByID(kInterfaceNameField);	ThrowIfNil_(textEditField);	textEditField->GetDescriptor(inArpEntry->interfaceName);	// protocol address	ipNumEditField = (CIPNumberEditField*)FindPaneByID(kProtocolAddrField);	ThrowIfNil_(ipNumEditField);	inArpEntry->protocolAddr = ipNumEditField->GetValue();	// protocol mask	ipNumEditField = (CIPNumberEditField*)FindPaneByID(kProtocolMaskField);	ThrowIfNil_(ipNumEditField);	inArpEntry->protocolMask = ipNumEditField->GetValue();	// hardware address	textEditField = (LEditField*)FindPaneByID(kHardwareAddrField);	ThrowIfNil_(textEditField);	textEditField->GetDescriptor(str);	HW_StrToInt(str, &inArpEntry->hardwareAddr);	// arp flags	inArpEntry->arpFlags = 0;	theCheckBox = (LStdCheckBox*)FindPaneByID(kPermanentCheckBox);	ThrowIfNil_(theCheckBox);	if (theCheckBox->GetValue()) inArpEntry->arpFlags |= kArpFlagPermanent;		theCheckBox = (LStdCheckBox*)FindPaneByID(kPublishCheckBox);	ThrowIfNil_(theCheckBox);	if (theCheckBox->GetValue()) inArpEntry->arpFlags |= kArpFlagPublish;	theCheckBox = (LStdCheckBox*)FindPaneByID(kMappingCheckBox);	ThrowIfNil_(theCheckBox);	if (theCheckBox->GetValue()) inArpEntry->arpFlags |= kArpFlagMapping;}// ---------------------------------------------------------------------------------//		¥ IoctlResponse// ---------------------------------------------------------------------------------//	IoctlResponse - an ioctl completed process the resultvoidCArpWindow::IoctlResponse(long inResult){	switch (inResult) {		case 3:				// get NDD forwarding unknown result?		case 0:				// no error			mStatusCaption->SetDescriptor("\pOK");			break;		case kOTNotFoundErr:			mStatusCaption->SetDescriptor("\pkOTNotFoundErr.");			break;				case kEINVALErr:			mStatusCaption->SetDescriptor("\pkEINVALErr - Invalid parameter.");			break;		case kOTDuplicateFoundErr:					mStatusCaption->SetDescriptor("\pkOTDuplicateFoundErr.");			break;		case kEBUSYErr:			mStatusCaption->SetDescriptor("\pkEBUSYErr - Device or resource busy.");			break;		case kENXIOErr:			mStatusCaption->SetDescriptor("\pNo such device or address.");			break;		case kEAGAINErr:			mStatusCaption->SetDescriptor("\pkEAGAINErr - Try operation again later.");			break;		default:			{				LStr255	status;				status = "\pioctl unexpected result code: ";				Str32 str;				NumToString(inResult, str);				status += str;				mStatusCaption->SetDescriptor( status );			}			break;	}	// end switch}#pragma mark --- nslookup ---// ---------------------------------------------------------------------------//		¥ NameToAddress// ---------------------------------------------------------------------------//	Lookup IP Address from namevoidCArpWindow::LookupNameToAddress(){	// if a lookup thread is already in progress, just return	if (mInetMapperThread) return;		mLookupType = kLookupNameToAddress;		// launch thread to perform lookup	mInetMapperThread = new CInetMapperThread(		(CObjectMaster*)	this,		(LWindow*)			this,		(LInternetMapper*)	mMapper,		(UInt8)				kLookupNameToAddress);	mInetMapperThread->Resume();}// ---------------------------------------------------------------------------//		¥ Lookup Address To Name// ---------------------------------------------------------------------------//	Lookup Host Name from IP AddressvoidCArpWindow::LookupAddressToName(){	// if a lookup thread is already in progress, just return	if (mInetMapperThread) return;		mLookupType = kLookupAddressToName;		// launch thread to perform lookup	mInetMapperThread = new CInetMapperThread(		(CObjectMaster*)	this,		(LWindow*)			this,		(LInternetMapper*)	mMapper,		(UInt8)				kLookupAddressToName);	mInetMapperThread->Resume();}// ---------------------------------------------------------------------------//		¥ AbortLookup// ---------------------------------------------------------------------------//	Abort DNS lookup in progress//		Since we can't actually cancel the DNS request://			Delete the mapper object to ignore the response or timeout//			Create a new mapper to allow the user to enter another request.voidCArpWindow::AbortLookup(){	if (mInetMapperThread) {		mInetMapperThread->AbortLookup();		LThread::Yield();					// give thread a chance to abort	}}// ---------------------------------------------------------------------------------//		¥ LookupBegin// ---------------------------------------------------------------------------------//	Method called to update window appearance during DNS lookupvoidCArpWindow::LookupBegin(){	LView*	printView;		mPendingLookup = true;	if (mSpinCursor != nil) {		AddAttachment(mSpinCursor);		// Attach SpinCursor to this window				// Attach SpinCursor to printView and subPanes		printView = (LView*) this->FindPaneByID(kPrintView);		ThrowIfNil_(printView);		printView->AddAttachment(mSpinCursor);						// Attach SpinCursor to all subpanes of printView		TArrayIterator<LPane*> iterator(printView->GetSubPanes(), LArrayIterator::from_Start);		LPane	*theSub;		while (iterator.Next(theSub)) {			theSub->AddAttachment(mSpinCursor);		}		// Attach LBeep to LookUp button		// 	so we aren't hit again until the lookup completes.		LButton	*theButton;		theButton = (LButton*) FindPaneByID(kLookUpButton);		theButton->AddAttachment(mBeepAttachment);				if (IsActive()) mSpinCursor->StartIdling();	}}// ---------------------------------------------------------------------------------//		¥ LookupComplete// ---------------------------------------------------------------------------------//	Method called by PingTest object to indicate DNS Lookup has completedvoidCArpWindow::LookupComplete(Boolean lookupSucceeded){	LView*	printView;	mPendingLookup = false;	if (mSpinCursor != nil) {		mSpinCursor->StopIdling();				// Remove SpinCursor attachment from all subpanes		printView = (LView*) this->FindPaneByID(kPrintView);		ThrowIfNil_(printView);		TArrayIterator<LPane*> iterator(printView->GetSubPanes(), LArrayIterator::from_Start);		LPane	*theSub;		while (iterator.Next(theSub)) {			theSub->RemoveAttachment(mSpinCursor);		}		printView->RemoveAttachment(mSpinCursor);		RemoveAttachment(mSpinCursor);	// Remove SpinCursor attachment from this window		// Remove LBeep from LookUp button		// 	so we aren't hit again until the lookup completes.		LButton	*theButton;		theButton = (LButton*) FindPaneByID(kLookUpButton);		theButton->RemoveAttachment(mBeepAttachment);	}	// save the address we looked up if any	if (lookupSucceeded) { 		LEditField* theEditField = (LEditField*) this->FindPaneByID( kHostAddressField );		ThrowIfNil_(theEditField);		mLookupAddress = theEditField->GetValue();	} else mLookupAddress = nil;}// ---------------------------------------------------------------------------------//		¥ ActivateSelf// ---------------------------------------------------------------------------------voidCArpWindow::ActivateSelf(){	CWindow::ActivateSelf();	// inherit behavior	// if look up in progress, resume spinning cursor	if (mPendingLookup && mSpinCursor) mSpinCursor->StartIdling();}// ---------------------------------------------------------------------------------//		¥ DeactivateSelf// ---------------------------------------------------------------------------------voidCArpWindow::DeactivateSelf(){	if (mSpinCursor) mSpinCursor->StopIdling();	// turn off spinning cursor	CWindow::DeactivateSelf();	// inherit behavior}// ---------------------------------------------------------------------------//		¥ ObjectThreadDied// ---------------------------------------------------------------------------//	A threaded operation has completed.voidCArpWindow::ObjectThreadDied(LThread *inThread) {		// DNS Lookup completed?	if (inThread == mInetMapperThread) {		// get result		long result = *((long*)inThread->GetResult());		// indicate thread no longer exists		mInetMapperThread = nil;		// handle results		if (result == 0) {	// no error			LookupComplete(true);			mCanRetry = true;			mLookupType = kLookupNone;		} else {			LookupComplete(false);			// get a new mapper			if (mMapper != nil) {				delete mMapper;				mMapper = new LOpenTptInetMapper();				ThrowIfNil_(mMapper);			}			if ((result == kOTOutStateErr) && (mCanRetry)) {				// try again				mCanRetry = false;				LookupBegin();				if (mLookupType == kLookupAddressToName) {					LookupAddressToName();				} else if (mLookupType == kLookupNameToAddress) {					LookupNameToAddress();				}			} else mLookupType = kLookupNone;		}	}}