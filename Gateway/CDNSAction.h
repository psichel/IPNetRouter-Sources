// =================================================================================//	CDNSAction.h	 	©1999 Sustainable Softworks. All rights reserved.// =================================================================================//	Perform DNS Deferral////	IPNetRouter does DNS forwarding using the NAT feature when there//	is no PPP interface or PPP is connected.  The NAT module is//  programmed to translate DNS requests to our local address to//  the currently configured DNS server, and the IP module forwards//	them.////	When PPP is disconnected, the DNS NAT mappings are disabled so//  this module can receive DNS traffic and perform DNS Deferral.//	We intercept simple DNS lookup requests and generate an//	intermediate response at 2 second intervals until PPP comes//	back on-line (or we time out).  The purpose of these intermediate//	responses is to prevent the clients DNR from timing out while//  waiting for PPP to connect.////	We never actually forward a DNS request on behalf of a client,//	rather, we string the client along with one CNAME after another//	until the DNS port mappings are back online, then we tell the//	client to retry the original DNS request, but this time the request//  is redirected to a real Name Server by the NAT module.#pragma once#include "myDNS.h"	// pick up protocol definitions#include <LCleanupTask.h>#include <LPeriodical.h>#include <LListener.h>#include "CObjectMaster.h"#define kMaxServerDim	4// Generic message descriptorstruct msg_descriptor {	UInt8*	data;	// pointer to buffer containing message	UInt32	size;	// size of message in buffer	UInt16	offset;	// offset to next item in message};typedef struct msg_descriptor msg_descriptor_t;#define kMaxResponseLen	1460// DNS request (collect DNS message information)struct dns_request {	msg_descriptor_t md;	UInt16	remotePort;	UInt32	remoteAddr;	OTTimeStamp	timeStamp;	// time when received	// data buffer	UInt8	buf[kMaxResponseLen];};typedef struct dns_request dns_request_t;// when to check timeoutsconst SInt16 kDNSIdleDefault		= 5000;	// test every 5 secondsconst SInt16 kDNSIdleRestart		= 2000;	// restart after 2 secondconst SInt16 kDNSIdleData			= 200;	// data waiting, every 250 msconst SInt16 kDNSRetryCount			= 10;	// number times to try restarting// dns deferral stringsconst Str31 kDialingPrefixStr		= "\p.dialing-please-wait-";const Str31 kDialingSufixStr		= "\p.apple.com";class CTurboUDPEndpoint;class CReceiveUDPThread;class CSendUDPThread;class LArray;class LComparator;class LFile;class CDNSAction :	public LPeriodical, LListener, CObjectMaster {public:								CDNSAction();	virtual		 				~CDNSAction();	void				Terminate(Boolean inCanWait=true);	Boolean				StartServing();	Boolean				StopServing(Boolean inCanWait=true);	void				StopDeferral();	void				ResumeDeferral();	virtual void		SpendTime(const EventRecord &inMacEvent);	virtual void		ObjectThreadDied(LThread *inThread);	void				ListenToMessage(							MessageT	inEventCode,							void		*ioParam );	void				ReceiveData(LDataArrived* inMessage);protected:	void				ProcessRequest(dns_request_t* inRequest);	Boolean				SendResponse(dns_request_t* inRequest);	OTResult			ForwardToDNS(UInt8* inData, UInt32 inDataSize);	void				ReceiveDNRProxy(LDataArrived* inMessage);	OTResult			ForwardFromDNS(UInt8* inData, UInt32 inDataSize);	Boolean				GetDName(msg_descriptor_t* md, Str255 outStr);	Boolean				PutDName(msg_descriptor_t* md, ConstStr255Param inStr);	UInt8				IsFakeDialingName(ConstStr255Param inStr);	long				GetFakeDialingName(ConstStr255Param inStr, Str255 outStr);	StringPtr			GetRealDialingName(ConstStr255Param inStr, Str255 outStr);	void				LastComplete();	LArray*				mResponseArray;	Boolean				mIsServing;	Boolean				mWaitingToStop;	Boolean				mWaitingToRestart;	UInt8				mDNSRetryCount;	private:		// UDP query	UInt32				mServerAddr[kMaxServerDim];	CTurboUDPEndpoint*	mUDPEndpoint;				// our UDP network endpoint object	CReceiveUDPThread*	mReceiveUDPThread;	CSendUDPThread*		mSendUDPThread;	OTTimeStamp			mLastStamp;	OTTimeStamp			mStopStamp;	UInt32				mIdleDelay;					// milliseconds	// Local DNS forwarding	CTurboUDPEndpoint*	mDNRProxyEndpoint;	CReceiveUDPThread*	mDNRProxyRxThread;	UInt32				mDNRSourceAddr;	UInt16				mDNRSourcePort;};