// =================================================================================//	CDialupDNSClient.cp			©1999 Sustainable Softworks All rights reserved.// =================================================================================//	Establish connection to dialup DNS server as needed#include "CompileFlags.h"#include "CDialupDNSClient.h"#include "MacSupport.h"#include "IPSupport.h"#include "CLogAction.h"#include "CResidentIfInfo.h"#include "CGatewayData.h"#include <LString.h>#include "CReceiveTCPThread.h"#include "CSendTCPThread.h"#include <LTCPEndpoint.h>#include <LOpenTptTCPEndpoint.h>#include <OpenTransport.h>#include <OpenTptInternet.h>// Globalsextern CLogAction*			gLogAction;extern CResidentIfInfo*		gResInfo;extern CGatewayData* 		gGatewayData;// ---------------------------------------------------------------------------------//		¥ CDialupDNSClient()// ---------------------------------------------------------------------------------CDialupDNSClient::CDialupDNSClient(){	// other initialization	mReceiveTCPThread = nil;	mSendTCPThread = nil;	mTCPEndpoint = nil;	mRetryCount = kDialupDNSRetryCount;	mIsActive = false;	mWaitingToRestart = false;}// ---------------------------------------------------------------------------------//		¥ ~CDialupDNSClient// ---------------------------------------------------------------------------------CDialupDNSClient::~CDialupDNSClient(){	CloseConnection();}// ---------------------------------------------------------------------------------//		¥ Terminate// ---------------------------------------------------------------------------------voidCDialupDNSClient::Terminate(Boolean inCanWait){	// Release thread objects we created	if (mReceiveTCPThread) mReceiveTCPThread->Abort();	if (mSendTCPThread) mSendTCPThread->Abort();	if (inCanWait) {		// Wait for threads to abort normally		UInt8 retryLimit = 24;		while (	(mReceiveTCPThread != nil)	||				(mSendTCPThread != nil) ) {			LThread::Yield();			retryLimit -= 1;			if (retryLimit == 0) break;		}	}		// if threads didn't complete, cleanup as best we can	if (mReceiveTCPThread) {		mReceiveTCPThread->DeleteThread();		mReceiveTCPThread = nil;	}	if (mSendTCPThread) {		mSendTCPThread->DeleteThread();		mSendTCPThread = nil;	}	// Release the TCP Endpoint we created	if (mTCPEndpoint) {		// no longer want notification of endpoint events		mTCPEndpoint->RemoveListener(this);		delete mTCPEndpoint;		mTCPEndpoint = nil;	}}// ---------------------------------------------------------------------------------//		¥ InitConnection// ---------------------------------------------------------------------------------BooleanCDialupDNSClient::InitConnection(){	mRetryCount = kDialupDNSRetryCount;	return OpenConnection();}// ---------------------------------------------------------------------------------//		¥ OpenConnection// ---------------------------------------------------------------------------------BooleanCDialupDNSClient::OpenConnection(){	OSErr		err = noErr;	Boolean		result = false;	Str255		inServerAddress;	SInt32		inServerPort;	LStr255		partStr;	UInt8		pos;	// read address from resource	::GetIndString(inServerAddress, rDialupDNS_STRN, kDialupDNS_ServerStr);	inServerPort = kDialupDNSServerPort;	// default to port 81	partStr = inServerAddress;				// look for port number as name:port	pos = partStr.Find( ':' );	if (pos != 0) {		// get port string from end		partStr.Assign(partStr, pos+1);		::StringToNum(partStr, &inServerPort);		// shorten address string accordingly		inServerAddress[0] = pos-1;	}		try {				//	Create a TCP endpoint		if (!mTCPEndpoint) {			mTCPEndpoint = new LOpenTptTCPEndpoint();			//mTCPEndpoint = new LTCPEndpoint();			ThrowIfNil_(mTCPEndpoint);			mTCPEndpoint->QueueSends();			// Register to receive other event notifications			mTCPEndpoint->AddListener(this);		}		// Create thread objects for receive and transmit		if (!mReceiveTCPThread) {			mReceiveTCPThread = new CReceiveTCPThread(				(CObjectMaster*)	this,				(LTCPEndpoint*) 	mTCPEndpoint,				(ConstStr255Param)	inServerAddress,				(UInt16)			inServerPort);			ThrowIfNil_(mReceiveTCPThread);			mReceiveTCPThread->Resume();		}		if (!mSendTCPThread) {			mSendTCPThread = new CSendTCPThread(				(CObjectMaster*)	this,				(LTCPEndpoint*) mTCPEndpoint);		// coerce to re-use code			ThrowIfNil_(mSendTCPThread);			mSendTCPThread->Resume();		}		mIsActive = true;		// record server start time		::OTGetTimeStamp(&mLastStamp);		// tell user		gLogAction->LogText("\p\rDialup DNS Client: open connection");		result = true;	}	catch (...) {		gLogAction->LogText("\p\rUnexpected result while starting DialupDNS Client");	} 	return result;}// ---------------------------------------------------------------------------------//		¥ CloseConnection// ---------------------------------------------------------------------------------BooleanCDialupDNSClient::CloseConnection(Boolean inCanWait){		if (mIsActive) gLogAction->LogText("\p\rDialup DNS Client: closing connection");	mIsActive = false;	// stop waiting	this->StopIdling();	// close connection	if (mReceiveTCPThread) mReceiveTCPThread->StartDisconnect();		// clean up	Terminate(inCanWait);	return true;}// ---------------------------------------------------------------------------//		¥ ObjectThreadDied// ---------------------------------------------------------------------------//	A threaded operation has completed.voidCDialupDNSClient::ObjectThreadDied(LThread *inThread) {	// Receive Thread completed?	if (inThread == mReceiveTCPThread) {		// get result		long result = *((long*)inThread->GetResult());		// indicate thread no longer exists		mReceiveTCPThread = nil;		LastComplete();		// handle results		switch (result) {			case 0:				// no error			case Abort_Error:	// operation aborted				result = 0;				break;			case kOTAccessErr:				gLogAction->LogText("\p\r### DialupDNSClient CReceiveTCPThread result code: ", result);				result = 0;				break;			default:				gLogAction->LogText("\p\r### DialupDNSClient CReceiveTCPThread unexpected event code: ", result);				break;		}	// end switch		if (result != 0) {			// Thread died due to Endpoint event, try to recover			if (mIsActive) {				CloseConnection(true);				mIdleDelay = kDialupDNSIdleRestart;		// set idle time for restart				OTGetTimeStamp(&mLastStamp);				mWaitingToRestart = true;				this->StartIdling();				//UpdateConnection();			}		}	}		// Transmit Thread completed?	else if (inThread == mSendTCPThread) {		// get result		long result = *((long*)inThread->GetResult());		// indicate thread no longer exists		mSendTCPThread = nil;		LastComplete();			// handle results		switch (result) {			case 0:				// no error			case Abort_Error:	// operation aborted				result = 0;				break;			default:				gLogAction->LogText("\p\r### DNSAction CSendTCPThread unexpected event code: ", result);				break;		}	// end switch		if (result != 0) {			// Thread died due to Endpoint event, try to recover			if (mIsActive) {				CloseConnection(true);				mIdleDelay = kDialupDNSIdleRestart;		// set idle time for restart				OTGetTimeStamp(&mLastStamp);				mWaitingToRestart = true;				this->StartIdling();				OpenConnection();			}		}	}}// ---------------------------------------------------------------------------------//		¥ LastComplete// ---------------------------------------------------------------------------------//	Release our TCP endpoint only after all threads have safely completedvoidCDialupDNSClient::LastComplete(){	if ((mReceiveTCPThread == nil) &&		(mSendTCPThread == nil)) {		// Release the TCP Endpoint we created		if (mTCPEndpoint) {			mTCPEndpoint->RemoveListener(this);			delete mTCPEndpoint;			mTCPEndpoint = nil;		}	}}// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------//	Listen for other notifications from endpoint//		BroadcastMessage(nextMessage->GetMessageType(), nextMessage);voidCDialupDNSClient::ListenToMessage(	MessageT	inEventCode,	void		*ioParam ){	LNetMessage* inMessage = (LNetMessage*)ioParam;	switch ( inEventCode ) {		case kOTProviderWillClose:		case kOTProviderIsClosed:			Terminate(false);			gLogAction->LogText("\p\rDNSAction:  OT Provider has closed.");			break;		case msg_BroadcasterDied:		default:			gLogAction->LogText("\p\rDialup DNS Client unexpected async message type: ", inEventCode);			gLogAction->LogText("\p\r  Result code: ", inMessage->GetResultCode());			// try to recvoer			if (mIsActive) {				CloseConnection(true);				if (mRetryCount > 0) {					mRetryCount -= 1;					mIdleDelay = kDialupDNSIdleRestart;		// set idle time for restart					OTGetTimeStamp(&mLastStamp);					mWaitingToRestart = true;					this->StartIdling();					//OpenConnection();				}			}	}}#pragma mark --- Handle Requests ---// ---------------------------------------------------------------------------//		¥ Receive Data// ---------------------------------------------------------------------------//	Handle data that arrived from the network.voidCDialupDNSClient::ReceiveData(LDataArrived* inMessage){	UInt8*	data;	UInt32	size;	LStr255	loginStr;	Str255	str;		// setup access to message data	data = (UInt8*)inMessage->GetDataBuffer();	size = inMessage->GetDataSize();	if (size < 255) {		::BlockMove(data, &str[1], size);		if ((str[size] == '\n') || (str[size] == '\r')) size = size-1;		if ((str[size] == '\n') || (str[size] == '\r')) size = size-1;		str[0] = size;		// log received string		gLogAction->LogText("\p\rRECV> ");		gLogAction->LogText(str);		gLogAction->Update();		// if received "Connect"		loginStr = str;		if (loginStr.BeginsWith("\pConnect")) {			// build login string			loginStr = "\pHello:";			gGatewayData->GetDataDialupUsername(str);			loginStr += str;			loginStr += '^';			gLogAction->LogText("\p\rSEND> ");			gLogAction->LogText(loginStr);			gLogAction->LogText("\p¥¥¥");			gLogAction->Update();			gGatewayData->GetDataDialupPassword(str);			loginStr += str;			loginStr += '\r';			loginStr += '\n';			// and send it			mSendTCPThread->SendData(&loginStr[1], loginStr.Length());			// reinitialize retry counter for next time			//mRetryCount = kDialupDNSRetryCount;		}	}}// ---------------------------------------------------------------------------//		¥ SpendTime// ---------------------------------------------------------------------------//	Periodical function to test if we have a request waiting//	or other pending action.voidCDialupDNSClient::SpendTime(const EventRecord &inMacEvent){#pragma unused (inMacEvent)	UInt32		deltaTime;	// do every "mIdleDelay" milliseconds	deltaTime = OTElapsedMilliseconds(&mLastStamp);	if (deltaTime > mIdleDelay) {		OTGetTimeStamp(&mLastStamp);		do {			// check if pending restart			if (mWaitingToRestart) {				mWaitingToRestart = false;				CloseConnection(true);				OpenConnection();				break;				}		} while (false);	}	// end if (deltaTime > mIdleDelay)}