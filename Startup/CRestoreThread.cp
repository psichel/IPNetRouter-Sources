// ===========================================================================//	CRestoreThread.cp	 	й2000 Sustainable Softworks. All rights reserved.// ===========================================================================//	Thread object to step through restore config file sequence#include "CRestoreThread.h"#include "CLogAction.h"#include "CInterfacesData.h"#include "CInterfacesAction.h"#include "CRoutesData.h"#include "CRoutesAction.h"#include "CPortMapData.h"#include "CPortMapAction.h"#include "CFilterData.h"#include "CFilterAction.h"#include "CGatewayData.h"#include "CGatewayAction.h"#include "CConnectionData.h"#include "CDeviceData.h"#include "CDHCPData.h"#include "CIPRouterApp.h"#include "CRegisterConst.h"#include "MacSupport.h"// Globalsextern CLogAction*			gLogAction;extern CResidentIfInfo* 	gResInfo;extern CInterfacesData*		gInterfacesData;extern CInterfacesAction*	gInterfacesAction;extern CRoutesData*			gRoutesData;extern CRoutesAction*		gRoutesAction;extern CPortMapData*		gPortMapData;extern CPortMapAction*		gPortMapAction;extern CFilterData*			gFilterData;extern CFilterAction*		gFilterAction;extern CGatewayData*		gGatewayData;extern CGatewayAction*		gGatewayAction;extern CConnectionData*		gConnectionData;extern CDeviceData*			gDeviceData;extern CDHCPData*			gDHCPData;extern CIPRouterApp*		gAppObject;extern UInt8				gApplicationMode;// ===========================================================================#pragma mark еее CRestoreThread еееCRestoreThread::CRestoreThread(CObjectMaster* inObjectMaster)		: LThread(false, thread_DefaultStack, threadOption_Default, nil),		mObjectMaster(inObjectMaster)		  {}// ---------------------------------------------------------------------------//		е ~CRestoreThread// ---------------------------------------------------------------------------CRestoreThread::~CRestoreThread(){}// ---------------------------------------------------------------------------//		е Run// ---------------------------------------------------------------------------void*CRestoreThread::Run(){	OTResult result;	mResult = kOTNoError;	// if application is just starting up, wait 15 seconds	if ((gApplicationMode & kModeFBA) && gAppObject->mStartupPause) {//	if (gAppObject->mStartupPause) {		gLogAction->LogText("\p\rCRestoreThread - Pause for system startup");		gAppObject->mStartupPause = false;		LThread::Sleep(15000);	}	// try to load a saved configuration	try {						// Update Interfaces and Routes data to make sure we are current		for (UInt8 i=1; i<=4; i++) {			result = gInterfacesAction->UpdateInterfacesData();			if (result != kEAGAINErr) break;			gLogAction->LogText("\p\rCRestoreThread - kEAGAIN update interfaces try again later.");			LThread::Sleep(2000);		}		//ThrowIfError_(result);		for (UInt8 i=1; i<=4; i++) {			result = gRoutesAction->UpdateRoutesData();			if (result != kEAGAINErr) break;			gLogAction->LogText("\p\rCRestoreThread - kEAGAIN update routes try again later.");			LThread::Sleep(2000);		}		//ThrowIfError_(result);				// Filters		// Load filters before interfaces for security		result = gFilterAction->LoadFilterConfig(gFilterData->mFilterData);		if (result == kOTNoError) {			delete gFilterData->mFilterData;			gFilterData->mFilterData = nil;		}		else {			gLogAction->LogText("\p\rCRestoreThread - Error restoring IP Filter settings: ", result);			gLogAction->LogText("\p\r  See Filter Window for additional information.");		}		// set IP forwarding		if (true) {			UInt8 forwarding = gGatewayData->GetDataIPforwarding();			if (forwarding == kForwardingNever) {				result = gInterfacesAction->SetOTParameter(kForwardingName, "\p0");			}			else if (forwarding == kForwardingAlways) {				result = gInterfacesAction->SetOTParameter(kForwardingName, "\p1");			}			else if (forwarding == kForwardingAutomatic) {				result = gInterfacesAction->SetOTParameter(kForwardingName, "\p2");			}		}		// Interfaces		result = gInterfacesAction->LoadIfConfig(gInterfacesData->mInterfacesData);		if (result == kOTNoError) {			delete gInterfacesData->mInterfacesData;			gInterfacesData->mInterfacesData = nil;		}		else {			gLogAction->LogText("\p\rCRestoreThread - Error restoring IP Interface settings: ", result);			gLogAction->LogText("\p\r  See Interfaces Window for additional information.");			if (gApplicationMode & kModeApple) gAppObject->ObeyCommand(cmd_Quit, nil);		}		// let interfaces settle		LThread::Sleep(1000);		// if PPP, pause a little more to let PPP start dialing		if (gResInfo->IsMonitoringPPP()) LThread::Sleep(4000);		// PortMap data is restored when masquerading is enabled				// check if waiting for PPP connection		Boolean isWaitForPPP = false;		while (gConnectionData->GetDataLinkState() == kLinkStateConnecting) {			isWaitForPPP = true;			LThread::Sleep(2000);		}		// check if waiting for PPP interface to come up		if (isWaitForPPP) {			LThread::Sleep(1000);	// allow first attempt to complete			for (UInt8 i=1; i<=5; i++) {				if (gResInfo->IsPPPComplete()) break;				else LThread::Sleep(2000);			}		}				// update routes data		for (UInt8 i=1; i<=4; i++) {			result = gRoutesAction->UpdateRoutesData();			if (result != kEAGAINErr) break;			gLogAction->LogText("\p\rCRestoreThread - kEAGAIN update routes try again later.");			LThread::Sleep(2000);		}		// load routes		result = gRoutesAction->LoadRtConfig(gRoutesData->mRoutesData);		if (result == kOTNoError) {			delete gRoutesData->mRoutesData;			gRoutesData->mRoutesData = nil;		}		if (result != kOTNoError) {			gLogAction->LogText("\p\rCRestoreThread - Error restoring Routes settings: ", result);			gLogAction->LogText("\p\r  See Configure Routes Window for additional information.");			if (gApplicationMode & kModeApple) gAppObject->ObeyCommand(cmd_Quit, nil);		}		// startup DHCP as requested		if (gDHCPData->mSeenDHCPServerOn) gDHCPData->SetDataDHCPServerOn(true);		if (gDHCPData->mSeenDHCPVerboseLogging) gDHCPData->SetDataDHCPVerboseLogging(true);		// start Dialup DNS Client		gGatewayAction->DialupDNSClientStart();				// check registration key against our database and notify our server		// do this after a successful restore for a given reg key		//		// use Btdt resource to remember which key was tested and count how many		// times we have seen it.		// If app is registered and not in Apple mode...    	if ((gAppObject->mRegKey != 0) && !(gApplicationMode & kModeApple))    	{	// begin scope for resource objects        	RegInfo_t	regInfo;            Str255      str;            UInt32      prevKey = 0;            UInt32      prevCount = 0;            UInt32      key;            UInt32*     dp;    		StNewResource beenThere( (ResType)'Btdt',       // Btdt = Been there, done that!    				rRegD_RegistrationData2, 8, false );	// inDefaultSize, inGet1Resource    		if (beenThere.mResourceH) {                     // resource exists?    		    dp = (UInt32*)(*beenThere.mResourceH);    		    prevKey = dp[0];    // get previously tested key    		    prevCount = dp[1];    		}  			// try to read new reg info  			StResource regData( (ResType)'RegD',  				rRegD_RegistrationData2, false, false );	// inThrowFail, inGet1Resource  			if (regData.mResourceH) {  				LString::CopyPStr((UInt8*)(*regData.mResourceH), str);  				StringToRegInfo(str, &regInfo);           		// get information to send           		LStr255 regSendText;           		regSendText = regInfo.key;           		regSendText += "\p,";           		regSendText += regInfo.name;           		regSendText += "\p,";           		regSendText += regInfo.organization;           		regSendText += "\p,";           		regSendText += regInfo.copies;                // check that we haven't already tested this key                key = HexToNum(regInfo.key);                if ( (key != prevKey) || (prevCount%10 == 0) ) {                    // check key against database resource                    CheckKey(key, regSendText);                }               // update resource to show key we have tested               if (key != prevKey) prevCount = 0;               dp = (UInt32*)(*beenThere.mResourceH);               dp[0] = key;               dp[1] = prevCount + 1;  			}    	}   // end scope for stack based resource objects (write them out)	}	catch (const LException& inErr) {		mResult = inErr.GetErrorCode();		// try to tell the user what happened		gLogAction->LogText("\p\rError restoring saved settings: ", mResult);		// handle exception results		// just report result to Object Master	} 	SetResult(&mResult);	// set result so Object Master can retrieve it.	mObjectMaster->ObjectThreadDied(this);	return &mResult;}