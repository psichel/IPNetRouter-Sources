// ===========================================================================//	CNetscapeEvent.cp				©1997 Quicomm. All rights reserved.// ===========================================================================#include "CNetscapeEvent.h"#include <AppleEvents.h>#include <AEPackObject.h>#include <string.h>#include <UDesktop.h>#include <LString.h>#include "IPSupport.h"typedef unsigned char	Str8[8];Boolean	gBrowserFoundFlag = false;Str8	gBrowserClassID = {"WWW!"};Str8	gBrowserEventID = {"OURL"};OSType	gBrowserSignature;ProcessSerialNumber		gRunningBrowserPSN;void Send_Netscape_OpenURL(Ptr theURLStringPtr){OSErr			myErr;AEDesc			targetAddress;AppleEvent		myAppleEvent;short			myDataLength;Str255			myString;AEEventClass	theAEEventClass;AEEventID		theAEEventID;	if(!FindRunningBrowser())	{		ParamText("\pYou must have your browser running","\pfor on-line registrations or","\pon-line support.","\p(Netscape Navigator or Microsoft Explorer)");		UDesktop::Deactivate();		// Alert will swallow Deactivate event		NoteAlert(1006,nil);		UDesktop::Activate();		return; // just return if we don't have a running browser	}		myErr = SetFrontProcess(&gRunningBrowserPSN); // easier than launching!	myErr = AECreateDesc(typeProcessSerialNumber, (Ptr) &gRunningBrowserPSN,sizeof(ProcessSerialNumber), &targetAddress);			// we can use the same EventClass and EventID for Netscape and Internet Explorer since they are the same	// (not so for Mosaic)	//memcpy((Ptr)&theAEEventClass,(Ptr)&gBrowserClassID,4);	BlockMove((Ptr)&gBrowserClassID,(Ptr)&theAEEventClass,4);	//memcpy((Ptr)&theAEEventID,(Ptr)&gBrowserEventID,4);	BlockMove((Ptr)&gBrowserEventID,(Ptr)&theAEEventID,4);	myErr = AECreateAppleEvent(theAEEventClass,theAEEventID,&targetAddress,kAutoGenerateReturnID,kAnyTransactionID,&myAppleEvent);//		theSignature = 'MOSS';//		myErr = AECreateAppleEvent('WWW!','OURL',&targetAddress,kAutoGenerateReturnID,kAnyTransactionID,&myAppleEvent);		//strcpy((Ptr)myString,theURLStringPtr);	SmallStrCopy((UInt8*)myString,theURLStringPtr);	//myDataLength = strlen((Ptr)myString);	myDataLength = LString::CStringLength((Ptr)myString);	myErr = AEPutParamPtr(&myAppleEvent,'----','TEXT',myString,myDataLength);		myErr = AESend(&myAppleEvent,nil,kAENoReply+kAEAlwaysInteract+kAECanSwitchLayer,			kAENormalPriority,kAEDefaultTimeout,nil,nil);			myErr = AEDisposeDesc(&targetAddress);			myErr = AEDisposeDesc(&myAppleEvent);		}/********************************************************/// FindRunningBrowser returns:// false if no browser running// true if Netscape or Internet Explorer running and fills in gRunningBrowserPSNBoolean FindRunningBrowser(){	ProcessSerialNumber	tempPSN;	if(FindAProcess('APPL','MOSS',&tempPSN) == noErr)	{		//memcpy(&gRunningBrowserPSN,&tempPSN,8);		BlockMove(&tempPSN,&gRunningBrowserPSN,8);		gBrowserSignature = 'MOSS';		return(true);	}	if(FindAProcess('APPL','MSIE',&tempPSN) == noErr)	{		//memcpy(&gRunningBrowserPSN,&tempPSN,8);		BlockMove(&tempPSN,&gRunningBrowserPSN,8);		gBrowserSignature = 'MSIE';		return(true);	}		return(false);}/********************************************************/void	BringBrowserToForeground(){	OSErr	myErr;		if(!FindRunningBrowser())		return;		myErr = SetFrontProcess(&gRunningBrowserPSN); // easier than launching!}/**********************************************************/OSErr	FindAProcess(OSType typeToFind, OSType creatorToFind,			ProcessSerialNumberPtr processSN){	ProcessInfoRec		tempInfo;	FSSpec				procSpec;	Str31				processName;	OSErr				myErr = noErr;		//start at the beginning of the process list	processSN->lowLongOfPSN = kNoProcess;	processSN->highLongOfPSN = kNoProcess;		//init the process info record	tempInfo.processInfoLength = sizeof(ProcessInfoRec);	tempInfo.processName = (StringPtr)&processName;	tempInfo.processAppSpec = &procSpec;		do {		myErr=GetNextProcess(processSN);		if(myErr == noErr)			GetProcessInformation(processSN,&tempInfo);	}	while((tempInfo.processSignature != creatorToFind || tempInfo.processType != typeToFind) &&				myErr == noErr);		return(myErr);}