// ===========================================================================//	CSendTCPThread.h			©1997 Sustainable Softworks. All rights reserved.// ===========================================================================//	Thread object to Send TCP data using PP networking classes.////	So the object doesn't need to be created for each send,//	this thread will suspend itself until there is more data//	to send, or the mTerminate flag is set.////	Since the underlying transport already buffers and queues//	transmit data, no further buffering is provided here.//	Simply return false if we are already waiting for a send//	to complete when new data arrives.#pragma onceconst SInt16 kMaxSendSize = 2048;#include "CObjectMaster.h"#include <LThread.h>#include <LInternetAddress.h>#include <UOpenTptSupport.h>class LTCPEndpoint;class CSendTCPThread : 		public LThread {public:						CSendTCPThread(								CObjectMaster*		inObjectMaster,								LTCPEndpoint*		inNetworkEndpoint);	virtual				~CSendTCPThread();	void				Abort();	void				TerminateUponCompletion();	Boolean				Ioctl(UInt32 inCmd, void* inData);	Boolean				IsReady();	Boolean				SendData(		void*				inData,		UInt32				inDataSize);	protected:	virtual void*		Run();	CObjectMaster* 		mObjectMaster;	LTCPEndpoint*		mEndpoint;					// network endpoint object		Boolean				mAbort;						// Operation aborted	Boolean				mTerminate;					// Terminate thread upon completion	UInt32				mTimeoutSeconds;	LInternetAddress	mRemoteAddress;				// Send Destination	UInt8				mData[kMaxSendSize];		// transmit data buffer	UInt32				mDataSize;					// transmit data length	UInt32				mCmd;						// requested Ioctl command	void*				mIoctlData;					// Ioctl data	Boolean				mIsSuspended;				// suspended waiting for more data?		OSStatus			mResult;};