// ===========================================================================//	CSendTCPThread.cp	 	й1997 Sustainable Softworks. All rights reserved.// ===========================================================================//	Thread object to Send TCP data using PP networking classes.////	So the object doesn't need to be created for each send,//	this thread will suspend itself until there is more data//	to send, or the mTerminate flag is set.////	Since the underlying transport already buffers and queues//	transmit data, no further buffering is provided here.//	Simply return false if we are already waiting for a send//	to complete when new data arrives.#include "CSendTCPThread.h"#include <LTCPEndpoint.h>#include <PP_Networking.h>// ===========================================================================#pragma mark еее CSendTCPThread еееCSendTCPThread::CSendTCPThread(	CObjectMaster*		inObjectMaster,	LTCPEndpoint*		inNetworkEndpoint)		: LThread(false, thread_DefaultStack, threadOption_Default, nil),		  mObjectMaster(inObjectMaster),		  mEndpoint(inNetworkEndpoint)		  {	mAbort = false;	mTerminate = false;	mDataSize = 0;					// no data to send	mCmd = 0;						// no Ioctl to send	mTimeoutSeconds = 0;	mIsSuspended = false;			// not suspended waiting for more data}// ---------------------------------------------------------------------------//		е ~CSendTCPThread// ---------------------------------------------------------------------------CSendTCPThread::~CSendTCPThread(){}// ---------------------------------------------------------------------------//		е Abort// ---------------------------------------------------------------------------voidCSendTCPThread::Abort(){	if (!mAbort) {		mAbort = true;		mTerminate = true;		if (mIsSuspended) {			mIsSuspended = false;			this->Resume();		} else {			mEndpoint->AbortThreadOperation(this);		}	}}// ---------------------------------------------------------------------------//		е TerminateUponCompletion// ---------------------------------------------------------------------------voidCSendTCPThread::TerminateUponCompletion(){	mTerminate = true;}// ---------------------------------------------------------------------------//		е Ioctl()// ---------------------------------------------------------------------------//	Perform Ioctl on endpointBooleanCSendTCPThread::Ioctl(UInt32 inCmd, void* inData){	//Don't setup multiples	if (mCmd) return false;		mCmd = inCmd;	mIoctlData = inData;			// resume thread to perform Ioctl if necessary	if (mIsSuspended) {		mIsSuspended = false;		this->Resume();	}	return true;}// ---------------------------------------------------------------------------//		е IsReady()// ---------------------------------------------------------------------------//	Return whether Send TCP Thread is ready, that is,//	not waiting for a previous operation to complete due to flow control etc.BooleanCSendTCPThread::IsReady(){	return (mDataSize == 0);}// ---------------------------------------------------------------------------//		е SendUData// ---------------------------------------------------------------------------BooleanCSendTCPThread::SendData(		void*				inData,		UInt32				inDataSize){	//Don't setup multiples	if (mDataSize) return false;		// reject if data exceeds buffer size	if (inDataSize > kMaxSendSize) return false;		// copy data to free caller's buffer	mDataSize = inDataSize;	::OTMemcpy( (void*)&mData, inData, inDataSize);		// resume thread to send data	if (mIsSuspended) {		mIsSuspended = false;		this->Resume();	}		return true;}// ---------------------------------------------------------------------------//		е Run// ---------------------------------------------------------------------------void*CSendTCPThread::Run(){	mResult = 0;	try {		// loop until set to terminate upon completion		while (!mTerminate) {			// if no new requests			if ((mCmd == 0) && (mDataSize == 0)) {				// suspend until we have more to do.				mIsSuspended = true;				this->Suspend();				mIsSuspended = false;	// defensive				if (mAbort) break;			}			// Send Ioctl?			if (mCmd) {				//mEndpoint->Ioctl(mCmd, mIoctlData);	// use TurboTCPEndpoint				mCmd = 0;			}			// any data to send?			if (mDataSize) {				// send it				mEndpoint->SendData(&mData, mDataSize, false, mTimeoutSeconds);	// inExpedited, inTimeoutSeconds)				mDataSize = 0;			}		}	}	catch (const LException& inErr) {		mResult = inErr.GetErrorCode();		// handle exception results		// just report result to Object Master	} 	SetResult(&mResult);	// set result so Object Master can retrieve it.	mObjectMaster->ObjectThreadDied(this);	return &mResult;}