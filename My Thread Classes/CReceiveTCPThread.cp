// ===========================================================================//	CReceiveTCPThread.cp	 		©1997 Sustainable Softworks. All rights reserved.// ===========================================================================//	Thread object to handle receive from a TCP endpoint//	Open a connection to the specified server port and loop to receive//	data until connection times out or is otherwise terminated.////	We "Bind" and "Connect" from the receive thread so as not to miss//	any data when the connection is first established.  When used with//	CSendTCPThread, the send thread should be used after the//	connection is established.#include "CReceiveTCPThread.h"#include <LTCPEndpoint.h>#include <LString.h>#include <PP_Networking.h>#include "IPSupport.h"// ===========================================================================#pragma mark ¥¥¥ CReceiveTCPThread ¥¥¥CReceiveTCPThread::CReceiveTCPThread(	CObjectMaster*		inObjectMaster,	LTCPEndpoint*		inNetworkEndpoint,	ConstStr255Param	inServerAddress,	UInt16				inServerPort)		: LThread(false, thread_DefaultStack, threadOption_Default, nil),		  mObjectMaster(inObjectMaster),		  mEndpoint(inNetworkEndpoint)		  {	LString::CopyPStr(inServerAddress, mServerAddressString, sizeof(Str255));		mServerPort = inServerPort;	mTimeoutSeconds = 0;	// no timeout specified	mStartDisconnect = false;	mIsConnected = false;	// default - bind to any local port	LInternetAddress address(0, 0);	mLocalAddress = address;}// ---------------------------------------------------------------------------//		¥ ~CReceiveTCPThread// ---------------------------------------------------------------------------CReceiveTCPThread::~CReceiveTCPThread(){}// ---------------------------------------------------------------------------//		¥ Bind// ---------------------------------------------------------------------------//	Bind to specified local address (must be called before thread begins)voidCReceiveTCPThread::Bind(LInternetAddress&	inLocalAddress){	mLocalAddress = inLocalAddress;}// ---------------------------------------------------------------------------//		¥ IsConnected// ---------------------------------------------------------------------------BooleanCReceiveTCPThread::IsConnected(){	return mIsConnected;}// ---------------------------------------------------------------------------//		¥ StartDisconnect// ---------------------------------------------------------------------------voidCReceiveTCPThread::StartDisconnect(){	if (!mStartDisconnect) {		mStartDisconnect = true;		mIsConnected = false;		if (mEndpoint) mEndpoint->AbortThreadOperation(this);	}}// ---------------------------------------------------------------------------//		¥ Abort// ---------------------------------------------------------------------------//	Could use abortive disconnectvoidCReceiveTCPThread::Abort(){	if (!mStartDisconnect) {		mStartDisconnect = true;		mIsConnected = false;		if (mEndpoint) mEndpoint->AbortThreadOperation(this);	}}// ---------------------------------------------------------------------------//		¥ SetTimeout// ---------------------------------------------------------------------------voidCReceiveTCPThread::SetTimeout(UInt32 inTimeoutSeconds){	mTimeoutSeconds = inTimeoutSeconds;}// ---------------------------------------------------------------------------//		¥ Run// ---------------------------------------------------------------------------void*CReceiveTCPThread::Run(){	try {		// Bind to requested local endpoint		mEndpoint->Bind(mLocalAddress);				// Connect to remote address		LInternetAddress remoteAddress(mServerAddressString, mServerPort, true);		mEndpoint->Connect(remoteAddress, mTimeoutSeconds);		mIsConnected = true;		// Receive incomming data		try {			// reading			UInt8	outDataBuffer[kMaxTransferUnit];			UInt32	ioDataSize;			Boolean	outExpedited;						mStartDisconnect = false;						// Endless loop: Read data and process it.			while (!mStartDisconnect) {							// Read a block of data				ioDataSize = kMaxTransferUnit;	// reset maximum transfer unit				mEndpoint->ReceiveData(						(void*)outDataBuffer,						ioDataSize,				// UInt32&						outExpedited,			// Boolean&						mTimeoutSeconds);		// UInt32								{	// create LDataArrived message					MessageT theType;					if (outExpedited) theType = T_EXDATA;					else theType = T_DATA;										LDataArrived theMessage(						theType,					// MessageT				inMessageType						kOTNoError,					// ResultT				inResultCode						outDataBuffer,				// void*				inDataBuffer						ioDataSize,					// UInt32				inDataSize						&remoteAddress,				// LInternetAddress*	inRemoteAddress						false,						// Boolean				inMustReleaseMemory						mEndpoint);					// LEndpoint*			inEndpoint					// Callback to ObjectMaster with received data					mObjectMaster->ReceiveData(&theMessage);				}	// end scope for LDataArrived message								// give other threads a chance				LThread::Yield();			}		}		catch (const LException& inErr) {			mResult = inErr.GetErrorCode();			// handle no data results			switch (mResult) {				case OrderlyDisconnect_Error:					mIsConnected = false;					mEndpoint->AcceptRemoteDisconnect();					mResult = 0;		// indicate normal completion					break;				case Disconnect_Error:					mIsConnected = false;					break;				case Timeout_Error:					break;				//case Abort_Error:	// operation aborted				//	break;				default:					break;			}	// end switch		} 	}	catch(...) {		// set result code to indicated we never connected.		mResult = kOTAccessErr;	}	try {		// We're done with the connectionÉ bail out.		mIsConnected = false;		if (mEndpoint) {			if (mResult != kOTAccessErr) mEndpoint->Disconnect();			mEndpoint->Unbind();		}	}	catch(...) {	}		if (mStartDisconnect) mResult = Abort_Error;		SetResult(&mResult);	// set result so Object Master can retrieve it.	mObjectMaster->ObjectThreadDied(this);	return &mResult;}