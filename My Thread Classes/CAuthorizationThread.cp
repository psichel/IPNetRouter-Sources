// ===========================================================================//	CAuthorizationThread.cp	 	й1999 Sustainable Softworks. All rights reserved.// ===========================================================================//	Thread object to step through application Authorization sequence#include "CAuthorizationThread.h"#include "CIPRouterApp.h"#include "CDeviceData.h"#include "CInterfacesData.h"#include "CLogAction.h"#include "IPSupport.h"#include "MacSupport.h"#include "IPRouterCommon.h"#include <LInternetMapper.h>#include <LOpenTptInetMapper.h>#include <OpenTransport.h>#include <OpenTptInternet.h>#include <OpenTptLinks.h>// Globalsextern UInt8				gApplicationMode;extern CDeviceData*			gDeviceData;extern CInterfacesData*		gInterfacesData;extern CLogAction*			gLogAction;// ===========================================================================#pragma mark еее CAuthorizationThread еееCAuthorizationThread::CAuthorizationThread(	CIPRouterApp*		inApp)		: LThread(false, thread_DefaultStack, threadOption_Default, nil)		  {	mApp = inApp;}// ---------------------------------------------------------------------------//		е ~CAuthorizationThread// ---------------------------------------------------------------------------CAuthorizationThread::~CAuthorizationThread(){}// ---------------------------------------------------------------------------------//		е FindFirstEthernet// ---------------------------------------------------------------------------------// Find secondary NAT interface for use with TR Cable Modems// We assume this will be the first Ethernet interface currently configuredUInt32CAuthorizationThread::FindFirstEthernet(){	ArrayIndexT			numTableE, row;	InterfaceEntry_t	ifTableEntry;	DeviceEntry_t		deviceEntry;	UInt32				result = 0;			// scan list of interfaces	numTableE = gInterfacesData->GetDataCount();	for (row=1; row<=numTableE; row++) {		if ( !gInterfacesData->GetDataInterfacesArray(row, &ifTableEntry) ) continue;		if (::EqualString("\plo0", ifTableEntry.interfaceName, false, false)) continue;		// get interface info 		if (gDeviceData->FindDataDeviceArray(nil, ifTableEntry.portName, nil, &deviceEntry)) {			// if its an Ethernet devices, return index;			if ((deviceEntry.deviceType  == kOTEthernetDevice) ||				(deviceEntry.deviceType  == kOTFastEthernetDevice)) {				result = row;				break;			}		}	}	return result;}// ---------------------------------------------------------------------------------//		е GetParentDomain// ---------------------------------------------------------------------------------// Get parent domain from DNS name x.y.z.tld// Returns false if no value found or tld onlyBooleanCAuthorizationThread::GetParentDomain(Str255 inStr, Str255 outStr){	SInt32	pos, end, len;	Boolean	result = false;	end = inStr[0];	if (end > 0) {		// find start of value		pos = FindByte('.', &inStr[1], 0, end);		if (pos != 0) {			pos += 1;	// adjust for offset from inStr[1]			len = end - pos;			if ((len >= 0) && (len < 255)) {				outStr[0] = len;				::BlockMove(&inStr[pos+1], &outStr[1], len);				result = true;				// skip top level domain				end = outStr[0];				pos = FindByte('.', &outStr[1], 0, end);				if (pos == 0) result = false;			}		}	}	return result;}// ---------------------------------------------------------------------------//		е Run// ---------------------------------------------------------------------------// Return 0 if authorizedvoid*CAuthorizationThread::Run(){	UInt32		row;	UInt32		gatewayAddr;	Str255		gatewayName;	Str31		str;	LStr255		text;	LOpenTptInetMapper*	tMapper;	InterfaceEntry_t tableInterfaceEntry;	//OTResult	err;		mResult = 0;	// pause for Ethernet to come up	LThread::Sleep(1000);	do {		// step through Authorization sequence		try {			gLogAction->LogText("\p\rCAuthorizationThread:  Begin authorization sequence");			// Create a mapper object to access DNR services			tMapper = new LOpenTptInetMapper();			// find our IP address (use the address of the first Ethernet)			row = FindFirstEthernet();				if (!gInterfacesData->GetDataInterfacesArray(row, &tableInterfaceEntry)) break;			gatewayAddr = tableInterfaceEntry.interfaceAddr;			text = "\p\r Gateway address: ";			text += IP_NumToStr(gatewayAddr, str);			gLogAction->LogText(text);			// lookup domain name for this IP address//			text = "\ppm4-138.port.shore.net";		// *** testing			tMapper->AddressToName(gatewayAddr, text);			LString::CopyPStr(text, gatewayName);			text = "\p\r Gateway domain name: ";			text += gatewayName;			gLogAction->LogText(text);					}		catch (const LException& inErr) {			mResult = inErr.GetErrorCode();		} 		if (mResult != noErr) {			gLogAction->LogText("\p\rCAuthorizationThread result: ", mResult);			// quit if we didn't find a name for our IP address			if (mResult == kOTBadNameErr) {				mResult = kSTQuit;				gLogAction->LogText("\p\rNo authorization domain found, application will now quit.");			}			break;				}				// get Authorization Name from Option Settings		::GetIndString(str, rSTRN_OptionSettings, kOptionAuthorizationName);		GetKeywordValue(str, str);		// look for authorization string in each gateway domain		while (GetParentDomain(gatewayName, gatewayName)) {						text = str;			text += "\p.";			text += gatewayName;			gLogAction->LogText("\p\r Checking authorization: ");			gLogAction->LogText(text);			gLogAction->Update();			try {				// look for a corresponding entry				gatewayAddr = tMapper->NameToAddress(gatewayName);				// we found an entry, so quit				gLogAction->LogText("\p\r  Restriction found: ");				IP_NumToStr(gatewayAddr, str);				gLogAction->LogText(str);				break;			}			catch (...) {				mResult = 0;				gLogAction->LogText("\p\r  No restriction found");				continue;			} 		}			} while (false);	gLogAction->LogText("\p\rCAuthorizationThread:  Authorization sequence complete");	SetResult(&mResult);	// set result so Object Master can retrieve it.	mApp->ObjectThreadDied(this);	return &mResult;}