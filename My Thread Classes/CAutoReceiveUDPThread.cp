// ===========================================================================//	CAutoReceiveUDPThread.cp  й1997 Sustainable Softworks. All rights reserved.// ===========================================================================//	Thread object to handle receive (Rx) part of Ping Test#include "CompileFlags.h"#include "CAutoReceiveUDPThread.h"#include "CTurboUDPEndpoint.h"#include <LString.h>#include <PP_Networking.h>#include "CObjectMaster.h"#include "IPSupport.h"#include "CLogAction.h"#include "CompileFlags.h"// Globalsextern CLogAction*		gLogAction;// ===========================================================================#pragma mark еее CAutoReceiveUDPThread еееCAutoReceiveUDPThread::CAutoReceiveUDPThread(	CObjectMaster*		inObjectMaster,	CTurboUDPEndpoint*	inNetworkEndpoint)		: LThread(false, thread_DefaultStack, threadOption_Default, nil),		  mEndpoint(inNetworkEndpoint)		  {	mObjectMaster = inObjectMaster;	mAbort = false;	mCmd = 0;}// ---------------------------------------------------------------------------//		е ~CAutoReceiveUDPThread// ---------------------------------------------------------------------------CAutoReceiveUDPThread::~CAutoReceiveUDPThread(){}// ---------------------------------------------------------------------------//		е Abort// ---------------------------------------------------------------------------voidCAutoReceiveUDPThread::Abort(){	if (!mAbort) {		mAbort = true;		mEndpoint->AbortThreadOperation(this);	}}// ---------------------------------------------------------------------------//		е Ioctl()// ---------------------------------------------------------------------------//	Perform Ioctl on endpoint after receiving dataBooleanCAutoReceiveUDPThread::Ioctl(UInt32 inCmd, void* inData){	//Don't setup multiples	if (mCmd) return false;		mCmd = inCmd;	mIoctlData = inData;			return true;}// ---------------------------------------------------------------------------//		е Run// ---------------------------------------------------------------------------void*CAutoReceiveUDPThread::Run(){	LReentrantMemoryPool rxMemoryPool(kRxPoolSize);	LInterruptSafeList  rxMessageQueue;	mResult = kOTNoError;	try {		// Initialization: Bind to any local port		LInternetAddress address(0, 0);		mEndpoint->Bind(address);		// Setup for auto receive		mEndpoint->StartAutoReceive(			&rxMessageQueue,			&rxMemoryPool,			kRxPoolReserve,			kRxPoolMTU,			nil);				// Handle receive		while (!mAbort) {			try {				// wait for incoming data				mEndpoint->ContinueAutoReceive();				// handle any messages on the list				LInterruptSafeListMember*	p;				LInterruptSafeListIterator	iter(rxMessageQueue);				iter.Reset();				while (iter.Next(p))				{					LDataArrived* inMessage = (LDataArrived*) p;		// get message					mObjectMaster->ReceiveData(inMessage);				// process it					rxMessageQueue.Remove(inMessage);					// remove from list					mEndpoint->ReleaseAutoReceiveMessage(inMessage);	// release memory					/*// debugging *** show AR pool					UInt32 unused = rxMemoryPool.FreeMem();					gLogAction->LogText("\p\r### CAutoReceiveUDPThread unused pool: ");					Str31 str;					NumToString(unused, str);					gLogAction->LogText(str);					//*/										/*// debugging *** show shared pool					UInt32 unused = mEndpoint->CheckSharedPool();					gLogAction->LogText("\p\r### CAutoReceiveUDPThread shared pool: ");					Str31 str;					NumToString(unused, str);					gLogAction->LogText(str);					//*/				}				// Send Ioctl?				if (mCmd) {					mEndpoint->Ioctl(mCmd, mIoctlData);					mCmd = 0;				}			}			catch (const LException& inErr) {				mResult = inErr.GetErrorCode();				// handle no data results				switch (mResult) {					//case Timeout_Error:					case Abort_Error:						mResult = 0;		// indicate normal completion						mAbort = true;						break;					case ARPool_Reserve:						mAbort = true;						gLogAction->LogText("\p\rCAutoReceiveUDPThread Auto Receive Pool Exhausted.");						break;					case ARPool_Error:						mAbort = true;						gLogAction->LogText("\p\rCAutoReceiveUDPThread Auto Receive Pool Allocation failed.");						break;					default:						break;				}	// end switch			} 		}	// end while (!mAbort)	}	catch(...) {		gLogAction->LogText("\p\rCAutoReceiveUDPThread Unable to configure endpoint. ");	}	// We're done auto receiving	mEndpoint->StopAutoReceive();		// Don't try asynch Unbind since endpoint is about to go away	//try {	//	mEndpoint->Unbind();	//}	//catch(...) {	//}		SetResult(&mResult);	// set result so Object Master can retrieve it.	mObjectMaster->ObjectThreadDied(this);	return &mResult;}