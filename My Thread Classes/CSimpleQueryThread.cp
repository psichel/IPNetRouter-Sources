// ===========================================================================//	CSimpleQueryThread.cp	 		©1997 Sustainable Softworks. All rights reserved.// ===========================================================================//	Thread object that ecapsulates the idea of a simple TCP/IP query.//	Open a connection to the specified server port, send request,//	and receive response (if any).#include "CSimpleQueryThread.h"#include <LTCPEndpoint.h>#include <LString.h>#include <PP_Networking.h>#include "IPSupport.h"// ===========================================================================#pragma mark ¥¥¥ CSimpleQueryThread ¥¥¥CSimpleQueryThread::CSimpleQueryThread(	CObjectMaster*		inObjectMaster,	LTCPEndpoint*		inNetworkEndpoint,	ConstStr255Param	inQueryName,	ConstStr255Param	inServerAddress,	UInt16				inServerPort)		: LThread(false, thread_DefaultStack, threadOption_Default, nil),		  mObjectMaster(inObjectMaster),		  mEndpoint(inNetworkEndpoint)		  {	LString::CopyPStr(inQueryName, mQueryName, sizeof(Str255));	LString::CopyPStr(inServerAddress, mServerAddressString, sizeof(Str255));		mServerPort = inServerPort;	mTimeoutSeconds = 0;	// no timeout specified	mStartDisconnect = false;}// ---------------------------------------------------------------------------//		¥ ~CSimpleQueryThread// ---------------------------------------------------------------------------CSimpleQueryThread::~CSimpleQueryThread(){}// ---------------------------------------------------------------------------//		¥ StartDisconnect// ---------------------------------------------------------------------------voidCSimpleQueryThread::StartDisconnect(){	if (!mStartDisconnect) {		mStartDisconnect = true;		mEndpoint->AbortThreadOperation(this);	}}// ---------------------------------------------------------------------------//		¥ SetTimeout// ---------------------------------------------------------------------------voidCSimpleQueryThread::SetTimeout(UInt32 inTimeoutSeconds){	mTimeoutSeconds = inTimeoutSeconds;}// ---------------------------------------------------------------------------//		¥ Run// ---------------------------------------------------------------------------void*CSimpleQueryThread::Run(){	Boolean	gotResponse = false;	try {		// Initialization: Bind to any local port, then connect to the remote host.		LInternetAddress address(0, 0);		mEndpoint->Bind(address);				// Connect to remote address		LInternetAddress remoteAddress(mServerAddressString, mServerPort, true);		mEndpoint->Connect(remoteAddress, mTimeoutSeconds);		// transmit query command		void*	inData = &mQueryName[1];		UInt32	inDataSize = mQueryName[0];		mEndpoint->SendData(inData, inDataSize, false, mTimeoutSeconds);	// inExpedited, inTimeoutSeconds)		// Get response if any		try {			// reading			UInt8	outDataBuffer[kMaxTransferUnit];			UInt32	ioDataSize;			Boolean	outExpedited;			// writing			LStr255 buffer;						mStartDisconnect = false;						// Endless loop: Read data and process it.			while (!mStartDisconnect) {							// Read a block of data				ioDataSize = kMaxTransferUnit;	// reset maximum transfer unit				mEndpoint->ReceiveData(						(void*)outDataBuffer,						ioDataSize,				// UInt32&						outExpedited,			// Boolean&						mTimeoutSeconds);		// UInt32								gotResponse = true;								{	// create LDataArrived message					MessageT theType;					if (outExpedited) theType = T_EXDATA;					else theType = T_DATA;										LDataArrived theMessage(						theType,					// MessageT				inMessageType						kOTNoError,					// ResultT				inResultCode						outDataBuffer,				// void*				inDataBuffer						ioDataSize,					// UInt32				inDataSize						&remoteAddress,				// LInternetAddress*	inRemoteAddress						false,						// Boolean				inMustReleaseMemory						mEndpoint);					// LEndpoint*			inEndpoint					// Callback to ObjectMaster with received data					mObjectMaster->ReceiveData(&theMessage);				}	// end scope for LDataArrived message								// give other threads a chance				LThread::Yield();			}		}		catch (const LException& inErr) {			mResult = inErr.GetErrorCode();			// handle no data results			switch (mResult) {				case OrderlyDisconnect_Error:					mEndpoint->AcceptRemoteDisconnect();					mResult = 0;		// indicate normal completion					break;				case Disconnect_Error:				case Timeout_Error:					// if we got a response, just exit quietly					if (gotResponse) mResult = 0;					break;				//case Abort_Error:	// operation aborted				//	break;				default:					break;			}	// end switch		} 	}	catch(...) {		// set result code to indicated we never connected.		mResult = kOTAccessErr;	}	try {		// We're done with the connectionÉ bail out.		if (mResult != kOTAccessErr) mEndpoint->Disconnect();		mEndpoint->Unbind();	}	catch(...) {	}		if (mStartDisconnect) mResult = Abort_Error;		SetResult(&mResult);	// set result so Object Master can retrieve it.	mObjectMaster->ObjectThreadDied(this);	return &mResult;}