// ===========================================================================//	CReceiveUDPThread.cp  й1997 Sustainable Softworks. All rights reserved.// ===========================================================================//	Thread object to handle receive (Rx) part of Ping Test#include "CompileFlags.h"#include "CReceiveUDPThread.h"#include "CTurboUDPEndpoint.h"#include <LString.h>#include <PP_Networking.h>#include "CObjectMaster.h"#include "IPSupport.h"#include "CLogAction.h"#include "CompileFlags.h"// Globalsextern CLogAction*		gLogAction;// ===========================================================================#pragma mark еее CReceiveUDPThread еееCReceiveUDPThread::CReceiveUDPThread(	CObjectMaster*		inObjectMaster,	LUDPEndpoint*		inNetworkEndpoint)		: LThread(false, thread_DefaultStack, threadOption_Default, nil),		  mEndpoint(inNetworkEndpoint)		  {	mObjectMaster = inObjectMaster;	mAbort = false;	// default - bind to any local port	LInternetAddress address(0, 0);	mLocalAddress = address;}// ---------------------------------------------------------------------------//		е ~CReceiveUDPThread// ---------------------------------------------------------------------------CReceiveUDPThread::~CReceiveUDPThread(){}// ---------------------------------------------------------------------------//		е Bind// ---------------------------------------------------------------------------//	Bind to specified local address (must be called before thread begins)voidCReceiveUDPThread::Bind(LInternetAddress&	inLocalAddress){	mLocalAddress = inLocalAddress;}// ---------------------------------------------------------------------------//		е Abort// ---------------------------------------------------------------------------voidCReceiveUDPThread::Abort(){	if (!mAbort) {		mAbort = true;		mEndpoint->AbortThreadOperation(this);	}}// ---------------------------------------------------------------------------//		е Run// ---------------------------------------------------------------------------void*CReceiveUDPThread::Run(){	mResult = kOTNoError;	try {		// Bind to requested address		mEndpoint->Bind(mLocalAddress);		// Handle receive		while (!mAbort) {			try {				// read incoming data				// will block until there is data, timeout, or cancelled				LInternetAddress remoteAddress;				UInt8* dataBuffer[kReceiveBufferSize];				UInt32 dataSize;				UInt32 inTimeoutSeconds;								dataSize = kReceiveBufferSize;				inTimeoutSeconds = 0;								mEndpoint->ReceiveFrom(					remoteAddress,		// set on output					(void*)dataBuffer,					dataSize,			// in=buffersize, out=datasize					inTimeoutSeconds);				// pass received data as LDataArrived message to OjbectMaster				LDataArrived theMessage(					T_DATA,					// MessageT				inMessageType					kOTNoError,				// ResultT				inResultCode					(void *)dataBuffer,		// void*				inDataBuffer					dataSize,				// UInt32				inDataSize					&remoteAddress,			// LInternetAddress*	inRemoteAddress					false,					// Boolean				inMustReleaseMemory					mEndpoint);				// LEndpoint*			inEndpoint				mObjectMaster->ReceiveData(&theMessage);		// process it			}			catch (const LException& inErr) {				mResult = inErr.GetErrorCode();				// handle no data results				switch (mResult) {					//case Timeout_Error:					case Abort_Error:						mResult = 0;		// indicate normal completion						mAbort = true;						break;					case Timeout_Error:						mAbort = true;						break;					case kOTOutStateErr:						gLogAction->LogText("\p\rCReceiveUDPThread unexpected error code:", mResult);						mAbort = true;						break;					default:						gLogAction->LogText("\p\rCReceiveUDPThread unexpected error code:", mResult);						mAbort = true;						break;				}	// end switch			} 		}	// end while (!mAbort)	}	catch(...) {		gLogAction->LogText("\p\rCReceiveUDPThread Unable to configure endpoint. ");	}		// Don't try asynch Unbind since endpoint is about to go away	//try {	//	mEndpoint->Unbind();	//}	//catch(...) {	//}		SetResult(&mResult);	// set result so Object Master can retrieve it.	mObjectMaster->ObjectThreadDied(this);	return &mResult;}