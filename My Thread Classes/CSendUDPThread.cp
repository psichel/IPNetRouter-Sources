// ===========================================================================//	CSendUDPThread.cp	 	й1997 Sustainable Softworks. All rights reserved.// ===========================================================================//	Thread object to Send UDP data using PP networking classes.////	So the object doesn't need to be created for each send,//	this thread will suspend itself until there is more data//	to send, or the mTerminate flag is set.////	Since the underlying transport already buffers and queues//	transmit data, no further buffering is provided here.//	Simply return false if we are already waiting for a send//	to complete when new data arrives.#include "CSendUDPThread.h"#include "CTurboUDPEndpoint.h"#include <PP_Networking.h>// ===========================================================================#pragma mark еее CSendUDPThread еееCSendUDPThread::CSendUDPThread(	CObjectMaster*		inObjectMaster,	CTurboUDPEndpoint*	inNetworkEndpoint)		: LThread(false, thread_DefaultStack, threadOption_Default, nil),		  mObjectMaster(inObjectMaster),		  mEndpoint(inNetworkEndpoint)		  {	mAbort = false;	mTerminate = false;	mDataSize = 0;					// no data to send	mTTL = 0;						// no TTL to set	mBind = false;					// no Bind request	mOptionPending = false;			// no Option Managment request	mOptionCmd = nil;	mCmd = 0;						// no Ioctl to send	mIsSuspended = false;			// not suspended waiting for more data}// ---------------------------------------------------------------------------//		е ~CSendUDPThread// ---------------------------------------------------------------------------CSendUDPThread::~CSendUDPThread(){}// ---------------------------------------------------------------------------//		е Abort// ---------------------------------------------------------------------------voidCSendUDPThread::Abort(){	if (!mAbort) {		mAbort = true;		mTerminate = true;		if (mIsSuspended) {			mIsSuspended = false;			this->Resume();		} else {			mEndpoint->AbortThreadOperation(this);		}	}}// ---------------------------------------------------------------------------//		е TerminateUponCompletion// ---------------------------------------------------------------------------voidCSendUDPThread::TerminateUponCompletion(){	mTerminate = true;}// ---------------------------------------------------------------------------//		е Bind// ---------------------------------------------------------------------------//	Bind to local address for subsequent transmit datavoidCSendUDPThread::Bind(LInternetAddress&	inLocalAddress){	mLocalAddress = inLocalAddress;	mBind = true;}// ---------------------------------------------------------------------------//		е SetIP_TTL()// ---------------------------------------------------------------------------//	Set Time To Live option for subsequent transmit datavoidCSendUDPThread::SetIP_TTL(UInt32 inTTL){	mTTL = inTTL;}// ---------------------------------------------------------------------------//		е DoOption()// ---------------------------------------------------------------------------//	Do Option ManagementBooleanCSendUDPThread::DoOption(TOptMgmt* cmd){	//Don't setup multiples	if (mOptionPending) return false;	mOptionCmd = cmd;	mOptionPending = true;	// resume thread to perform Option Management if necessary	if (mIsSuspended) {		mIsSuspended = false;		this->Resume();	}	return true;}// ---------------------------------------------------------------------------//		е IsOptionReady()// ---------------------------------------------------------------------------//	Return true if previous option management request completed and/or//	ready to accept a new requestBooleanCSendUDPThread::IsOptionReady(){	return (mOptionPending == false);}// ---------------------------------------------------------------------------//		е Ioctl()// ---------------------------------------------------------------------------//	Perform Ioctl on endpointBooleanCSendUDPThread::Ioctl(UInt32 inCmd, void* inData){	//Don't setup multiples	if (mCmd) return false;		mCmd = inCmd;	mIoctlData = inData;			// resume thread to perform Ioctl if necessary	if (mIsSuspended) {		mIsSuspended = false;		this->Resume();	}	return true;}// ---------------------------------------------------------------------------//		е IsReady()// ---------------------------------------------------------------------------//	Return whether Send UDP Thread is ready, that is,//	not waiting for a previous operation to complete due to flow control etc.BooleanCSendUDPThread::IsReady(){	return (mDataSize == 0);}// ---------------------------------------------------------------------------//		е SendUData// ---------------------------------------------------------------------------BooleanCSendUDPThread::SendUData(		LInternetAddress&	inRemoteHost,		void*				inData,		UInt32				inDataSize){	//Don't setup multiples	if (mDataSize) return false;		// reject if data exceeds buffer size	if (inDataSize > kMaxSendSize) return false;	// get target address	mRemoteAddress.SetIPAddress( inRemoteHost.GetIPAddress() );	mRemoteAddress.SetHostPort( inRemoteHost.GetHostPort() );		// copy data to free caller's buffer	mDataSize = inDataSize;	::OTMemcpy( (void*)&mData, inData, inDataSize);		// resume thread to send data	if (mIsSuspended) {		mIsSuspended = false;		this->Resume();	}		return true;}// ---------------------------------------------------------------------------//		е Run// ---------------------------------------------------------------------------void*CSendUDPThread::Run(){	mResult = 0;	try {		// loop until set to terminate upon completion		while (!mTerminate) {			// if no new requests			if ((mCmd == 0) && (mBind == false) && (mTTL == 0) &&				(mOptionPending == false) && (mDataSize == 0)) {				// suspend until we have more to do.				mIsSuspended = true;				this->Suspend();				mIsSuspended = false;	// defensive				if (mAbort) break;			}			// Send Ioctl?			if (mCmd) {				mEndpoint->Ioctl(mCmd, mIoctlData);				mCmd = 0;			}			// Bind request?			if (mBind) {				mEndpoint->Bind(mLocalAddress);				mBind = false;			}			// set TTL request?			if (mTTL) {				mEndpoint->SetIP_TTL(mTTL);				mTTL = 0;			}			// Option Management request?			if (mOptionPending) {				mEndpoint->DoOption(mOptionCmd);				mOptionPending = false;				mOptionCmd = nil;			}			// any data to send?			if (mDataSize) {				// send it				mEndpoint->SendPacketData(mRemoteAddress, &mData, mDataSize);				mDataSize = 0;			}		}	}	catch (const LException& inErr) {		mResult = inErr.GetErrorCode();		// handle exception results		// just report result to Object Master	} 	SetResult(&mResult);	// set result so Object Master can retrieve it.	mObjectMaster->ObjectThreadDied(this);	return &mResult;}