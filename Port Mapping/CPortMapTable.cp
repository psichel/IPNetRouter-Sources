// =================================================================================//	CPortMapTable.cp				©1998 Sustainable Softworks All rights reserved.// =================================================================================//	Table object to display trace route information#include "CPortMapTable.h"#include "CPortMapConst.h"#include "CPortMapWindow.h"#include "Cwindow.h"#include <PP_Messages.h>#include "AGAColors.h"#include "CIPRouterApp.h"#include "IPRouterCommon.h"#include "IPSupport.h"#include "MacSupport.h"#include "CIPNumberEditField.h"#include <LString.h>#include <Icons.h>#include "ICAPI.h"#include "CPortMapData.h"// Globalsextern CIPRouterApp* gAppObject;extern ICInstance gICInstance;// ---------------------------------------------------------------------------------//		¥ CPortMapTable(LStream*)// ---------------------------------------------------------------------------------CPortMapTable::CPortMapTable(	LStream	*inStream )		: CConfigureTable( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CPortMapTable// ---------------------------------------------------------------------------------CPortMapTable::~CPortMapTable(){}// ---------------------------------------------------------------------------//		¥ Click Cell// ---------------------------------------------------------------------------//  Handle click in cell.//	Display table entry in window edit fieldsvoidCPortMapTable::ClickCell(	const TableCellT		&inCell,	const SMouseDownEvent&	inMouseDown){	PortMapEntry_t	mapEntry;	TableCellT		theCell;	TableItemW		tData;	SelectRow(inCell, false);	// ( ,extendFlag)	// check for double click	if (GetClickCount() == 2) {			// Get IP Address from clicked row of table		theCell.row = inCell.row;		theCell.col = kActualEndpoint;		GetCellData( theCell, &tData );				// Found an address, try to invoke ping		if (tData.hi != 0) {			// ping test			LaunchURL("\pping://");		}	} else {		if (GetPortMapEntry(inCell.row, &mapEntry))			((CPortMapWindow*)mWindow)->DisplayPortMapEntry(&mapEntry);	}}// ---------------------------------------------------------------------------------//		¥ GetPortMapEntry// ---------------------------------------------------------------------------------//	Get Port Map Entry from TableBooleanCPortMapTable::GetPortMapEntry(TableIndexT inRow, PortMapEntry_t* outEntry){	TableCellT	theCell;	TableItemW	tData;	Boolean		result = true;	do {		// check for valid row entry		theCell.row = inRow;		theCell.col = kColumnApparent;		GetCellData(theCell, &tData);		if (tData.hi == kItemNone) {			result = false;			break;		}		// get entry		theCell.col = kColumnProtocol;		GetCellData(theCell, &tData);		outEntry->protocol = tData.hi;				theCell.col = kColumnApparent;		GetCellData(theCell, &tData);		outEntry->apparent.address = tData.hi;		outEntry->apparent.port	= tData.lo >> 16;		outEntry->portRange	= tData.lo & 0xFFFF;				theCell.col = kColumnActual;		GetCellData(theCell, &tData);		outEntry->actual.address = tData.hi;		outEntry->actual.port	 = tData.lo >> 16;				theCell.col = kColumnAge;		GetCellData(theCell, &tData);		outEntry->age = tData.hi;		theCell.col = kColumnFlags;		GetCellData(theCell, &tData);		outEntry->flags = tData.hi & 0xFFFF;			// clear wamnet parameter			outEntry->flags &= ~kFlagWamnet;	} while (false);	return result;}// ---------------------------------------------------------------------------------//		¥ SetPortMapEntry// ---------------------------------------------------------------------------------//	Set Port Map Entry in Table//	Refresh if entry was changedvoidCPortMapTable::SetPortMapEntry(TableIndexT inRow, PortMapEntry_t* inEntry){	TableCellT	theCell;	TableItemW	tData, uData;	Boolean		result = false;	do {		// check for valid row entry		if (inRow > kMaxPortMapTableRows) {			result = false;			break;		}		// insert rows if needed		if (inRow > mRows) {			tData.hi = 0;			tData.lo = 0;			InsertRows(inRow-mRows, mRows, &tData);	// how many, after row, *data		}		theCell.row = inRow;		// set entry		theCell.col = kColumnProtocol;		tData.hi = inEntry->protocol;		GetCellData(theCell, &uData);		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}		theCell.col = kColumnApparent;		tData.hi = inEntry->apparent.address;		tData.lo = ((inEntry->apparent.port)<<16) | inEntry->portRange;		GetCellData(theCell, &uData);		if ((tData.hi != uData.hi) || (tData.lo != uData.lo)) {			SetCellData(theCell, &tData);			result = true;		}				theCell.col = kColumnActual;		tData.hi = inEntry->actual.address;		tData.lo = ((inEntry->actual.port)<<16) | inEntry->portRange;		GetCellData(theCell, &uData);		if ((tData.hi != uData.hi) || (tData.lo != uData.lo)) {			SetCellData(theCell, &tData.hi);			result = true;		}				theCell.col = kColumnAge;		tData.hi = inEntry->age;		GetCellData(theCell, &uData);		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}		theCell.col = kColumnFlags;		tData.hi = inEntry->flags;		GetCellData(theCell, &uData);		if (tData.hi != uData.hi) {			SetCellData(theCell, &tData);			result = true;		}	} while (false);	if (result) RefreshRow(inRow);}// ---------------------------------------------------------------------------//		¥ Draw Cell// ---------------------------------------------------------------------------voidCPortMapTable::DrawCell(	const TableCellT	&inCell){	Rect		cellFrame;	TableItemW	tData, uData;	TableCellT	tCell;	UInt16		portA, portRange;	Str31		str;	LStr255		text;	OSErr		err = NoError;	if (FetchLocalContentFrame(inCell, cellFrame)) {		// draw white background		::PenNormal();		ApplyForeAndBackColors();		::EraseRect(&cellFrame);		// draw border around cell		::InsetRect(&cellFrame, -1, -1);		::PenPat(&UQDGlobals::GetQDGlobals()->gray);		if (PaneInColor (this)) {			StColorState	saveColor;			RGBColor		emptyColor;			emptyColor = gAGAColorArray[6];			::RGBForeColor(&emptyColor);			::FrameRect(&cellFrame);		} else { ::FrameRect(&cellFrame); }		::PenPat(&UQDGlobals::GetQDGlobals()->black);				// draw contents		::TextFont(applFont);		::TextFace(0);	// normal		::TextSize(9);		// Get cell data		GetCellData( inCell, &tData );		// Handle each column		switch (inCell.col) {		case kColumnProtocol:			// first column, display protocol			// Get apparent to cofirm we have an entry			tCell.row = inCell.row;			tCell.col = kColumnApparent;			GetCellData( tCell, &uData );			if (uData.hi != kItemNone) {				MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);				switch (tData.hi) {					case kProtocolICMP:						DrawString("\pICMP");						break;					case kProtocolUDP:						DrawString("\pUDP");						break;					case kProtocolTCP:						DrawString("\pTCP");						break;					case kProtocolGRE:						DrawString("\pGRE");						break;					case kProtocolIPSec:						DrawString("\pIPSec");						break;					case kProtocolAny:						DrawString("\pAny");						break;					default:						::NumToString( tData.hi, str );						DrawString(str);						break;				}			}			break;		case kApparentEndpoint:			// display apparent endpoint if any			if (tData.hi != 0) {				MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);				IP_NumToStr( tData.hi, str );				text = str;				portA = tData.lo >> 16;				portRange = tData.lo & 0xFFFF;				if (portA) {					text += "\p:";					if (portRange) {						::NumToString(portA, str);						text += str;						text += "\p-";						::NumToString(portA+portRange, str);					} else {						PortToString(portA, str);					}					text += str;				}				DrawString(text);			}			break;		case kActualEndpoint:			// display actual endpoint if any			if (tData.hi != 0) {				MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);				IP_NumToStr( tData.hi, str );				text = str;				portA = tData.lo >> 16;				portRange = tData.lo & 0xFFFF;				if (portA) {					text += "\p:";					if (portRange) {						::NumToString(portA, str);						text += str;						text += "\p-";						::NumToString(portA+portRange, str);					} else {						PortToString(portA, str);					}					text += str;				}				DrawString(text);			}			break;		case kColumnAge:			// display age of NAT entry			// Get apparent to cofirm we have an entry			tCell.row = inCell.row;			tCell.col = kColumnApparent;			GetCellData( tCell, &uData );			if (uData.hi != kItemNone) {				MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);				::NumToString( tData.hi, str );				DrawString( str );			}			break;		case kColumnFlags:			// show flags			// Get apparent to cofirm we have an entry			tCell.row = inCell.row;			tCell.col = kColumnApparent;			GetCellData( tCell, &uData );			if (uData.hi != kItemNone) {				MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);				text = "\p";				if (tData.hi & kFlagPermanent) text += "\pP ";				if (tData.hi & kFlagFINLocal) text += "\pFL ";				if (tData.hi & kFlagFINPeer) text += "\pFR ";				if (tData.hi & kFlagStatic) text += "\pS ";				//if (tData.hi & kFlagActive) text += "\pA ";				DrawString( text );			}			break;		default:								// ### Debugging								// Draw cell row & column number inside								// frame of cell			::MoveTo(cellFrame.left + 8, cellFrame.bottom - 4);				Str31	str;			NumToString(inCell.row, str);			DrawString(str);			DrawString("\p,");			NumToString(inCell.col, str);			DrawString(str);		}	}}