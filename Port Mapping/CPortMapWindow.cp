// =================================================================================//	CPortMapWindow.cp			©1998 Sustainable Softworks All rights reserved.// =================================================================================//	Configure Interface Window#include "CompileFlags.h"#include "CPortMapWindow.h"#include "CPortMapConst.h"#include "CConfigDocument.h"#include "CIPNumberEditField.h"#include "IPRouterCommon.h"#include "CSubnetCalcWindow.h"#include "UIPNumKeyFilters.h"#include "CPortMapTable.h"#include "CMultiCaption.h"#include "MacSupport.h"#include "IPSupport.h"#include "CLogAction.h"#include "CHelpWindow.h"#include <UReanimator.h>#include <LString.h>#include <LPreferencesFile.h>#include <UResourceMgr.h>#include <LArrayIterator.h>#include <OpenTransport.h>#include "CResidentIfInfo.h"#include "CPortMapData.h"#include "CPortMapAction.h"// Globalsextern CLogAction*		gLogAction;extern CPortMapData*	gPortMapData;extern CPortMapAction*	gPortMapAction;extern CInterfacesData* gInterfacesData;// ---------------------------------------------------------------------------------//		¥ CPortMapWindow(LStream*)// ---------------------------------------------------------------------------------CPortMapWindow::CPortMapWindow(	LStream	*inStream )		: CWindow( inStream ){	// initialization	mFlagStaticCheckBox = nil;	mFlagPermCheckBox = nil;	mPermanentOnlyCheckBox = nil;	mLastTime = 0;	mProtocolOther = 0;	mIsMonitoring = false;}// ---------------------------------------------------------------------------------//		¥ ~CPortMapWindow// ---------------------------------------------------------------------------------CPortMapWindow::~CPortMapWindow(){	// disconnect from PortMap data	gPortMapData->RemoveListener(this);	gPortMapAction->StopMonitoring();}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------//	Finish creating the Port Map window.voidCPortMapWindow::FinishCreateSelf(){	// setup up Port Map display table	// get the table view	mPortMapTable = (CPortMapTable*) this->FindPaneByID( kPortMapTablePane );	ThrowIfNil_( mPortMapTable );	mPortMapTable->SetWindow(this);	// tell table it's parent window	// set column widths (inWidth, inFromCol, inToCol)	mPortMapTable->SetColWidth(kWidthProtocol, 1, 1);	mPortMapTable->SetColWidth(kWidthEndpoint, 2, 3);	mPortMapTable->SetColWidth(kWidthAge, 4, 5);	// setup up table captions	CMultiCaption	*theCaption;	theCaption = (CMultiCaption*) this->FindPaneByID( kPortMapTableCaptionPane );	ThrowIfNil_( theCaption );	// customize the caption widths to match table outline	theCaption->SetColWidth(kWidthProtocol,	1, 1);	theCaption->SetColWidth(kWidthEndpoint, 2, 3);	theCaption->SetColWidth(kWidthAge, 4, 5);	// setup pointer to apparent address field	mApparentIPField = (LEditField*)FindPaneByID( kApparentEndpoint );		ThrowIfNil_(mApparentIPField);	// setup pointer to port fields	mApparentPortField = (LEditField*)FindPaneByID( kApparentPort );		ThrowIfNil_(mApparentPortField);	mActualPortField = (LEditField*)FindPaneByID( kActualPort );		ThrowIfNil_(mActualPortField);	// setup pointer to status caption	mStatusCaption = (LCaption*)FindPaneByID( kStatusCaption );	ThrowIfNil_(mStatusCaption);	// setup pointer to connect button	mUpdateButton = (LControl*) FindPaneByID(kUpdateButton);	ThrowIfNil_(mUpdateButton);	// setup pointer to check boxes	mFlagStaticCheckBox = (LStdCheckBox*) FindPaneByID(kFlagStaticCheckBox);	ThrowIfNil_(mFlagStaticCheckBox);	mFlagPermCheckBox = (LStdCheckBox*) FindPaneByID(kFlagPermCheckBox);	ThrowIfNil_(mFlagPermCheckBox);	mPermanentOnlyCheckBox = (LStdCheckBox*) FindPaneByID(kPermanentOnlyCheckBox);	ThrowIfNil_(mPermanentOnlyCheckBox);	// initialize Show Static Only check box from current setting	mPermanentOnlyCheckBox->SetValue(gPortMapData->GetDataPermanentOnly());	// setup pointer to protocol popup	mProtocolPopup = (LStdPopupMenu*)this->FindPaneByID( kProtocolPopup );	ThrowIfNil_(mProtocolPopup);	// setup protocol port names popup	mProtocolPortNamesPopup = (LStdPopupMenu*)this->FindPaneByID( kProtocolPortNamesPopup );	ThrowIfNil_(mProtocolPortNamesPopup);	// setup port name caption	mPortNameCaption = (LCaption*)this->FindPaneByID( kPortNameCaption );	ThrowIfNil_(mPortNameCaption);	// Link the window (the listener) with the controls in	// the window (the broadcasters).	UReanimator::LinkListenerToControls(		(CPortMapWindow *)this, this, rRidL_PortMapWindow );	// connect to PortMap data	gPortMapData->AddListener(this);	// update the Port Map table		// portMap data is updated each time we enable masquerading	//gPortMapAction->UpdatePortMapData();	UpdateTable();	// update PortMap entry in Window	PortMapEntry_t portMapEntry;	gPortMapData->GetDataPortMapEntry(&portMapEntry);	DisplayPortMapEntry(&portMapEntry);		// initialize apparent IP field	UInt32 tNATaddress;	tNATaddress = gPortMapData->GetDataNATaddress();	if (tNATaddress) {		mApparentIPField->SetValue(tNATaddress);	} else {		mApparentIPField->SetDescriptor("\p");	}	// initialize current NAT table	InterfaceEntry_t	entry;	if (gPortMapData->FindCurrentNATinterface(&entry)) {		mPortNameCaption->SetDescriptor(entry.userPortName);	} else {		mPortNameCaption->SetDescriptor("\p");	}	{	// begin scope for resource object		// get window state resource		UInt8 state;		StNewResource windowState( (ResType)'WSta',			(ResIDT)rPPob_PortMapWindow, kPortMapStateSize, true );	// inDefaultSize, inGet1Resource		if (windowState.ResourceExisted()) {			// restore show permanent only state			state = ((UInt8*)(*windowState.mResourceH))[1];			mPermanentOnlyCheckBox->SetValue(state);			// restore monitoring state			state = ((UInt8*)(*windowState.mResourceH))[2];			if (state) {				mIsMonitoring = true;				gPortMapAction->StartMonitoring();				mUpdateButton->SetDescriptor(kPauseName);						}			else {				mIsMonitoring = false;				gPortMapAction->StopMonitoring();				mUpdateButton->SetDescriptor(kMonitorName);						}		}	}	// end scope for resource object}// ---------------------------------------------------------------------------//		¥ AttemptClose// ---------------------------------------------------------------------------//	Try to close a Window as a result of direct user actionvoidCPortMapWindow::AttemptClose(){	// get window state resource	StNewResource windowState( (ResType)'WSta',		(ResIDT)rPPob_PortMapWindow, kPortMapStateSize, true );	// inDefaultSize, inGet1Resource	// remember mPermanentOnlyCheckBox state	((UInt8*)(*windowState.mResourceH))[1] = mPermanentOnlyCheckBox->GetValue();	// remember monitoring state	((UInt8*)(*windowState.mResourceH))[2] = mIsMonitoring;		// inherit any other behavior	CWindow::AttemptClose();	}// ---------------------------------------------------------------------------//		¥ HandleKeyPress// ---------------------------------------------------------------------------//	Handle <Return>, <Enter> passed up from an EditField////	Return true if the Window handles the keystrokeBooleanCPortMapWindow::HandleKeyPress(	const EventRecord&	inKeyEvent){	Boolean		keyHandled = true;	LControl	*keyButton = nil;	SInt16		theKey = inKeyEvent.message & charCodeMask;	switch (theKey) {			//case char_Enter:		//case char_Return:		//	keyButton =  (LControl*) FindPaneByID(kAddButton);		//	break;		case char_UpArrow:			if (inKeyEvent.modifiers & cmdKey) {//				menuChoice = mPortNamePopup->GetValue();//				if (menuChoice > 1) {//					menuChoice -= 1;//					mPortNamePopup->SetValue(menuChoice);//				}			}			break;		case char_DownArrow:			if (inKeyEvent.modifiers & cmdKey) {//				menuChoice = mPortNamePopup->GetValue();//				if (menuChoice < mPortNamePopupMax) {//					menuChoice += 1;//					mPortNamePopup->SetValue(menuChoice);//				}			}			break;		default:			if (UKeyFilters::IsCmdPeriod(inKeyEvent)) {				// reset PPP controller				//keyButton =  (LControl*) FindPaneByID(kTestButtonPane);			} else {				keyHandled = CWindow::HandleKeyPress(inKeyEvent);			}			break;	}				if (keyButton != nil) {		keyButton->SimulateHotSpotClick(kControlButtonPart);		keyHandled = true;	}		return keyHandled;}// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------voidCPortMapWindow::ListenToMessage(	MessageT	inEventCode,	void		*ioParam ){	LNetMessage* inMessage = (LNetMessage*)ioParam;	OSStatus 			err = noErr;	PortMapEntry_t		portMapEntry;	try {		switch ( inEventCode ) {						case msg_SignalDataEvent:				// handle change to portMap Data				UInt32 dataID = *(UInt32*)ioParam;				if (dataID == DATA_ID(kPortMapData, kDataPortMapEntry)) {					// PortMap parameter data has changed										gPortMapData->GetDataPortMapEntry(&portMapEntry);					DisplayPortMapEntry(&portMapEntry);				}				else if (dataID == DATA_ID(kPortMapData, kDataPortMapPermanentOnly)) {					// static only setting has changed										Boolean permanentOnly;					permanentOnly = gPortMapData->GetDataPermanentOnly();					if (permanentOnly) {						gPortMapAction->StopMonitoring();						mUpdateButton->SetDescriptor(kRefreshName);						gPortMapAction->UpdatePortMapData();					}					else {						mIsMonitoring = false;						gPortMapAction->StopMonitoring();						mUpdateButton->SetDescriptor(kMonitorName);						gPortMapAction->UpdatePortMapData();					}				}				else if (dataID == DATA_ID(kPortMapData, kDataNATaddress)) {					// current NAT address has changed					UInt32 tNATaddress;					tNATaddress = gPortMapData->GetDataNATaddress();					if (tNATaddress) {						mApparentIPField->SetValue(tNATaddress);					} else {						mApparentIPField->SetDescriptor("\p");					}				}				else if (dataID == DATA_ID(kPortMapData, kDataPortMapHash)) {					// current NAT table has changed					InterfaceEntry_t	entry;					if (gPortMapData->FindCurrentNATinterface(&entry)) {						mPortNameCaption->SetDescriptor(entry.userPortName);					} else {						mPortNameCaption->SetDescriptor("\p");					}				}				else if (dataID>>16 == kPortMapData) {					// a row in the portMap array has changed					TableIndexT	row;					row = dataID & 0xFFFF;					if (row > kDataPortMapArrayOffset) {						row -= kDataPortMapArrayOffset;						// try to get data for this row						if (gPortMapData->GetDataPortMapArray(row, &portMapEntry)) {							// got it, update table							mPortMapTable->SetPortMapEntry(row, &portMapEntry);						}						else {							// no data, row must have been deleted							mPortMapTable->ClearRow(row);						}					}				}				break;						case msg_AddButton:			case msg_RemoveButton:				DoCommand(inEventCode);				gPortMapData->SignalDataChange();				break;						case msg_UpdateButton:				if (mPermanentOnlyCheckBox->GetValue()) {					UpdateTable();				} else {					if (mIsMonitoring) {						mIsMonitoring = false;						gPortMapAction->StopMonitoring();						mUpdateButton->SetDescriptor(kMonitorName);					} else {						mIsMonitoring = true;						gPortMapAction->StartMonitoring();						mUpdateButton->SetDescriptor(kPauseName);					}				}				break;						case kFlagPermCheckBox:			case kFlagStaticCheckBox:				break;						case kProtocolPopup:				break;			case kProtocolPortNamesPopup:				{					MenuHandle	theMenuH;					Handle		h;					SInt32		value;					short		theID;					ResType		theType;					Str31		name;					// get protocol name					theMenuH = mProtocolPortNamesPopup->GetMacMenuH();					value = mProtocolPortNamesPopup->GetValue();					::GetMenuItemText( theMenuH, value, name );					// find corresponding resource to determine port#					h=::GetNamedResource ('STRP', name);					if (h != nil) {						::GetResInfo(h, &theID, &theType, name);						value = theID - kPortStart;						mApparentPortField->SetValue(value);						mActualPortField->SetValue(value);					}				}				break;						case kPermanentOnlyCheckBox:				gPortMapData->SetDataPermanentOnly(mPermanentOnlyCheckBox->GetValue() == 1);				break;									case msg_HelpButton:											// Create the Help Window				CHelpWindow		*theWindow;				theWindow = (CHelpWindow*)InvokeWindow(kNameHelp, this);				theWindow->Show();				theWindow->LoadTextInWindow(rTEXT_PortMapHelp);				break;		}	}	catch (const LException& inErr) {		Str31 errStr;		::NumToString( inErr.GetErrorCode(), errStr);		::ParamText(errStr, nil, nil, nil);		UDesktop::Deactivate();		// Alert will swallow Deactivate event		::Alert(ALRT_OTError, nil);		UDesktop::Activate();	} 	catch (...) {		gLogAction->LogText("\p\rCPortMapWindow::ListenToMessage unexpected Exception");		::SysBeep(1);	}}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	Respond to commandsBooleanCPortMapWindow::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;//	GrafPtr		theWindowP;	LWindow*	theWindow;//	LEditField*	theEditField;//	Str255		str;	switch (inCommand) {		case cmd_SubnetCalculator:			// Create the Subnet Calculator Window			theWindow = InvokeWindow(kNameSubnetCalculator, mSuperCommander);			theWindow->Show();//			theEditField = (LEditField*) this->FindPaneByID( kIPAddressField );//			ThrowIfNil_(theEditField);//			theEditField->GetDescriptor(str);//			((CSubnetCalcWindow*)theWindow)->InvokeSubnetCalcWindow(str);			break;					default:			cmdHandled = CWindow::ObeyCommand(inCommand, ioParam);			break;	}	return cmdHandled;}#pragma mark --- Display Table ---// ---------------------------------------------------------------------------------//		¥ UpdateTable// ---------------------------------------------------------------------------------//	Update Port Map Table from data objectvoidCPortMapWindow::UpdateTable(){	ArrayIndexT		num;	ArrayIndexT		index;	PortMapEntry_t	portMapEntry;		num = gPortMapData->GetDataCount();	for (index=1; index<=num; index++) {		if (gPortMapData->GetDataPortMapArray(index, &portMapEntry)) {			mPortMapTable->SetPortMapEntry(index, &portMapEntry);		} else {			mPortMapTable->ClearRow(index);		}	}}// ---------------------------------------------------------------------------------//		¥ DisplayPortMapEntry// ---------------------------------------------------------------------------------//	Display Port Map Entry in window edit fieldsvoidCPortMapWindow::DisplayPortMapEntry(PortMapEntry_t*	inMapEntry){	LEditField* theEditField;	Str63				str;	LStr255				text;	do {		// set protocol		if (inMapEntry->protocol == kProtocolTCP) {			mProtocolPopup->SetValue(kProtocolMenuTCP);		}		else if (inMapEntry->protocol == kProtocolUDP) {			mProtocolPopup->SetValue(kProtocolMenuUDP);		}		else if (inMapEntry->protocol == kProtocolICMP) {			mProtocolPopup->SetValue(kProtocolMenuICMP);		}		else if (inMapEntry->protocol == kProtocolGRE) {			mProtocolPopup->SetValue(kProtocolMenuGRE);		}		else if (inMapEntry->protocol == kProtocolIPSec) {			mProtocolPopup->SetValue(kProtocolMenuIPSec);		}		else if (inMapEntry->protocol == kProtocolAny) {			mProtocolPopup->SetValue(kProtocolMenuAny);		}		else if (inMapEntry->protocol > 0) {			mProtocolPopup->SetValue(kProtocolMenuOther);			mProtocolOther = inMapEntry->protocol;		}		// transfer apparent and actual endpoints			// apparent address		theEditField = (LEditField*)FindPaneByID( kApparentEndpoint );			ThrowIfNil_(theEditField);		theEditField->SetValue(inMapEntry->apparent.address);			// apparent port		::NumToString( inMapEntry->apparent.port, str );		text = str;		if (inMapEntry->apparent.port == 0) text = "\p*";		else {			if (inMapEntry->portRange != 0) {				::NumToString( inMapEntry->apparent.port+inMapEntry->portRange, str );				text += "\p-";				text += str;			}		}		theEditField = (LEditField*)FindPaneByID( kApparentPort );			ThrowIfNil_(theEditField);		theEditField->SetDescriptor(text);			// actual address		theEditField = (LEditField*)FindPaneByID( kActualEndpoint );			ThrowIfNil_(theEditField);		theEditField->SetValue(inMapEntry->actual.address);				// actual port		::NumToString( inMapEntry->actual.port, str );		text = str;		if (inMapEntry->actual.port == 0) text = "\p*";		else {			if (inMapEntry->portRange != 0) {				::NumToString( inMapEntry->actual.port+inMapEntry->portRange, str );				text += "\p-";				text += str;			}		}		theEditField = (LEditField*)FindPaneByID( kActualPort );			ThrowIfNil_(theEditField);		theEditField->SetDescriptor(text);				// age		theEditField = (LEditField*)FindPaneByID( kAgeEditField );			ThrowIfNil_(theEditField);		theEditField->SetValue(inMapEntry->age);			// set permanent check box		if (inMapEntry->flags & kFlagPermanent) {			mFlagPermCheckBox->SetValue(1);		} else {			mFlagPermCheckBox->SetValue(0);		}		// set static check box		if (inMapEntry->flags & kFlagStatic) {			mFlagStaticCheckBox->SetValue(1);		} else {			mFlagStaticCheckBox->SetValue(0);		}		} while (false);}// ---------------------------------------------------------------------------------//		¥ DoCommand// ---------------------------------------------------------------------------------OTResultCPortMapWindow::DoCommand(MessageT inEventCode){	OTResult		result = kOTNoError;	PortMapEntry_t	mapEntry;	LEditField* 	theEditField;	UInt16			len, portA, portB;	Str31			str;		// set map entry from edit fields	bzero((UInt8*)&mapEntry, sizeof(PortMapEntry_t));	// protocol	switch(mProtocolPopup->GetValue()) {		case kProtocolMenuTCP:			mapEntry.protocol = kProtocolTCP;			break;		case kProtocolMenuUDP:			mapEntry.protocol = kProtocolUDP;			break;		case kProtocolMenuICMP:			mapEntry.protocol = kProtocolICMP;			break;		case kProtocolMenuGRE:			mapEntry.protocol = kProtocolGRE;			break;		case kProtocolMenuIPSec:			mapEntry.protocol = kProtocolIPSec;			break;		case kProtocolMenuAny:			mapEntry.protocol = kProtocolAny;			break;		case kProtocolMenuOther:			mapEntry.protocol = mProtocolOther;			break;	}		// apparent and actual endpoints	mapEntry.apparent.address = mApparentIPField->GetValue();	mApparentPortField->GetDescriptor(str);	len = str[0];	str[len+1] = 0;	// null terminate	if (DecodePortRange((char*)&str[1], &portA, &portB)) {		mapEntry.apparent.port = portA;		if (portB > portA) mapEntry.portRange = portB - portA;	}	theEditField = (LEditField*)FindPaneByID( kActualEndpoint );		ThrowIfNil_(theEditField);	mapEntry.actual.address = theEditField->GetValue();	mActualPortField->GetDescriptor(str);	len = str[0];	str[len+1] = 0;	// null terminate	if (DecodePortRange((char*)&str[1], &portA, &portB)) {		mapEntry.actual.port = portA;	}	// age	theEditField = (LEditField*)FindPaneByID( kAgeEditField );		ThrowIfNil_(theEditField);	mapEntry.age = theEditField->GetValue();		// flags	mapEntry.flags = 0;	if (inEventCode == msg_AddButton) mapEntry.flags = kFlagActive;	if (mFlagPermCheckBox->GetValue()) mapEntry.flags |= kFlagPermanent;	if (mFlagStaticCheckBox->GetValue()) mapEntry.flags |= kFlagStatic;		// issue command	result = gPortMapAction->DoPortMapEntry(&mapEntry, true);	// show user what happened	IoctlResponse(result);		return result;}// ---------------------------------------------------------------------------------//		¥ IoctlResponse// ---------------------------------------------------------------------------------//	IoctlResponse - an ioctl completed process the resultvoidCPortMapWindow::IoctlResponse(long inResult){	switch (inResult) {		case 0:				// no error			mStatusCaption->SetDescriptor("\pOK");			break;		case kProxyAddError:			mStatusCaption->SetDescriptor("\pNo NAT table currently selected.");			break;				case kProxyDelError:			mStatusCaption->SetDescriptor("\pMatching entry not found.");			break;				case kOTNotFoundErr:			mStatusCaption->SetDescriptor("\pkOTNotFoundErr.");			break;				case kEINVALErr:			mStatusCaption->SetDescriptor("\pkEINVALErr - Invalid parameter.");			break;		case kOTDuplicateFoundErr:					mStatusCaption->SetDescriptor("\pkOTDuplicateFoundErr.");			break;		case kEBUSYErr:			mStatusCaption->SetDescriptor("\pkEBUSYErr - Device or resource busy.");			break;		case kENXIOErr:			mStatusCaption->SetDescriptor("\pNo such device or address.");			break;		default:			{				LStr255	status;				status = "\pioctl unexpected result code: ";				Str32 str;				NumToString(inResult, str);				status += str;				mStatusCaption->SetDescriptor( status );			}			break;	}	// end switch}