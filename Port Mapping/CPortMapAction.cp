// =================================================================================//	CPortMapAction.cp			©1998 Sustainable Softworks All rights reserved.// =================================================================================//	Configure Interface Window#include "CompileFlags.h"#include "CPortMapAction.h"//#include "CPortMapConst.h"#include "CConfigDocument.h"#include "IPRouterCommon.h"#include "MacSupport.h"#include "IPSupport.h"#include "CLogAction.h"#include <UReanimator.h>#include <LString.h>#include <LPreferencesFile.h>#include <UResourceMgr.h>#include <LArrayIterator.h>#include <OpenTransport.h>#include <OpenTptConfig.h>#include <OpenTptInternet.h>#include <OpenTptLinks.h>#include "CReceiveUDPThread.h"#include "CSendUDPThread.h"#include "CTurboUDPEndpoint.h"#include "ProxyModule.h"#include "CResidentIfInfo.h"#include "CProxyControl.h"#include "CPortMapData.h"#include "CInterfacesData.h"// Globalsextern CLogAction*		gLogAction;extern CResidentIfInfo*	gResInfo;extern CProxyControl*	gProxyControl;extern CPortMapData*	gPortMapData;extern CInterfacesData* gInterfacesData;// ---------------------------------------------------------------------------------//		¥ CPortMapAction(LStream*)// ---------------------------------------------------------------------------------CPortMapAction::CPortMapAction(){	// initialization	mEndpoint = nil;	mReceiveUDPThread = nil;	mLastTime = 0;	mUpdateRow = 0;	mNeedInit = true;}// ---------------------------------------------------------------------------------//		¥ ~CPortMapAction// ---------------------------------------------------------------------------------CPortMapAction::~CPortMapAction(){	Terminate();	}// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------voidCPortMapAction::ListenToMessage(	MessageT	inEventCode,	void		*ioParam ){	LNetMessage* inMessage = (LNetMessage*)ioParam;	OSStatus 			err = noErr;	try {		switch ( inEventCode ) {//			case msg_SignalDataEvent://				// handle change to portMap Data//				UInt32 dataID = *(UInt32*)ioParam;//				if (dataID == DATA_ID(kPortMapData, kDataPortMapHash)) {//					// current NAT table has changed//					//UpdatePortMapData();//				}//				break;										// Endpoint notifications			case kOTProviderWillClose:				gLogAction->LogText("\p\r### Network connection terminated.");				gLogAction->LogText("\p\r kOTProviderWillClose - Provider will close immediately.");				break;			case kOTProviderIsClosed:			case msg_BroadcasterDied:				break;			case kStreamIoctlEvent:				gLogAction->LogText("\p\rCPortMapAction - IOCTL event code: ", inMessage->GetResultCode());				break;			default:				gLogAction->LogText("\p\rCPortMapAction unknown async message type: ");				Str32 str;				IP_NumToHexStr(inEventCode, str);				gLogAction->LogText(str);				//gLogAction->LogText("\p\r  Result code: ");				//NumToString(inMessage->GetResultCode(), str);				//gLogAction->LogText(str);				break;		}	}	catch (const LException& inErr) {		gLogAction->LogText("\p\rCPortMapAction::ListenToMessage unexpected result from OT: ", inErr.GetErrorCode());		::SysBeep(1);		gLogAction->LogText("\p\r Is TCP/IP configured and OTModl$Proxy in your Extensions Folder?");	} 	catch (...) {		gLogAction->LogText("\p\rCPortMapAction::ListenToMessage unexpected Exception");		::SysBeep(1);	}}// ---------------------------------------------------------------------------//		¥ StartMonitoring// ---------------------------------------------------------------------------//	Start updating NAT table periodicallyvoidCPortMapAction::StartMonitoring(){	StartIdling();}// ---------------------------------------------------------------------------//		¥ StopMonitoring// ---------------------------------------------------------------------------//	Stop updating NAT table periodicallyvoidCPortMapAction::StopMonitoring(){	StopIdling();}// ---------------------------------------------------------------------------//		¥ SpendTime// ---------------------------------------------------------------------------//	Periodical function to test if stat message times outvoidCPortMapAction::SpendTime(const EventRecord &inMacEvent){#pragma unused (inMacEvent)	UInt32 timeStamp = TickCount();	// refresh table every second or so	if ((timeStamp - mLastTime) > 80) {		mLastTime = timeStamp;		UpdatePortMapData();	}}// ---------------------------------------------------------------------------//		¥ ReceiveData// ---------------------------------------------------------------------------//	Some data came in from the network.voidCPortMapAction::ReceiveData(LDataArrived* inMessage){	void* 			inData;			// data that arrived	//UInt32		inDataSize;		// size of the data	//LInternetAddress* inRemoteAddress;	UInt8 i;		// setup access to message data and remote address	inData = inMessage->GetDataBuffer();	//inDataSize = inMessage->GetDataSize();	//inRemoteAddress = inMessage->GetRemoteAddress();	// update PortMap data	dl_port_map_t* dp = (dl_port_map_t*)inData;			if (dp->dl_primitive == DL_PORT_MAP) {		mGotResponse = true;		if ((0 < dp->dl_number) && (dp->dl_number <= kPortMapEntryDim)) {			for (i=0; i<dp->dl_number; i++) {				PortMapEntry_t*	mapEntry;				mapEntry = &dp->array[i];				// skip non static entries as specified				if (!(mapEntry->flags & kFlagPermanent) &&					 ( gPortMapData->GetDataPermanentOnly() )) continue;				// update Port Map data as needed				mUpdateRow += 1;								gPortMapData->SetDataPortMapArray(mUpdateRow, mapEntry);			}		}		// end of table?		if (dp->dl_status == 0) {			// yes, set filter data count			gPortMapData->SetDataCount(mUpdateRow);			// reset update row in case another update is in the queue			mUpdateRow = 0;		}			}}// ---------------------------------------------------------------------------------//		¥ LastComplete// ---------------------------------------------------------------------------------//	Release the endpoints we created after all threads that depend on them//	have safely terminated.voidCPortMapAction::LastComplete(){	if (mReceiveUDPThread == nil) {		// Release the endpoints we created		if (mEndpoint) {			// no longer want notification of endpoint events			mEndpoint->RemoveListener(this);			delete mEndpoint;			mEndpoint = nil;		}	}}// ---------------------------------------------------------------------------//		¥ ObjectThreadDied// ---------------------------------------------------------------------------//	A threaded operation has completed.voidCPortMapAction::ObjectThreadDied(LThread *inThread) {			// Receive Thread completed?	if (inThread == mReceiveUDPThread) {		// get result		long result = *((long*)inThread->GetResult());		// indicate thread no longer exists		mReceiveUDPThread = nil;		// handle results		switch (result) {			case 0:				// no error			case Abort_Error:	// operation aborted				break;			default:				// write to log window if any				gLogAction->LogText("\p\r### CPortMapAction CReceiveUDPThread unexpected event code: ", result);				break;		}	// end switch		if (result != 0) {			// Thread died due to Endpoint event,			//  just stop any Monitoring in progress			//PauseMonitor();		}			// Release the endpoints we created		LastComplete();	}	}#pragma mark --- Proxy Module Accessors ---// ---------------------------------------------------------------------------------//		¥ Init I/O with our Proxy module// ---------------------------------------------------------------------------------voidCPortMapAction::Init(){	mNeedInit = false;	UOpenTptSupport::StartOpenTransport();						// Put this here because we must call						// InitOpenTransport() before attempting autopush.	// Register module as a streams Driver so we can open a control stream to it	gProxyControl->SetupPort();	// Create a connectionless endpoint to our Proxy driver		// used to send IOCTLs and read PortMap table data	if (!mEndpoint) {		mEndpoint = new CTurboUDPEndpoint("Proxy");		ThrowIfNil_(mEndpoint);		// Register to receive other event notifications (including Ioctl responses)		mEndpoint->AddListener(this);	}}// ---------------------------------------------------------------------------------//		¥ Terminate I/O with our Proxy module// ---------------------------------------------------------------------------------voidCPortMapAction::Terminate(Boolean inCanWait){	mNeedInit = true;	    // stop any monitoring in progress    StopIdling();    	// Release thread objects we created	if (mReceiveUDPThread) mReceiveUDPThread->Abort();	if (inCanWait) {		// Wait for threads to abort normally		UInt8 retryLimit = 16;		while (	(mReceiveUDPThread != nil) ) {			LThread::Yield();			retryLimit -= 1;			if (retryLimit == 0) break;		}	}	// if threads didn't complete, cleanup as best we can	if (mReceiveUDPThread) {		mReceiveUDPThread->DeleteThread();		mReceiveUDPThread = nil;	}	// Release the Endpoints we created	if (mEndpoint) {		mEndpoint->RemoveListener(this);		delete mEndpoint;		mEndpoint = nil;	}}// ---------------------------------------------------------------------------------//		¥ LoadPortMapConfig// ---------------------------------------------------------------------------------//	Add or Delete port map entries from imported dataSInt32CPortMapAction::LoadPortMapConfig(CPortMapData* inPortMapData){	OTResult	result = kOTNoError;	SInt32		numConfigE;	TableIndexT	row;		if (mNeedInit) Init();		do {				PortMapEntry_t	portMapEntry;		// setup access to mConfigData		if (inPortMapData == nil)  break;	// nothing to configure		numConfigE = inPortMapData->GetDataCount();		if (numConfigE == 0) break;			// nothing to configure				// try to apply each saved config		for (row=numConfigE; row>=1; row--) {			if (inPortMapData->GetDataPortMapArray(row,&portMapEntry)) {							// skip dynamic entries				if (!(portMapEntry.flags & kFlagPermanent)) continue;				// skip no restore entries				if (portMapEntry.flags & kFlagNoRestore) continue;				// override apparent address if NAT is already configured and not static				if ( !(portMapEntry.flags & kFlagStatic) ) {					portMapEntry.apparent.address = gPortMapData->GetDataNATaddress();				}				result = DoPortMapEntry(&portMapEntry, false);				if (result != kOTNoError) {					// Command failed, update port map entry so it will appear in window					inPortMapData->SetDataPortMapEntry(&portMapEntry);					gLogAction->LogText("\p\rLoadPortMapConfig OT result: ", result);					//break;				}			}		}		UpdatePortMapData();	} while (false);		return result;}// ---------------------------------------------------------------------------------//		¥ UpdatePortMapData// ---------------------------------------------------------------------------------//	Update Port Map data ojbect from Proxy moduleOTResultCPortMapAction::UpdatePortMapData(){	struct strioctl	streamCommand;	UInt32			portNameHash;	OTResult result = kOTNoError;	if (mNeedInit) Init();	// Create a connectionless endpoint to our Proxy driver		// used to send IOCTLs and read PortMap table data	if (!mEndpoint) {		mEndpoint = new CTurboUDPEndpoint("Proxy");		ThrowIfNil_(mEndpoint);		// Register to receive other event notifications (including Ioctl responses)		mEndpoint->AddListener(this);	}	// Create thread object to receive NAT data	if (!mReceiveUDPThread) {		mReceiveUDPThread = new CReceiveUDPThread(			(CObjectMaster*)	this,			(CTurboUDPEndpoint*) mEndpoint);		ThrowIfNil_(mReceiveUDPThread);		// launch thread to begin I/O		mReceiveUDPThread->Resume();		// prepare for first update		mUpdateRow = 0;	}	// mUpdateRow is set to zero when previous update completes	//mUpdateRow = 0;	// Send IOCTL to request NAT data	portNameHash = gPortMapData->GetDataPortMapHash();	if ( gPortMapData->GetDataPermanentOnly() ) {		SetupIoctl(&streamCommand, I_GetStaticMap,			(char*)&portNameHash, sizeof(proxy_name_t));	} else {		SetupIoctl(&streamCommand, I_GetFullMap,			(char*)&portNameHash, sizeof(proxy_name_t));	}	mGotResponse = false;	result = DoIoctl(I_STR, &streamCommand);	// yield so receive thread can read the response	for (UInt8 i=1; i<=8; i++) {		LThread::Yield();		if (mGotResponse) break;	}		if (result != kOTNoError) {		gLogAction->LogText("\p\rPort Mapping table not updated.");	}		return result;}// ---------------------------------------------------------------------------------//		¥ DoPortMapEntry// ---------------------------------------------------------------------------------//	Add or Delete PortMap entry per configOTResultCPortMapAction::DoPortMapEntry(PortMapEntry_t* inEntry, Boolean inUpdate){	OTResult			result;	struct strioctl		streamCommand;	proxy_map_entry_t	proxyMap;	if (mNeedInit) Init();	// tell user what we're about to do	LStr255	text;	Str255 str;	//text = "\p\rCPortMapAction::DoPortMapEntry\r ";	text = "\p\r";	gPortMapData->PortMapEntryToString(inEntry, str);	text += str;	gLogAction->LogText(text);	// setup ioctl	proxyMap.portNameHash = gPortMapData->GetDataPortMapHash();	proxyMap.mapEntry = *inEntry;	if (inEntry->flags & kFlagActive) {			SetupIoctl(&streamCommand, I_AddMapEntry, (char*)&proxyMap, sizeof(proxy_map_entry_t));				}	else {				SetupIoctl(&streamCommand, I_DelMapEntry, (char*)&proxyMap, sizeof(proxy_map_entry_t));	}	// send ioctl	result = gProxyControl->ProxyIoctl(I_STR, &streamCommand);	if (inUpdate) UpdatePortMapData();	return result;}// ---------------------------------------------------------------------------------//		¥ DoIoctl// ---------------------------------------------------------------------------------//	Send synchronous ioctl to proxy moduleOTResultCPortMapAction::DoIoctl(UInt32 inCmd, void* inData){	OTResult	result;	EndpointRef	ep;		if (mEndpoint) {		// get OT endpoint ref		ep = mEndpoint->GetEndpointRef();				// set synchronous		::OTSetSynchronous(ep);		// issue requested ioctl		result = ::OTIoctl(ep, inCmd, inData);				// restore to asynchronous		::OTSetAsynchronous(ep);	}	else result = kOTBadReferenceErr;		return result;}