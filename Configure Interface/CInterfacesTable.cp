// =================================================================================//	CInterfacesTable.cp				©1996 Sustainable Softworks All rights reserved.// =================================================================================//	Table object to display trace route information#include "CInterfacesTable.h"#include "CInterfacesWindow.h"#include "CInterfacesConst.h"//#include "CInterfacesData.h"#include "CWindow.h"#include <PP_Messages.h>#include "AGAColors.h"#include "CIPRouterApp.h"#include "IPRouterCommon.h"#include "IPSupport.h"#include "MacSupport.h"#include "CIPNumberEditField.h"#include <LToggleButton.h>#include <LString.h>#include <Icons.h>#include "ICAPI.h"// Globalsextern CIPRouterApp* gAppObject;extern ICInstance gICInstance;// ---------------------------------------------------------------------------------//		¥ CInterfacesTable(LStream*)// ---------------------------------------------------------------------------------CInterfacesTable::CInterfacesTable(	LStream	*inStream )		: CConfigureTable( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CInterfacesTable// ---------------------------------------------------------------------------------CInterfacesTable::~CInterfacesTable(){}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------//	Finish creating the Interfaces table.voidCInterfacesTable::FinishCreateSelf(){	// set column widths (inWidth, inFromCol, inToCol)	SetColWidth(45, 1, 1);	SetColWidth(120, 2, 3);	SetColWidth(90, 4, 5);	// setup and init comment data	SetCommentDataSize(kCommentDataSize, 2);	// set column types	// column 1 is State	SetColType(kColTypeComment1, 2, 2);		// port Name	SetColType(kColTypeComment2, 3, 3);		// interface Name	SetColType(kColTypeIPAddr, 4, 4);		// IP addr	SetColType(kColTypeIPAddr, 5, 5);		// mask}// ---------------------------------------------------------------------------//		¥ Click Cell// ---------------------------------------------------------------------------//  Handle click in cell.//	Display table entry in window edit fieldsvoidCInterfacesTable::ClickCell(	const TableCellT		&inCell,	const SMouseDownEvent&	inMouseDown){	InterfaceEntry_t	interfaceEntry;	SelectRow(inCell, false);	// ( ,extendFlag)	if (GetInterfaceEntry(inCell.row, &interfaceEntry))		((CInterfacesWindow*)mWindow)->DisplayInterfaceEntry(&interfaceEntry);}// ---------------------------------------------------------------------------------//		¥ GetInterfaceEntry// ---------------------------------------------------------------------------------//	Get Interface Entry from TableBooleanCInterfacesTable::GetInterfaceEntry(TableIndexT inRow, InterfaceEntry_t* outInterfaceEntry){	TableCellT	theCell;	TableItem	tData;	Boolean		result = true;		do {		// check for valid row entry		theCell.row = inRow;		theCell.col = kColumnInterfaceName;		GetCellData(theCell, &tData);		if (tData != kCommentFlag) {			result = false;			break;		}		// get entry		GetCommentData(inRow, 1, outInterfaceEntry->userPortName);	// user port name		GetCommentData(inRow, 2, outInterfaceEntry->interfaceName);// interface name		theCell.col = kColumnIPAddress;		GetCellData(theCell, &outInterfaceEntry->interfaceAddr);// interface address		theCell.col = kColumnMask;		GetCellData(theCell, &outInterfaceEntry->netMask);		// net mask		theCell.col = kColumnState;		GetCellData(theCell, &tData);		outInterfaceEntry->bringUp = (tData & kItemUp);					// bring up		outInterfaceEntry->unnumbered = (tData & kItemUnnumbered);		outInterfaceEntry->masquerading = (tData & kItemMasquerading);		outInterfaceEntry->dhcp = (tData & kItemDhcp);		//outInterfaceEntry->needGateway = (tData & kItemNeedGateway);		outInterfaceEntry->isDone = false;									// is done	} while (false);		return result;}// ---------------------------------------------------------------------------------//		¥ SetInterfaceEntry// ---------------------------------------------------------------------------------//	Set Interfaces Entry in Table//	Refresh if entry was changedvoidCInterfacesTable::SetInterfaceEntry(TableIndexT inRow, InterfaceEntry_t* inEntry){	TableCellT	theCell;	TableItem	tData, uData;	Str63		str;	Boolean		result = false;	do {		// check for valid row entry		if (inRow > kMaxInterfacesTableRows) {			result = false;			break;		}		// insert rows if needed		if (inRow > mRows) {			tData = 0;			InsertRows(inRow-mRows, mRows, &tData);	// how many, after row, *data		}		theCell.row = inRow;		// set entry			// UserPortName		theCell.col = kColumnPortName;		GetCellData(theCell, &uData);		str[0] = 0;		GetCommentData(inRow, 1, str);		tData = str[0];				// is there a name, and are they the same?		if ((tData != uData)	||				!::EqualString(str, inEntry->userPortName, true, false) ) {			SetCommentData(inRow, 1, inEntry->userPortName);			tData = kCommentFlag;			SetCellData(theCell, &tData);								result = true;		}						// InterfaceName		theCell.col = kColumnInterfaceName;		GetCellData(theCell, &uData);		str[0] = 0;		GetCommentData(inRow, 2, str);		tData = str[0];			// is there a name, and are they the same?		if ((tData != uData)	||			!::EqualString(str, inEntry->interfaceName, true, false) ) {			SetCommentData(inRow, 2, inEntry->interfaceName);			tData = kCommentFlag;			SetCellData(theCell, &tData);			result = true;		}						// IP address		theCell.col = kColumnIPAddress;		tData = inEntry->interfaceAddr;		GetCellData(theCell, &uData);		if (tData != uData) {			SetCellData(theCell, &tData);			result = true;		}			// NetMask		theCell.col = kColumnMask;		tData = inEntry->netMask;		GetCellData(theCell, &uData);		if (tData != uData) {			SetCellData(theCell, &tData);			result = true;		}			// state		theCell.col = kColumnState;		tData = 0;		if (inEntry->bringUp)		tData |= kItemUp;		else						tData |= kItemDown;		if (inEntry->unnumbered)	tData |= kItemUnnumbered;		if (inEntry->masquerading)	tData |= kItemMasquerading;		if (inEntry->dhcp)			tData |= kItemDhcp;		//if (inEntry->needGateway)	tData |= kItemNeedGateway;		GetCellData(theCell, &uData);		if (tData != uData) {			SetCellData(theCell, &tData);			result = true;		}	} while (false);	if (result) RefreshRow(inRow);}// ---------------------------------------------------------------------------//		¥ Draw Cell// ---------------------------------------------------------------------------voidCInterfacesTable::DrawCell(	const TableCellT	&inCell){	Rect		cellFrame;	TableItem	tData;	OSErr		err = NoError;	if (FetchLocalContentFrame(inCell, cellFrame)) {		// draw white background		::PenNormal();		ApplyForeAndBackColors();		::EraseRect(&cellFrame);		// draw border around cell		::InsetRect(&cellFrame, -1, -1);		::PenPat(&UQDGlobals::GetQDGlobals()->gray);		if (PaneInColor (this)) {			StColorState	saveColor;			RGBColor		emptyColor;			emptyColor = gAGAColorArray[6];			::RGBForeColor(&emptyColor);			::FrameRect(&cellFrame);		} else { ::FrameRect(&cellFrame); }		::PenPat(&UQDGlobals::GetQDGlobals()->black);				// draw contents		::TextFont(applFont);		::TextFace(0);	// normal		::TextSize(9);		// Get cell data		GetCellData( inCell, &tData );		// Handle each column		switch (inCell.col) {			case kColumnState:				// first column, display interface state				if (tData != kItemNone) {					// up or down					cellFrame.left += 1;					cellFrame.right = cellFrame.left + 16;					if (tData & kItemUp) {						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Up);						Assert_(err == NoError);					} else if (tData & kItemDown) {						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Down);						Assert_(err == NoError);					}					// IP Masquerading					cellFrame.left += 15;					cellFrame.right = cellFrame.left + 16;					if (tData & kItemMasquerading) {						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Masquerading);						Assert_(err == NoError);					}					// Unnumbered					cellFrame.left += 15;					cellFrame.right = cellFrame.left + 16;					if (tData & kItemUnnumbered) {						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Unnumbered);						Assert_(err == NoError);					}					else if (tData & kItemDhcp) {						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Dhcp);						Assert_(err == NoError);					}				}				break;			default:				// inherit behavior for common data types				CConfigureTable::DrawCell(inCell);		}	}}