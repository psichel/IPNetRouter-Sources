// =================================================================================//	CInterfacesAction.cp			©1998 Sustainable Softworks All rights reserved.// =================================================================================//	Configure Interface Window#include "CompileFlags.h"#include "CInterfacesAction.h"#include "CInterfacesConst.h"#include "CRoutesConst.h"#include "CGatewayData.h"#include "CConfigDocument.h"#include "CFilterData.h"#include "CDeviceData.h"#include "CConnectionData.h"#include "CGatewayData.h"#include "CGatewayAction.h"#include "CInterfacesData.h"#include "CPortMapData.h"#include "CPortMapConst.h"#include "CPortMapAction.h"#include "CRoutesAction.h"#include "CArpAction.h"#include "CTurboUDPEndpoint.h"#include <LTCPEndpoint.h>#include "IPRouterCommon.h"#include "MacSupport.h"#include "IPSupport.h"#include "CLogAction.h"#include <UReanimator.h>#include <LString.h>#include <LPreferencesFile.h>#include <UResourceMgr.h>#include <LArrayIterator.h>#include <OpenTransport.h>#include <OpenTptConfig.h>#include <OpenTptInternet.h>#include <OpenTptLinks.h>#include <modnames.h>			// names of the standard OT modules#include <dlpi.h>#include "MyOTInetMultilink.h"//#include <myif.h>#include <miioccom.h>#include "CNatTask.h"#include "CFilterAction.h"#include "CProxyControl.h"#include "CDHCPAction.h"#include "CDHCPData.h"#include "CDNSAction.h"#include "CIPRouterApp.h"// Globalsextern CLogAction*			gLogAction;extern CResidentIfInfo*		gResInfo;extern CDeviceData*			gDeviceData;extern CConnectionData* 	gConnectionData;extern CGatewayData*		gGatewayData;extern CGatewayAction*		gGatewayAction;extern CInterfacesData*		gInterfacesData;extern CRoutesData*         gRoutesData;extern CFilterData*         gFilterData;extern CPortMapAction*		gPortMapAction;extern CPortMapData*		gPortMapData;extern CFilterAction*		gFilterAction;extern CRoutesAction*		gRoutesAction;extern CArpAction*          gArpAction;extern CProxyControl*		gProxyControl;extern CDHCPAction*			gDHCPAction;extern CDHCPData*			gDHCPData;extern CDNSAction*			gDNSAction;extern CIPRouterApp*		gAppObject;extern UInt8				gApplicationMode;// ---------------------------------------------------------------------------------//		¥ CInterfacesAction()// ---------------------------------------------------------------------------------CInterfacesAction::CInterfacesAction(){	// more initialization	mNatTask = nil;	mIpStream = nil;	mEndpoint = nil;	mIsListener = false;	mProviderWillClose = false;	mProviderWasClosed = false;	mInterfacesData = nil;	mIsMonitoringPPP = false;	mFlagsWhere = kFlagsUnknown;	mIsOTClosed = false;}// ---------------------------------------------------------------------------------//		¥ ~CInterfacesAction// ---------------------------------------------------------------------------------CInterfacesAction::~CInterfacesAction(){	Terminate();		if (mInterfacesData) delete mInterfacesData;	}// ---------------------------------------------------------------------------------//		¥ Terminate// ---------------------------------------------------------------------------------voidCInterfacesAction::Terminate(){	// stop waiting to restore interfaces	StopIdling();		// release the Nat task we created	if (mNatTask) {		delete mNatTask;		mNatTask = nil;	}	// Release the stream we created	if (mIpStream != nil) {		::OTStreamClose(mIpStream);		mIpStream = nil;	}	// Release the Endpoint we created	if (mEndpoint) {		mEndpoint->RemoveListener(this);		delete mEndpoint;		mEndpoint = nil;	}}// ---------------------------------------------------------------------------------//		¥ LoadIfConfig// ---------------------------------------------------------------------------------//	Add or Remove interfaces to match inConfigSInt32CInterfacesAction::LoadIfConfig(CInterfacesData* inInterfacesData){	OTResult	result = kOTNoError;	SInt32		numTableE, numConfigE;	TableIndexT	row;	ArrayIndexT index;	SInt32		match;	do {		// setup access to ConfigData		InterfaceEntry_t	ifConfigEntry, ifTableEntry;		if (inInterfacesData == nil) break;			// nothing to configure		numConfigE = inInterfacesData->GetDataCount();		if (numConfigE == 0) break;					// nothing to configure		// initialize to remember old and new DHCP address if needed		gResInfo->mDHCPNet.address = 0;		gResInfo->mDHCPNet.mask = 0;		gResInfo->mDHCPSavedNet.address = 0;		gResInfo->mDHCPSavedNet.mask = 0;				// setup access to ifTable		numTableE = gInterfacesData->GetDataCount();		// Check each existing interface to see if it is included		// in the configuration being loaded.  If so, mark		// it as already present, if not try to remove it.				// for each table row from last to first (an existing interface)		for (row=numTableE; row>=1; row--) {			match = kEntryNoMatch;			// get interface entry from table			if ( !gInterfacesData->GetDataInterfacesArray(row, &ifTableEntry) ) continue;			// try to match in config with a saved interface			//match = gInterfacesData->MatchInterfaceInConfig(&ifTableEntry, inInterfacesData, &ifConfigEntry);			// for each config element (a saved interface)			for (index=numConfigE; index>=1; index--) {				// get interface entry from config being loaded				if ( !inInterfacesData->GetDataInterfacesArray(index, &ifConfigEntry) ) continue;				// test how they match				match = gInterfacesData->MatchInterfaceEntry(&ifTableEntry, &ifConfigEntry);				if (match != kEntryNoMatch) {					// interface name or more matches, stop looking					break;	// get out				}				// continue looking for matching entry			}			if (match & kEntryNeedAddr) {				// names match, but different IP address or mask				if (ifConfigEntry.dhcp) {					// don't overwrite a DHCP configuration						gResInfo->mDHCPNet.address	= ifTableEntry.interfaceAddr;						gResInfo->mDHCPNet.mask		= ifTableEntry.netMask;						gResInfo->mDHCPSavedNet.address	= ifConfigEntry.interfaceAddr;						gResInfo->mDHCPSavedNet.mask	= ifConfigEntry.netMask;					ifConfigEntry.interfaceAddr = ifTableEntry.interfaceAddr;					ifConfigEntry.netMask = ifTableEntry.netMask;					inInterfacesData->SetDataInterfacesArray(index, &ifConfigEntry);					// tell user what happened					gLogAction->LogText("\p\rDifferent DHCP address detected.");				}			}			if (match == kEntryMatch) {				// matching interface already exists, mark config as already done				ifConfigEntry.isDone = true;				inInterfacesData->SetDataInterfacesArray(index, &ifConfigEntry);				// transfer wamnet parameter if present				if (ifConfigEntry.wamnet) {					ifTableEntry.wamnet = ifConfigEntry.wamnet;					gInterfacesData->SetDataInterfacesArray(row, &ifTableEntry);				}			}			if ((match == kEntryNoMatch) && !gGatewayData->GetDataAddOnly()) {				// no match was found				// try to remove existing interface				result = RemoveInterface(&ifTableEntry, false);				if (result != kOTNoError) {					gInterfacesData->SetDataInterfaceEntry(&ifTableEntry);					// command failed, interfaces entry in window has already been updated					// summarize for user					gLogAction->LogText("\p\rRestore interfaces detected one or more errors");				}			}		}				//if (result == kOTNoError) {		if (true) {						// For each interface in the configuration being loaded that is not			// already present, try to create it.			for (index=1; index<=numConfigE; index++) {				// get interface entry from config being loaded				if ( !inInterfacesData->GetDataInterfacesArray(index, &ifConfigEntry) ) continue;				// ignore the loopback interface				if (::EqualString("\plo0", ifConfigEntry.interfaceName, false, false)) continue;				// if not already present				if (ifConfigEntry.isDone == false) {					// bring up or remove					if (ifConfigEntry.bringUp) {						result = DoInterfaceEntry(&ifConfigEntry, false);					} else {						result = RemoveInterface(&ifConfigEntry, false);					}					if (result != kOTNoError) {						// command failed, interfaces entry in window has already been updated						// summarize for user						gLogAction->LogText("\p\rRestore interfaces detected one or more errors");					}				}				else {           		    // interface is already present           		    // Enable or Disable masquerading on this interface to restore Port Mapping            		if ((ifConfigEntry.masquerading) && (ifConfigEntry.bringUp)) {            			EnableMasquerading(&ifConfigEntry);            		} else {            			DisableMasquerading(&ifConfigEntry);            		}								}				}		}			UpdateInterfacesData();		gRoutesAction->UpdateRoutesData();		// Setup DNS Forwarding		gGatewayAction->SetupDNSForwarding();			} while (false);		return result;}// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------voidCInterfacesAction::ListenToMessage(	MessageT	inMessage,	void		*ioParam ){	OSStatus 		err = noErr;	try {		switch ( inMessage ) {//			case msg_SnmpData://				SnmpData((SnmpDataMsg_t*)ioParam);//				break;						// Endpoint notifications			case kOTProviderWillClose:			case kOTProviderIsClosed:				// handle OT provider going away				ProviderWillClose();				break;//			case msg_BroadcasterDied://				break;			default:				gLogAction->LogText("\p\rCInterfacesAction unknown async message type: ", inMessage);				break;		}	}	catch (const LException& inErr) {		gLogAction->LogText("\p\rCInterfacesAction::ListenToMessage unexpected result from OT: ", inErr.GetErrorCode());		gLogAction->LogText("\p\r Is TCP/IP configured and OTModl$Proxy in your Extensions Folder?");		::SysBeep(1);	} 	catch (...) {		gLogAction->LogText("\p\rCInterfacesAction::ListenToMessage unexpected Exception");		::SysBeep(1);	}}#pragma mark --- Interfaces Data and IP module Accessors ---// ---------------------------------------------------------------------------------//		¥ CheckIPReady()// ---------------------------------------------------------------------------------//	Check if OT is configured by counting UP interfaces//  in the ipif_status report.BooleanCInterfacesAction::CheckIPReady(){	Boolean     ready = false;	SInt32      count = 0;	OTResult	result = kOTNoError;	StreamRef	ipStream = nil;		// Stream to IP module	InterfaceEntry_t	interfaceEntry;	UInt8				retryCount;	do {		struct strioctl	stri;		char ndCommandBuffer[kNDCommandLength];		UInt32 realDataSize;					//	Create a tcp endpoint to force the InetConfigurator to fire		//	(blocks until TCP/IP is ready)//		result = gProxyControl->AsyncOpenAndClose();//		if (result != kOTNoError) {//			gLogAction->LogText("\p\rUpdateInterfacesData unexpected result initializing OT: ", result);//			break;//		}		// create a raw stream to IP.  Do this each time for reliability.		ipStream = ::OTStreamOpen(MI_IP_NAME, 0, &result);		if (result != kOTNoError) {			//gLogAction->LogText("\p\rUpdateInterfacesData unexpected result creating raw stream to IP: ", result);			break;		}					// Switch the stream in sync/blocking mode.  To make the		// code easier, we're going to do this synchronously.		(void) ::OTStreamSetBlocking(ipStream);		(void) ::OTStreamSetSynchronous(ipStream);		// Copy the name of the ND variable we're trying to get into our buffer.		::OTStrCopy(ndCommandBuffer, IP_IPIF_STATUS);		// First get the size of data buffer we need to allocate by		// doing the ioctl with a small buffer and examining the result.		// Initialise the I_STR ioctl structure.		stri.ic_cmd = ND_GET;		stri.ic_timout = 0;		stri.ic_len = kNDCommandLength;		stri.ic_dp = ndCommandBuffer;		// Send the ioctl.		result = OTStreamIoctl(ipStream, I_STR, &stri);		if (result < 0) break;	// return error		if (result < kNDCommandLength) {			// No data, empty table.			gInterfacesData->SetDataCount(0);			result = kOTNoError;			break;		}				retryCount = 3;		while ((result > kNDCommandLength) && (retryCount > 0)) {			retryCount -= 1;			// The first ioctl returned a positive number telling			// us how big the data returned was.  We turn around			// around make the ioctl again, this time passing			// in an appropriately sized buffer.			realDataSize = result + 1024;					StHandleBlock NDReport(realDataSize, false, false);			Handle dataH;			dataH = NDReport.Get();			if (dataH == nil) {				result = memFullErr;				break;					}						// begin scope for locked handle			{				StHandleLocker lock((Handle)dataH);									OTStrCopy(*dataH, IP_IPIF_STATUS);				// Initialise the I_STR ioctl structure.				stri.ic_cmd = ND_GET;				stri.ic_timout = 0;				stri.ic_len = realDataSize;				stri.ic_dp = *dataH;				// Send the ioctl.				result = OTStreamIoctl(ipStream, I_STR, &stri);				if (result == kOTNoError) {					// We have the ND report,					// initialize to examine each line					DeviceEntry_t deviceEntry;					UInt32 start, end, eol, pos;					UInt8* dp;					Str63 str;					dp = (UInt8*)*dataH;					start = 0;					end = stri.ic_len;	// actual length of report					eol = FindByte(0, dp, start, end);	// end of line					// log each line for debugging if requested					if (false) {						gLogAction->LogCText((char*)&dp[start]);					}					start = eol + 1;	// skip first line of headings					eol = FindByte(0, dp, start, end);	// end of line					while (eol > 0) {						// log each line for debugging if requested						if (false) {							gLogAction->LogCText((char*)&dp[start]);						}						// extract data from line						do {							bzero((UInt8*)&interfaceEntry, sizeof(InterfaceEntry_t));								// Mentat IPIF							pos = GetParamString(dp, start, eol, str);							if (pos) interfaceEntry.mentatIPIF = HEX_StrToInt(str);							else break;							start = pos;								// interfaceAddr							pos = GetParamString(dp, start, eol, str);							if (pos) interfaceEntry.interfaceAddr = IP_StrToInt(str);							else break;							start = pos;								// netMask							pos = GetParamString(dp, start, eol, str);							if (pos) interfaceEntry.netMask = IP_StrToInt(str);							else break;							start = pos;								// broadcast							pos = GetParamString(dp, start, eol, str);							if (!pos) break;							start = pos;								// p-p-dest							pos = GetParamString(dp, start, eol, str);							if (!pos) break;							start = pos;								// metric							pos = GetParamString(dp, start, eol, str);							if (!pos) break;							start = pos;								// mtu							pos = GetParamString(dp, start, eol, str);							if (!pos) break;							start = pos;								// in/out/forward							pos = GetParamString(dp, start, eol, str);							if (!pos) break;							start = pos;								// interfaceName							pos = GetInterfaceNameString(dp, start, eol, str);							if (::EqualString(str, "\plo0", false, false)) break;	// skip lo0							if (pos) {							    LString::CopyPStr(str, interfaceEntry.interfaceName, sizeof(Str63));							}							else break;							start = pos;								// portName and userPortName							if (gDeviceData->FindDataDeviceArray(nil, nil, interfaceEntry.interfaceName, &deviceEntry)) {								LString::CopyPStr(deviceEntry.portName, interfaceEntry.portName);								LString::CopyPStr(deviceEntry.userPortName, interfaceEntry.userPortName);							}							// get attributes								// bringUp							pos = GetParamString(dp, start, eol, str);							while (pos) {								if (::EqualString(str, "\pUP", false, false)) {									interfaceEntry.bringUp = true;									// found an up interface									ready = true;									count += 1;								}								if (::EqualString(str, "\pUNNUMBERED", false, false))									interfaceEntry.unnumbered = true;								start = pos;								pos = GetParamString(dp, start, eol, str);							}						} while (false);						// prepare to get next line						start = eol +1;						eol = FindByte(0, dp, start, end);	// end of line					}				}	// if (result == kOTNoError)			}	// end scope for locked handle		}	// end while (retryCount > 0)		// if all retries failed, warn user in log		if ((retryCount == 0) && (result > 0)) {			// cache report changed size, just get out			//gLogAction->LogText("\p\rUpdateInterfacesData unexpected result reading interfaces data: ", result);			result = kEAGAINErr;			break;		}	} while (false);	// clean up	if (ipStream != nil) {		(void) OTStreamClose(ipStream);	}			return ready;}// ---------------------------------------------------------------------------------//		¥ UpdateInterfacesData// ---------------------------------------------------------------------------------//	Update Interfaces Data from IP moduleOTResultCInterfacesAction::UpdateInterfacesData(){	OTResult	result = kOTNoError;	StreamRef	ipStream = nil;		// Stream to IP module	InterfaceEntry_t	interfaceEntry;	UInt8				retryCount;	// temporary object to store existing interfaces with WAM!NET parameter	CInterfacesData		tInterfacesData;	InterfaceEntry_t	tInterfaceEntry;	ArrayIndexT			count, tCount, i;	// temporary object to store interfaces we read using NDD before sorting	CInterfacesData		uInterfacesData;	InterfaceEntry_t	uInterfaceEntry;	ArrayIndexT			uCount, index, row;	do {		struct strioctl	stri;		char ndCommandBuffer[kNDCommandLength];		UInt32 realDataSize;		// don't try to update if provider is closing!		if (mProviderWillClose) break;			// copy existing interfaces with WAM!NET or needGateway parameter		tCount = 0;		tInterfacesData.Init();		// start with our own interfaceEntry		gInterfacesData->GetDataInterfaceEntry(&interfaceEntry);		tCount += 1;		tInterfacesData.SetDataInterfacesArray(tCount, &interfaceEntry);		// continue with interfacesArray		count = gInterfacesData->GetDataCount();		for (i=1; i<=count; i++) {			gInterfacesData->GetDataInterfacesArray(i, &interfaceEntry);			if (interfaceEntry.wamnet ||				interfaceEntry.needGateway ||				interfaceEntry.unnumbered) {				// || interfaceEntry.dhcp) {				tCount += 1;				tInterfacesData.SetDataInterfacesArray(tCount, &interfaceEntry);			}		}					//	Create a tcp endpoint to force the InetConfigurator to fire		//	(blocks until TCP/IP is ready)		result = gProxyControl->AsyncOpenAndClose();		if (result != kOTNoError) {			gLogAction->LogText("\p\rUpdateInterfacesData unexpected result initializing OT: ", result);			break;		}		// create a raw stream to IP.  Do this each time for reliability.		ipStream = ::OTStreamOpen(MI_IP_NAME, 0, &result);		if (result != kOTNoError) {			gLogAction->LogText("\p\rUpdateInterfacesData unexpected result creating raw stream to IP: ", result);			break;		}					// Switch the stream in sync/blocking mode.  To make the		// code easier, we're going to do this synchronously.		(void) ::OTStreamSetBlocking(ipStream);		(void) ::OTStreamSetSynchronous(ipStream);		// Copy the name of the ND variable we're trying to get into our buffer.		::OTStrCopy(ndCommandBuffer, IP_IPIF_STATUS);		// First get the size of data buffer we need to allocate by		// doing the ioctl with a small buffer and examining the result.		// Initialise the I_STR ioctl structure.		stri.ic_cmd = ND_GET;		stri.ic_timout = 0;		stri.ic_len = kNDCommandLength;		stri.ic_dp = ndCommandBuffer;		// Send the ioctl.		result = OTStreamIoctl(ipStream, I_STR, &stri);		if (result < 0) break;	// return error		if (result < kNDCommandLength) {			// No data, empty table.			gInterfacesData->SetDataCount(0);			result = kOTNoError;			break;		}				retryCount = 3;		while ((result > kNDCommandLength) && (retryCount > 0)) {			retryCount -= 1;			// The first ioctl returned a positive number telling			// us how big the data returned was.  We turn around			// around make the ioctl again, this time passing			// in an appropriately sized buffer.			realDataSize = result + 1024;					StHandleBlock NDReport(realDataSize, false, false);			Handle dataH;			dataH = NDReport.Get();			if (dataH == nil) {				result = memFullErr;				break;					}						// begin scope for locked handle			{				StHandleLocker lock((Handle)dataH);									OTStrCopy(*dataH, IP_IPIF_STATUS);				// Initialise the I_STR ioctl structure.				stri.ic_cmd = ND_GET;				stri.ic_timout = 0;				stri.ic_len = realDataSize;				stri.ic_dp = *dataH;				// Send the ioctl.				result = OTStreamIoctl(ipStream, I_STR, &stri);				if (result == kOTNoError) {					// We have the ND report,					// initialize to examine each line					DeviceEntry_t deviceEntry;					UInt32 start, end, eol, pos;					UInt8* dp;					Str63 str;					dp = (UInt8*)*dataH;					start = 0;					end = stri.ic_len;	// actual length of report					eol = FindByte(0, dp, start, end);	// end of line					// log each line for debugging if requested					if (false) {						gLogAction->LogCText((char*)&dp[start]);					}					start = eol + 1;	// skip first line of headings					eol = FindByte(0, dp, start, end);	// end of line					row = 0;					while (eol > 0) {						// log each line for debugging if requested						if (false) {							gLogAction->LogCText((char*)&dp[start]);						}						// extract data from line						do {							bzero((UInt8*)&interfaceEntry, sizeof(InterfaceEntry_t));								// Mentat IPIF							pos = GetParamString(dp, start, eol, str);							if (pos) interfaceEntry.mentatIPIF = HEX_StrToInt(str);							else break;							start = pos;								// interfaceAddr							pos = GetParamString(dp, start, eol, str);							if (pos) interfaceEntry.interfaceAddr = IP_StrToInt(str);							else break;							start = pos;								// netMask							pos = GetParamString(dp, start, eol, str);							if (pos) interfaceEntry.netMask = IP_StrToInt(str);							else break;							start = pos;								// broadcast							pos = GetParamString(dp, start, eol, str);							if (!pos) break;							start = pos;								// p-p-dest							pos = GetParamString(dp, start, eol, str);							if (!pos) break;							start = pos;								// metric							pos = GetParamString(dp, start, eol, str);							if (!pos) break;							start = pos;								// mtu							pos = GetParamString(dp, start, eol, str);							if (!pos) break;							start = pos;								// in/out/forward							pos = GetParamString(dp, start, eol, str);							if (!pos) break;							start = pos;								// interfaceName							pos = GetInterfaceNameString(dp, start, eol, str);							if (::EqualString(str, "\plo0", false, false)) break;	// skip lo0							if (pos) LString::CopyPStr(str, interfaceEntry.interfaceName, sizeof(Str63));							else break;							start = pos;								// portName and userPortName							if (gDeviceData->FindDataDeviceArray(nil, nil, interfaceEntry.interfaceName, &deviceEntry)) {								LString::CopyPStr(deviceEntry.portName, interfaceEntry.portName);								LString::CopyPStr(deviceEntry.userPortName, interfaceEntry.userPortName);							}							// get attributes								// bringUp							pos = GetParamString(dp, start, eol, str);							while (pos) {								if (::EqualString(str, "\pUP", false, false))									interfaceEntry.bringUp = true;								if (::EqualString(str, "\pUNNUMBERED", false, false))									interfaceEntry.unnumbered = true;								start = pos;								pos = GetParamString(dp, start, eol, str);							}								// IP Masquerading?							proxy_names_t	proxyNames;							UInt32			theHash;							interfaceEntry.masquerading = false;							gInterfacesData->GetDataProxyNames(&proxyNames);							theHash = HashName(interfaceEntry.portName);							if (theHash != 0) {								for (i=0; i<kNatNumDim; i++) {									if (theHash == proxyNames.NatPortName[i]) {										if (interfaceEntry.interfaceAddr == proxyNames.NatIPAddr[i]) {											// mark as masquerading											interfaceEntry.masquerading = true;										}										break;									}								}							}								// DHCP?							interfaceEntry.dhcp = (HashName(interfaceEntry.interfaceName) == gResInfo->mDHCPinterface);							// get needGateway and WAM!NET state							interfaceEntry.wamnet = false;		// default to false							interfaceEntry.needGateway = false;							//interfaceEntry.unnumbered = false;							//interfaceEntry.dhcp = false;							// look for matching interface in temporary array							SInt32 match;							match = gInterfacesData->MatchInterfaceInConfig(&interfaceEntry, &tInterfacesData, &tInterfaceEntry);							if (match != kEntryNoMatch) {								// transfer wamnet parameter								interfaceEntry.wamnet = tInterfaceEntry.wamnet;								interfaceEntry.needGateway = tInterfaceEntry.needGateway;								//interfaceEntry.unnumbered = tInterfaceEntry.unnumbered;								//interfaceEntry.dhcp = tInterfaceEntry.dhcp;							}							// put corresponding row in table							row += 1;							uInterfacesData.SetDataInterfacesArray(row, &interfaceEntry);						} while (false);						// prepare to get next line						start = eol +1;						eol = FindByte(0, dp, start, end);	// end of line					}					// set how many rows we found					uInterfacesData.SetDataCount(row);				}	// if (result == kOTNoError)			}	// end scope for locked handle		}	// end while (retryCount > 0)		// if all retries failed, warn user in log		if ((retryCount == 0) && (result > 0)) {			// cache report changed size, just get out			gLogAction->LogText("\p\rUpdateInterfacesData unexpected result reading interfaces data: ", result);			result = kEAGAINErr;			break;		}		// sort and transfer to gInterfaces		// initialize to load gInterfaces data		row = 0;		// get number of interfaces we read using NDD		uCount = uInterfacesData.GetDataCount();		while (uCount > 0) {			// get first from list			uInterfacesData.GetDataInterfacesArray(1, &interfaceEntry);			index = 1;			for (i=2; i<=uCount; i++) {				// get next from list				uInterfacesData.GetDataInterfacesArray(i, &uInterfaceEntry);				// compare to current first				if (CompareInterfaceEntry(&interfaceEntry, &uInterfaceEntry) > 0) {					// save as new first entry					uInterfacesData.GetDataInterfacesArray(i, &interfaceEntry);					index = i;				}			}			// put in next row of table			row += 1;			gInterfacesData->SetDataInterfacesArray(row, &interfaceEntry);			// remove from list			uInterfacesData.RemoveDataInterfacesArray(index);			// get number of interfaces remaining			uCount = uInterfacesData.GetDataCount();		}				// set how many rows we found		gInterfacesData->SetDataCount(row);	} while (false);	// clean up	if (ipStream != nil) {		(void) OTStreamClose(ipStream);	}			return result;}#define kDelimiterChar ' '// ---------------------------------------------------------------------------------//		¥ GetParamString// ---------------------------------------------------------------------------------// Get param string from array dp// Returns offset to one past end of parameter or zero if not found//	parameter is terminated by a 'kDelimiterChar' or NULL or ending offsetSInt32CInterfacesAction::GetParamString(UInt8* dp, SInt32 start, SInt32 end, Str63 outStr){	SInt32	pos, eol, len;	pos = 0;	if (start < end) {		// find end of line		eol = FindByte(0, dp, start, end);		if (eol == 0) eol = end;		// skip any leading spaces		pos = start;		while (dp[pos] == ' ') pos+=1;					start = pos;		// find end of param		pos = FindByte(kDelimiterChar, dp, start, end);		if ((pos == 0) || (pos > eol)) pos = eol;		len = pos - start;		if ((len >= 0) && (len < 255)) {			outStr[0] = len;			::BlockMove(&dp[start], &outStr[1], len);		} else pos = 0;	}	return pos;}// ---------------------------------------------------------------------------------//		¥ GetInterfaceNameString// ---------------------------------------------------------------------------------// Get Interface Name string from array dp// Returns offset to one past end of parameter or zero if not found//	parameter is terminated by a 'kDelimiterChar' or NULL or ending offsetSInt32CInterfacesAction::GetInterfaceNameString(UInt8* dp, SInt32 start, SInt32 end, Str63 outStr){	SInt32	pos, eol, len;	UInt8	lastChar;	pos = 0;	if (start < end) {		// find end of line		eol = FindByte(0, dp, start, end);		if (eol == 0) eol = end;		// skip any leading spaces		pos = start;		while (dp[pos] == ' ') pos+=1;					start = pos;		// find end of interface name		pos = FindByte(kDelimiterChar, dp, start, end);		if ((pos == 0) || (pos > eol)) pos = eol;		// must end with a digit		lastChar = dp[pos-1];		if (!IsDigit(lastChar)) {			pos = FindByte(kDelimiterChar, dp, pos+1, end);			if ((pos == 0) || (pos > eol)) pos = eol;		}		len = pos - start;		if ((len >= 0) && (len < 255)) {			outStr[0] = len;			::BlockMove(&dp[start], &outStr[1], len);		} else pos = 0;	}	return pos;}// ---------------------------------------------------------------------------------//		¥ ParseIfName// ---------------------------------------------------------------------------------//	Split interface name into module name and unique ID (unit name)voidCInterfacesAction::ParseIfName(Str63 inStr, Str63 outModuleName,	SInt32& outDeviceNumber, SInt32& outInterfaceNumber){	LStr255 		name, part;	UInt8			pos, len;	// set defaults	outDeviceNumber = 0;	outInterfaceNumber = 0;	// check for empty name	if (inStr[0] == 0) {		name = "\p";	} else {		// separate name into respective parts		name = inStr;		// look for colon		pos = name.Find(':');		if (pos) {			// found colon, try to get interface number			len = name.Length();			if (len-pos > 0) {				part.Assign(name, pos+1, len-pos);				::StringToNum(part, &outInterfaceNumber);			}			pos -= 1;				// pos = one before colon		}		else pos = name.Length();	// pos = last char		// get device number (assume it's a single digit) and name		if (('0' <= name[pos]) && (name[pos] <= '9')) {			outDeviceNumber = name[pos] - '0';			name.Assign(name, 1, pos-1);		} else {			// not a digit			name.Assign(name, 1, pos);		}	}	// return components	LString::CopyPStr(name, outModuleName);}// ---------------------------------------------------------------------------------//		¥ CompareInterfaceEntry// ---------------------------------------------------------------------------------// Compare interfaces to sort table by PPP, MacIP, and InterfaceName.// Return 1 if A>B, 0 if same, or -1 if A<BSInt32CInterfacesAction::CompareInterfaceEntry(		InterfaceEntry_t* inInterfaceEntryA, InterfaceEntry_t* inInterfaceEntryB){	SInt32				result = 0;	DeviceEntry_t		deviceEntryA, deviceEntryB;	Boolean				foundInfoA, foundInfoB;	Str63				moduleNameA, moduleNameB;	SInt32				deviceNumberA, deviceNumberB;	SInt32				interfaceNumberA, interfaceNumberB;		do {		// get interface info 		foundInfoA = gDeviceData->FindDataDeviceArray(nil, inInterfaceEntryA->portName, nil, &deviceEntryA);		foundInfoB = gDeviceData->FindDataDeviceArray(nil, inInterfaceEntryB->portName, nil, &deviceEntryB);		if (foundInfoA && foundInfoB) {			// PPP			if (deviceEntryA.needPPP && !deviceEntryB.needPPP) {				result = 1;				break;			}			if (!deviceEntryA.needPPP && deviceEntryB.needPPP) {				result = -1;				break;			}			// MacIP			if (deviceEntryA.isMacIP && !deviceEntryB.isMacIP) {				result = 1;				break;			}			if (!deviceEntryA.isMacIP && deviceEntryB.isMacIP) {				result = -1;				break;			}		}		// compare interface names		ParseIfName(inInterfaceEntryA->interfaceName, moduleNameA, deviceNumberA, interfaceNumberA);		ParseIfName(inInterfaceEntryB->interfaceName, moduleNameB, deviceNumberB, interfaceNumberB);			// module name		result = ::CompareString(moduleNameA, moduleNameB, nil);		if (result != 0) break;					// device number		if (deviceNumberA < deviceNumberB) {			result = -1;			break;		}		if (deviceNumberA > deviceNumberB) {			result = 1;			break;		}			// interface number		if (interfaceNumberA < interfaceNumberB) {			result = -1;			break;		}		if (interfaceNumberA > interfaceNumberB) {			result = 1;			break;		}	} while (false);	return result;}#pragma mark --- Configure Interface ---// ---------------------------------------------------------------------------------//		¥ DoInterfaceEntry// ---------------------------------------------------------------------------------//	Perform steps to configure interface//	- Set interface address//	- Set interface mask//	- Bring up interfaceOTResultCInterfacesAction::DoInterfaceEntry(InterfaceEntry_t* inInterfaceEntry, Boolean inUpdate){	UInt8				len;	short				flags;	OTResult			result = kOTNoError;	ifreq_t				sifreq;				// structure to hold SIOC ioctl request	struct strioctl		stri;	DeviceEntry_t		deviceEntry;	Boolean				foundInfo;	SInt32				numTableE;			// number of Interface Table Entries	TableIndexT			row;	SInt32				match;	InterfaceEntry_t	ifTableEntry;	Boolean				wamnetFlag;		do {		// check if interface is protected		wamnetFlag = false;		numTableE = gInterfacesData->GetDataCount();		for (row=1; row<=numTableE; row++) {			gInterfacesData->GetDataInterfacesArray(row, &ifTableEntry);			if (::EqualString(inInterfaceEntry->interfaceName, ifTableEntry.interfaceName, false, false)) {				// found corresponding interface in table				if (ifTableEntry.wamnet && !inInterfaceEntry->wamnet) {					// attempt to modify protected interface					wamnetFlag = true;					break;				}			}		}		if (wamnetFlag) {			gLogAction->LogText("\p\rAttempt to modify protected interface was rejected.");			result = kOTNoError;			break;	// get out		}		// get interface info 		foundInfo = gDeviceData->FindDataDeviceArray(nil, inInterfaceEntry->portName, nil, &deviceEntry);		// check option setting		Boolean	dial;		Str31	str;		::GetIndString(str, rSTRN_OptionSettings, kOptionIPNetRouterDials);		if ( BeginsWith(str, "\pIPNetRouterDials") && GetKeywordValue(str, str) ) {			long value;			::StringToNum(str, &value);			dial = value;		}		// if first time bringing up a PPP interface and not connected, try to connect first.				if ( (foundInfo) &&			 (gResInfo->mFirstPPPflag) &&			 (inInterfaceEntry->bringUp) &&			 (gGatewayData->GetDataDialOnDemand() || OptionKeyDown() || dial) &&			 (deviceEntry.needPPP) ) {			//gResInfo->SetPrimaryIf(inInterfaceEntry->portName);			result = gResInfo->MonitorPPP(inInterfaceEntry);	// make sure we are monitoring			if (result != kOTNoError) {				gLogAction->LogText("\p\rUnexpected result trying to communicate with PPP: ", result);			}			else if (!gResInfo->IsPPPUp()) {				DisableMasquerading(inInterfaceEntry);				gResInfo->ConnectPPP(inInterfaceEntry);				// Exit for now.  PPP connect event will call DoInterfaceEntry again				// when PPP is connected.				break;			}		}		// check if physical interface is already available to IP		// by trying to get interface flags		result = GetInterfaceFlags(inInterfaceEntry->interfaceName, &flags);		// if interface name is unknown		if (result == kEINVALErr) {			// Try to make selected interface available to IP			result = PlumbLinkStack(inInterfaceEntry);			if (result != kOTNoError) {					gLogAction->LogText("\p\rPlumbLinkStack: unable to setup interface, OT result ", result);				break;			}		} else {				if (result != kOTNoError) {				gLogAction->LogText("\p\rDoInterfaceEntry: unexpected error getting interface flags.");				break;			}			// check if need PPP address since we didn't PlumbLinkStack			if (foundInfo && deviceEntry.needPPP && !inInterfaceEntry->pppAddr) {				inInterfaceEntry->interfaceAddr = gResInfo->PPPGetAddress();			}		}				// check if the interface is already configured		match = gInterfacesData->MatchInterfaceInConfig(inInterfaceEntry, gInterfacesData, &ifTableEntry);		if (match == kEntryMatch) {			if (!mProviderWasClosed) break;			else {				// do partial restore anyway				match = kEntryNeedFlags + kEntryNeedMasquerading + kEntryNeedDhcp + kEntryNeedMtu;			}		}				// if need IP Address and dhcp,		// try to use existing address and mask		if ((match & kEntryNeedAddr) && (inInterfaceEntry->dhcp)) {			inInterfaceEntry->interfaceAddr = ifTableEntry.interfaceAddr;			inInterfaceEntry->netMask = ifTableEntry.netMask;			match |= ~kEntryNeedAddr;		}			// if need IP Address and address is still not specified,		// try to use existing address and mask		if ((match & kEntryNeedAddr) && (inInterfaceEntry->interfaceAddr == 0)) {			inInterfaceEntry->interfaceAddr = ifTableEntry.interfaceAddr;			inInterfaceEntry->netMask = ifTableEntry.netMask;			match |= ~kEntryNeedAddr;		}				// tell user what we're about to do		{			LStr255	text;			Str255 str;			text = "\p\rCInterfacesAction::DoInterfaceEntry\r ";			gInterfacesData->InterfaceEntryToString(inInterfaceEntry, str);			text += str;			gLogAction->LogText(text);		}		// Setup request structure		bzero((UInt8*)&sifreq, sizeof(ifreq_t));		// interface name		len = inInterfaceEntry->interfaceName[0];		if (len > IFNAMSIZ) break;		::BlockMove(&inInterfaceEntry->interfaceName[1], sifreq.ifr_name, len);		sifreq.ifr_name[len] = 0;	// make null terminated string		// Get interface flags		flags = 0;		result = GetInterfaceFlags(inInterfaceEntry->interfaceName, &flags);		// Set broadcast flag		flags |= IFF_BROADCAST;		// Bring the interface down before changing Addr or Mask		if (match & kEntryNeedAddr) {			flags &= ~IFF_UP;			result = SetInterfaceFlags(inInterfaceEntry->interfaceName, flags);			if (result != kOTNoError) break;		}				// Set interface mask		if ((inInterfaceEntry->netMask != 0) && (match & kEntryNeedAddr)) {			// Notice we set the interface mask before setting the IP address			//   since setting the address will use a default mask which may			//   not work if no mask has been specified.			::OTInitInetAddress( (InetAddress*)&sifreq.ifr_addr, 0, inInterfaceEntry->netMask);			// Issue SIOCSIFNETMASK ioctl to set interface net mask			SetupIoctl(&stri, SIOCSIFNETMASK, (char*)&sifreq, sizeof(sifreq));			result = DoIoctl(I_STR, &stri);			if (result != kOTNoError) break;		}		// Set interface address		if ((inInterfaceEntry->interfaceAddr != 0) && (match & kEntryNeedAddr)) {			::OTInitInetAddress( (InetAddress*)&sifreq.ifr_addr, 0, inInterfaceEntry->interfaceAddr );					// Issue SIOCSIFADDR ioctl to set interface address			SetupIoctl(&stri, SIOCSIFADDR, (char*)&sifreq, sizeof(sifreq));			result = DoIoctl(I_STR, &stri);			if (result != kOTNoError) break;		}		// Interface MTU		if ((inInterfaceEntry->mtu != 0) && (match & kEntryNeedMtu)) {			// tell user what were about to do			LStr255 text;			text = "\p\r Set Interface ";			text += inInterfaceEntry->interfaceName;			text += "\p MTU=";			gLogAction->LogText(text, inInterfaceEntry->mtu);			// interface mtu			sifreq.ifr_metric = inInterfaceEntry->mtu;			// Issue SIOCSIFMTU ioctl to set interface MTU			SetupIoctl(&stri, SIOCSIFMTU, (char*)&sifreq, sizeof(sifreq));			result = DoIoctl(I_STR, &stri);			if (result != kOTNoError) break;		}		else {			// Issue SIOCGIFMTU ioctl to get interface MTU			SetupIoctl(&stri, SIOCGIFMTU, (char*)&sifreq, sizeof(sifreq));			result = DoIoctl(I_STR, &stri);			if (result == kOTNoError) {				inInterfaceEntry->mtu = sifreq.ifr_metric;			}		}		// Set interface state and bring interface up or down		if ((match & kEntryNeedAddr) || (match & kEntryNeedFlags)) {			if (inInterfaceEntry->bringUp) flags |= IFF_UP;			else flags &= ~IFF_UP;				if (inInterfaceEntry->unnumbered) {				// Only allow unnumbered on point-to-point interfaces				if (foundInfo) {					if (deviceEntry.needPPP) flags |= IFF_UNNUMBERED;					}			}			// set interface flags			result = SetInterfaceFlags(inInterfaceEntry->interfaceName, flags);			if (result != kOTNoError) break;		}				// Set Pseudo Gateway if needed		SetPseudoGateway(inInterfaceEntry);				// Remember DHCP interface if requested		if (inInterfaceEntry->dhcp) {			gResInfo->mDHCPinterface = HashName(inInterfaceEntry->interfaceName);		} else {			if (gResInfo->mDHCPinterface == HashName(inInterfaceEntry->interfaceName)) {				// reset DHCP interface				gResInfo->mDHCPinterface = 0;				gResInfo->mDHCPNet.address = 0;				gResInfo->mDHCPNet.mask = 0;				gResInfo->mDHCPSavedNet.address = 0;				gResInfo->mDHCPSavedNet.mask = 0;			}		}		// Set Interfaces entry to show what we did and remember any settings we added		gInterfacesData->SetDataInterfaceEntry(inInterfaceEntry);				// Enable or Disable masquerading on this interface		//	Do this unless it was a perfect Match since other params can affect NAT		if ((inInterfaceEntry->masquerading) && (inInterfaceEntry->bringUp)) {			EnableMasquerading(inInterfaceEntry);		} else {			DisableMasquerading(inInterfaceEntry);		}		// If PPP, begin monitoring		if (foundInfo && deviceEntry.needPPP) {			gResInfo->MonitorPPP(inInterfaceEntry);		}			} while (false);	// update interfaces data again (in case masquerading changed or we didn't do it before)	if (inUpdate) {		UpdateInterfacesData();		gRoutesAction->UpdateRoutesData();		// Setup DNS Forwarding		gGatewayAction->SetupDNSForwarding();	}			// tell user what happened	if (result != kOTNoError) gLogAction->LogText("\p\rCInterfacesAction result: ", result);	return result;}// ---------------------------------------------------------------------------------//		¥ GetInterfaceFlags// ---------------------------------------------------------------------------------//	Issue SIOCGIFFLAGS to get interface flagsOTResultCInterfacesAction::GetInterfaceFlags(Str63 inInterfaceName, short* outFlags){	UInt8				len;	OTResult			result;	ifreq_t				sifreq;				// structure to hold SIOC ioctl request	struct strioctl		stri;		// Setup request structure	bzero((UInt8*)&sifreq, sizeof(ifreq_t));	// interface name	len = inInterfaceName[0];	ThrowIf_(len > IFNAMSIZ);	::BlockMove(&inInterfaceName[1], sifreq.ifr_name, len);	sifreq.ifr_name[len] = 0;	// make null terminated string			// Issue SIOCGIFFLAGS ioctl to get interface flags	SetupIoctl(&stri, SIOCGIFFLAGS, (char*)&sifreq, sizeof(sifreq));	result = DoIoctl(I_STR, &stri);	*outFlags = sifreq.ifr_flags & 0xFFFF;	// adjust to handle ifru_flags as "short" or "int"	if ((mFlagsWhere == kFlagsUnknown) && (result == noErr)) {		if (*outFlags == 0) mFlagsWhere = kFlagsHi;		else mFlagsWhere = kFlagsLo;	}	if (mFlagsWhere == kFlagsHi) {		*outFlags = sifreq.ifr_flags >> 16;	}	return result;}// ---------------------------------------------------------------------------------//		¥ SetInterfaceFlags// ---------------------------------------------------------------------------------//	Issue SIOCSIFFLAGS to set interface flagsOTResultCInterfacesAction::SetInterfaceFlags(Str63 inInterfaceName, short inFlags){	UInt8				len;	OTResult			result;	ifreq_t				sifreq;				// structure to hold SIOC ioctl request	struct strioctl		stri;		// Setup request structure	bzero((UInt8*)&sifreq, sizeof(ifreq_t));	// interface name	len = inInterfaceName[0];	ThrowIf_(len > IFNAMSIZ);	::BlockMove(&inInterfaceName[1], sifreq.ifr_name, len);	sifreq.ifr_name[len] = 0;	// make null terminated string	// interface flags	sifreq.ifr_flags = inFlags;	if (mFlagsWhere == kFlagsHi) {		sifreq.ifr_flags = sifreq.ifr_flags << 16;	}	// Issue SIOCSIFFLAGS ioctl to bring interface up or down	SetupIoctl(&stri, SIOCSIFFLAGS, (char*)&sifreq, sizeof(sifreq));	result = DoIoctl(I_STR, &stri);	return result;}// ---------------------------------------------------------------------------------//		¥ PlumbLinkStack// ---------------------------------------------------------------------------------//	Make a hardware interface available to IP//	Notice we need to create two streams if the interface//	requires address resolution (ARP).OSStatusCInterfacesAction::PlumbLinkStack(InterfaceEntry_t* inInterfaceEntry){		OSStatus 			err = noErr;	OTConfiguration*	ipLinkCfg = NULL;	OTConfiguration*	arpLinkCfg = NULL;	StreamRef			ipStream = NULL;	StreamRef			arpStream = NULL;	UInt8				len;	DeviceEntry_t		deviceEntry;	UInt16				index;	char				configStr[64];	InetHost			ipAddressBuffer;	// hold PPP address from server	Str31				driverName;	Boolean				needRestore = false;		// tell user what we're trying to do	LStr255	text;	text = "\p\rBuilding link stack for: ";	text += inInterfaceEntry->portName;	gLogAction->LogText(text);		// get a local copy of the portName as a C String	len = inInterfaceEntry->portName[0];	OTMemcpy(configStr, &inInterfaceEntry->portName[1], len);	configStr[len] = 0;		do {		// Look up interface info		index = gDeviceData->FindDataDeviceArray(nil, inInterfaceEntry->portName, nil, &deviceEntry);		if (index == 0) {			// not found, try to use defaults			deviceEntry.needArp = true;			deviceEntry.isMacIP = false;			deviceEntry.needPPP = false;		} else {			// check if streams already linked			if ((deviceEntry.ipLinkStream != nil) || (deviceEntry.arpLinkStream != nil)) {				// yes, we got KEINVALErr from GetInterfaceFlags() for				// a different reason so pass it back.				err = kEINVALErr;				break;			}		}		// (1) create configuration for supplied device string		// If we're trying to plumb PPP, append suggested IP address as an option		// configOptionStr = "ipcp(ipAddr=d.d.d.d)"		if (deviceEntry.needPPP) {			char addressStr[31];			char configOptionStr[127];			OTStrCopy(configOptionStr, configStr);			OTInetHostToString(inInterfaceEntry->interfaceAddr, addressStr);			OTStrCat(configOptionStr, "(ipAddr=\"");			OTStrCat(configOptionStr, addressStr);			OTStrCat(configOptionStr, "\")");			ipLinkCfg = OTCreateConfiguration(configOptionStr);		//	ipLinkCfg = OTCreateConfiguration(configStr);			// defensive in case 'epcf' resource for this option is not found			// (user might have an old version of PPP or another 'mdev')			if ((ipLinkCfg == NULL) || (ipLinkCfg == kOTInvalidConfigurationPtr)) {				ipLinkCfg = OTCreateConfiguration(configStr);			}		}		else {			ipLinkCfg = OTCreateConfiguration(configStr);		}		if ( ipLinkCfg == NULL )		{			err = kENOMEMErr;			break;		}		if ( ipLinkCfg == kOTInvalidConfigurationPtr )		{			err = kOTBadConfigurationErr;			break;		}		//arpLinkCfg = OTCfigCloneConfiguration(ipLinkCfg);		arpLinkCfg = OTCreateConfiguration(configStr);		if ( arpLinkCfg == NULL )		{			err = kENOMEMErr;			break;		}		// -- Build basic IP stream				// Put IP above device so create stream will see it		// as the parent.  Notice we ignore the returned config.		::OTCfigPushParent(ipLinkCfg, MI_IPM_NAME, &err);		if (err != kOTNoError) break;		// Configure it		err = OTConfigureChildren(OTCfigGetParent(ipLinkCfg));		if ( err != kOTNoError ) break;			// Special case:		// If PPP, make the interface we're about to configure		// appear as the primary interface		if (deviceEntry.needPPP) {			gResInfo->SetPrimaryIf(inInterfaceEntry->portName);		}				// Now create a stream to the device driver over which we'll		// be running IP.  Note the use OTCreateStream rather than		// OTStreamOpen.  This is because the device driver might		// have extra plumbing underneath it and just opening		// the driver would not give the driver's configurator		// chance to set up this plumbing.		ipStream = ::OTCreateStream(ipLinkCfg, 0, &err);		ipLinkCfg = nil;		if (err != noErr) {			ipStream = nil;		// set to nil so we don't try to close it			gLogAction->LogText("\p\rPlumbLinkStack: unable to create ipStream, OT result ", err);			break;		}		OTStreamSetBlocking(ipStream);		OTStreamSetSynchronous(ipStream);		// (2) if MacIP, Push IP2DDP (kIPtoDDPName)		//	    Follow that by doing a TCP_IOC_MACIPSETUP ioctl		//	    to tell IP2DDP whether we are in IPGATEWAY or NBP-ARP mode.		if (deviceEntry.isMacIP) {			err = ::OTStreamIoctl(ipStream, I_PUSH, (void*)kIPtoDDPName);			if (err != noErr) break;			// MacIP setup			tcp_ioc_macipsetup setup;					setup.ipAddress = inInterfaceEntry->interfaceAddr;			setup.inGatewayMode = false;			struct strioctl	stri;			SetupIoctl(&stri, TCP_IOC_MACIPSETUP, (char*)&setup, sizeof(tcp_ioc_macipsetup));			err = ::OTStreamIoctl(ipStream, I_STR, &stri);			if (err != noErr) break;		}				// Insert (push) our proxy module if it is not already present		else {//		{			struct str_list streamList;			struct str_mlist streamListNames[10];			Boolean foundIt = false;						streamList.sl_nmods = 10;			streamList.sl_modlist = streamListNames;			err = ::OTStreamIoctl(ipStream, I_LIST, &streamList);			if (err >= noErr) {				if ( streamList.sl_nmods > 0 ) {					for (UInt8 i=0; i<=streamList.sl_nmods; i++) {						if ( ::OTStrEqual(streamListNames[i].l_name, "Proxym") ) {							foundIt = true;							break;	// found it, get out						}					}				}			}			if (!foundIt) {				// didn't find it, push onto stream				err = ::OTStreamIoctl(ipStream, I_PUSH, (void*)"Proxym");				if (err == kEINVALErr) {					// release streams to Proxy module and try again					gProxyControl->Terminate();					gPortMapAction->Terminate(true);					gFilterAction->Terminate(true);					needRestore = true;					err = ::OTStreamIoctl(ipStream, I_PUSH, (void*)"Proxym");				}				if (err != noErr) {					gLogAction->LogText("\p\rPlumbLinkStack: unable to insert Proxym, OT result ", err);				}			}			// record actual driver name			OTStrCopy((char*)&driverName[1], streamListNames[streamList.sl_nmods-1].l_name);			driverName[0] = OTStrLength((char*)&driverName[1]);		}		// request driver info/*		{			UInt8 configBuffer[1024];			TNetbuf* ctlPtr = (TNetbuf*)configBuffer;			TNetbuf* dataPtr = (TNetbuf*)(((UInt8*)ctlPtr) + sizeof(TNetbuf));			dl_info_req_t* req = (dl_info_req_t*) 									(((UInt8*)dataPtr) + sizeof(TNetbuf));			OTFlags		getMsgFlag;						req->dl_primitive	= DL_INFO_REQ;			ctlPtr->len			= sizeof(dl_info_req_t);			ctlPtr->buf			= (UInt8*)req;			dataPtr->len		= (unsigned) -1;			dataPtr->buf		= NULL;						OTStreamPutMessage(ipStream, (strbuf*)ctlPtr, (strbuf*)dataPtr, 0);						//TNetbuf* ctlPtr   = (TNetbuf*)configBuffer;			//TNetbuf* dataPtr  = (TNetbuf*)(((UInt8*)ctlPtr) + sizeof(TNetbuf));			char*    dataArea = (char*)(((UInt8*)dataPtr) + sizeof(TNetbuf));			ctlPtr->maxlen		= sizeof(configBuffer) - (2 * sizeof(TNetbuf));			ctlPtr->buf			= (UInt8*)dataArea;			dataPtr->len		= (unsigned) -1;			dataPtr->buf		= NULL;			OTStreamGetMessage(ipStream, (strbuf*)ctlPtr, (strbuf*)dataPtr, &getMsgFlag);		}*/		// Give PPP a chance to tell us what address to use		if (deviceEntry.needPPP) {			ipAddressBuffer = 0;			struct strioctl	stri;			SetupIoctl(&stri, TCP_IOC_P2PCONFIG, (char*)&ipAddressBuffer, sizeof(InetHost));			err = ::OTStreamIoctl(ipStream, I_STR, &stri);			// set entry to use PPP address if any			if ((err == noErr) && (ipAddressBuffer != 0)) {				if (ipAddressBuffer == kOffLineAddress) {	// 169.254.255.254					// PPP has not connected awaiting dial on demand					// if an IP address was manually specified, use it					// otherwise self assign 169.254.255.254					if (inInterfaceEntry->interfaceAddr == 0) {						inInterfaceEntry->interfaceAddr = ipAddressBuffer;						gResInfo->mPPPlocalAddress  = ipAddressBuffer;					}				} else {					inInterfaceEntry->interfaceAddr = ipAddressBuffer;					gResInfo->mPPPlocalAddress  = ipAddressBuffer;					// try to get DNS address from PPP					ipAddressBuffer = 0;					SetupIoctl(&stri, TCP_IOC_DNSCONFIG, (char*)&ipAddressBuffer, sizeof(InetHost));					err = ::OTStreamIoctl(ipStream, I_STR, &stri);					if ((err == noErr) && (ipAddressBuffer != 0)) {						gResInfo->mPPPDNSAddress  = ipAddressBuffer;						gLogAction->LogText("\p\rPlumbLinkStack - DNS address from PPP server: ");						Str31 str;						IP_NumToStr(gResInfo->mPPPDNSAddress, str);						gLogAction->LogText(str);					}				}			}			else {				gLogAction->LogText("\p\rPlumbLinkStack: unable to retrieve PPP address");			}		}		// (3) push "ipm" to form fIPStream		err = ::OTStreamIoctl(ipStream, I_PUSH, (void*)MI_IPM_NAME);		if (err != noErr) {			gLogAction->LogText("\p\rPlumbLinkStack: unable to push ipm", err);			break;		}/*		// Try IF_UNITSEL ioctl so we can create ILLs out of order.		{			ifreq_t				sifreq;			// structure to hold SIOC ioctl request			struct strioctl		stri;			Str63				outModuleName;			SInt32				outDeviceNumber;			SInt32				outInterfaceNumber;						// get requested ILL number			ParseIfName(inInterfaceEntry->interfaceName,						outModuleName, outDeviceNumber, outInterfaceNumber);			// Setup request structure			bzero((UInt8*)&sifreq, sizeof(ifreq_t));			// interface name			len = outModuleName[0];			ThrowIf_(len > IFNAMSIZ);			::BlockMove(&outModuleName[1], sifreq.ifr_name, len);			sifreq.ifr_name[len] = 0;	// make null terminated string			// Set unit number			sifreq.ifr_metric = outDeviceNumber;			// Issue IF_UNITSEL ioctl to set device number			SetupIoctl(&stri, IF_UNITSEL, (char*)&sifreq, sizeof(sifreq));			err = OTStreamIoctl(ipStream, I_STR, &stri);			if (err != kOTNoError) {				gLogAction->LogText("\p\rPlumbLinkStack: IF_UNITSEL returned: ", err);			}		}*/				// -- Continue building configuration for interfaces		//	  that need address resolution (ARP)		if (deviceEntry.needArp) {			// (4) push "arpm" above IP to form Arpable fIPStream			err = OTStreamIoctl(ipStream, I_PUSH, (void*)MI_ARPM_NAME);			if (err != noErr) {				gLogAction->LogText("\p\rPlumbLinkStack: unable to push arpm on fIPStream");				break;			}			// Build 2nd stream to driver for ARP			// Put ARP above device in ARP config so create stream			// will see it as the parent.  Notice we ignore the returned config.			::OTCfigPushParent(arpLinkCfg, MI_ARPM_NAME, &err);			if (err != kOTNoError) break;			// Configure it			err = OTConfigureChildren(OTCfigGetParent(arpLinkCfg));			if ( err != kOTNoError ) break;					// (5) Now create a stream to the device driver over which we'll			// be running ARP.			arpStream = ::OTCreateStream(arpLinkCfg, 0, &err);			if (err != noErr) {				arpStream = nil;	// set to nil so we don't try to close it				gLogAction->LogText("\p\rPlumbLinkStack: unable to create arpStream");				break;			}			arpLinkCfg = nil;		// create stream destroys config			OTStreamSetBlocking(arpStream);			OTStreamSetSynchronous(arpStream);			// (6) if MacIP, Push ARP2DDP (kARPtoDDPName)			//	    Follow that by doing a TCP_IOC_MACIPSETUP ioctl			//	    to tell ARP2DDP our IP address.			if (deviceEntry.isMacIP) {				err = OTStreamIoctl(arpStream, I_PUSH, (void*)kARPtoDDPName);				if (err != noErr) break;						// MacIP setup				tcp_ioc_macipsetup setup;						setup.ipAddress = inInterfaceEntry->interfaceAddr;				setup.inGatewayMode = false;				struct strioctl	stri;				SetupIoctl(&stri, TCP_IOC_MACIPSETUP, (char*)&setup, sizeof(tcp_ioc_macipsetup));				err = ::OTStreamIoctl(arpStream, I_STR, &stri);				if (err != noErr) break;			}						// (7) push arpm to form fARPStream					err = OTStreamIoctl(arpStream, I_PUSH, (void*)MI_ARPM_NAME);			if (err != noErr) break;		}	// end if (needArp)		// Save the link StreamRefs with interface info		if (index > 0) {			deviceEntry.ipLinkStream = ipStream;			deviceEntry.arpLinkStream = arpStream;			// save updated info			gDeviceData->SetDataDeviceArray(index, &deviceEntry);		}		// tell user we finished		text = "\p\rEnd building link stack for: ";		//text += inInterfaceEntry->portName;		text += driverName;		gLogAction->LogText(text);		} while (false);		// Clean up after failure.	if (err != noErr) {		if (ipStream != nil) ::OTStreamClose( ipStream );		if (arpStream != nil) ::OTStreamClose( arpStream );	}		// General clean up.		if (ipLinkCfg != nil) OTDestroyConfiguration(ipLinkCfg);	if (arpLinkCfg != nil) OTDestroyConfiguration(arpLinkCfg);	gResInfo->RestorePrimaryIf();		// restore connections to proxy module if needed	if (needRestore) {		gProxyControl->ProxyConnect();		gPortMapAction->Init();		gFilterAction->Init();		// restore filters if any		gLogAction->LogText("\p\r Restore filters");		gFilterAction->RestoreFilterConfig();	}		return err;}// ---------------------------------------------------------------------------------//		¥ SetPseudoGateway// ---------------------------------------------------------------------------------//	Check if we need a Pseudo Gateway because we just got our interface address//	from PPP.  If so, create a default route to a PseudoGateway on the same subnet.OTResultCInterfacesAction::SetPseudoGateway(InterfaceEntry_t* inInterfaceEntry){		OTResult		result = kOTNoError;	InetHost		theGateway;	RouteEntry_t	routeEntry;		// need Pseudo Gateway?	if (inInterfaceEntry->needGateway) {		// Yes		// Try to remove previous pseudo gateway if any		RemovePseudoGateway(nil);		// find an acceptable pseudo gateway address (not all 0s or 1s)		theGateway = CalcPseudoGateway(inInterfaceEntry->interfaceAddr);		// create default route to pseudo gateway		bzero((UInt8*)&routeEntry, sizeof(RouteEntry_t));		routeEntry.routeType = IRE_GATEWAY;		routeEntry.destination = 0;		routeEntry.gateway = theGateway;		routeEntry.addRoute = true;		routeEntry.isDone = false;				// configure route		result = gRoutesAction->DoRouteEntry(&routeEntry, true);		gResInfo->mPseudoGateway = theGateway;	}	return result;}// ---------------------------------------------------------------------------------//		¥ RemovePseudoGateway// ---------------------------------------------------------------------------------//	Remove previous pseudo gateway if anyOTResultCInterfacesAction::RemovePseudoGateway(InterfaceEntry_t* inInterfaceEntry){		OTResult		result = kOTNoError;	RouteEntry_t	routeEntry;	InetHost		theGateway;	Boolean			update;	if (inInterfaceEntry) theGateway = CalcPseudoGateway(inInterfaceEntry->interfaceAddr);	else theGateway = gResInfo->mPseudoGateway;	// Try to remove previous pseudo gateway if any	if ((theGateway != 0) && (theGateway == gResInfo->mPseudoGateway)) {		bzero((UInt8*)&routeEntry, sizeof(RouteEntry_t));		routeEntry.routeType = IRE_GATEWAY;		routeEntry.destination = 0;		routeEntry.gateway = gResInfo->mPseudoGateway;		routeEntry.addRoute = false;		routeEntry.isDone = false;				// configure route		if (mProviderWillClose) update = false;		else update = true;		try {			result = gRoutesAction->DoRouteEntry(&routeEntry, update);		}		catch (const LException& inErr) {			// catch any errors here to be sure we don't miss other steps			result = inErr.GetErrorCode();		} 		gResInfo->mPseudoGateway = 0;	}	return result;}// ---------------------------------------------------------------------------------//		¥ RemoveInterface// ---------------------------------------------------------------------------------//	Remove named interfaceOTResultCInterfacesAction::RemoveInterface(InterfaceEntry_t* inInterfaceEntry, Boolean inUpdate){	OTResult			result;	DeviceEntry_t		deviceEntry;	UInt16				index;	short				flags;	ArrayIndexT			row, numRows, count;	InterfaceEntry_t	interfaceEntry;	Boolean				wamnetFlag;	enum {		kOTVersion250 = 0x02508000	};		do {		// check if interface is protected		wamnetFlag = false;		numRows = gInterfacesData->GetDataCount();		for (row=1; row<=numRows; row++) {			gInterfacesData->GetDataInterfacesArray(row, &interfaceEntry);			if (::EqualString(inInterfaceEntry->interfaceName, interfaceEntry.interfaceName, false, false)) {				// found corresponding interface in table				if (interfaceEntry.wamnet && !inInterfaceEntry->wamnet) {					// attempt to modify protected interface					wamnetFlag = true;					break;				}			}		}		if (wamnetFlag) {			gLogAction->LogText("\p\rAttempt to remove protected interface was rejected.");			result = kOTNoError;			break;	// get out		}		// tell user what we're about to do		LStr255	text;		Str255 str;		Boolean bringUp;		text = "\p\rCInterfacesAction::RemoveInterface\r ";		bringUp = inInterfaceEntry->bringUp;		inInterfaceEntry->bringUp = false;		gInterfacesData->InterfaceEntryToString(inInterfaceEntry, str);		inInterfaceEntry->bringUp = bringUp;		text += str;		gLogAction->LogText(text);							// Stop masquerading on this interface			// skip this step if provider is closing so we don't try to update		if (inInterfaceEntry->masquerading && !mProviderWillClose) DisableMasquerading(inInterfaceEntry);		// Set flags to bring down interface		flags = 0;		result = GetInterfaceFlags(inInterfaceEntry->interfaceName, &flags);		flags &= ~IFF_UP;		result = SetInterfaceFlags(inInterfaceEntry->interfaceName, flags);		if (result == kEINVALErr) {			// interface no longer exists (invalid argument)			gLogAction->LogText("\p\r kEINVALErr did not find interface.");			result = kOTNoError;	// exit gracefully			break;		}		if (result != kOTNoError) break;		// Reset DHCP interface if any		if (HashName(inInterfaceEntry->interfaceName) == gResInfo->mDHCPinterface) {			gResInfo->mDHCPinterface = 0;			gResInfo->mDHCPNet.address = 0;			gResInfo->mDHCPNet.mask = 0;			gResInfo->mDHCPSavedNet.address = 0;			gResInfo->mDHCPSavedNet.mask = 0;		}		// Remove pseudo gateway if any		RemovePseudoGateway(inInterfaceEntry);				// Check for any streams we created		index = gDeviceData->FindDataDeviceArray(inInterfaceEntry->userPortName, nil, nil, &deviceEntry);		if (index == 0) break;		else {			if ((deviceEntry.ipLinkStream == nil) && (deviceEntry.arpLinkStream == nil)) break;		}				// Found streams, see if we can close them		// Count number of Up interfaces on this port by scanning table		count = 0;		numRows = gInterfacesData->GetDataCount();				for (row=1; row<=numRows; row++) {			// get interface entry from table			if (gInterfacesData->GetDataInterfacesArray(row, &interfaceEntry)) {				// compare to specified port				if (::EqualString(inInterfaceEntry->userPortName, interfaceEntry.userPortName, true, false)) {					// get interface state					result = GetInterfaceFlags( interfaceEntry.interfaceName, &flags );					if (result == kEINVALErr) {						// interface no longer exists (invalid argument)						gLogAction->LogText("\p\rRemove Interface: did not find interface.");						flags = 0;						result = kOTNoError;	// continue gracefully					}					if (result != kOTNoError) break;					if (flags & IFF_UP) count += 1;				}			}		}		if (result != kOTNoError) break;		// if no up interfaces on this port, try to close link stream		if (count == 0) {			// try to close the corresponding device streams			if (deviceEntry.ipLinkStream != nil) {				LStr255 text;				text = "\p\rRemoveInterface - close link stream: ";				text += inInterfaceEntry->portName;				gLogAction->LogText(text);				::OTStreamClose( deviceEntry.ipLinkStream );				deviceEntry.ipLinkStream = nil;				gLogAction->LogText("\p.");			}			if (deviceEntry.arpLinkStream != nil) {				::OTStreamClose( deviceEntry.arpLinkStream );				deviceEntry.arpLinkStream = nil;				gLogAction->LogText("\p.");			}			// save updated multiplexor Link IDs in interface info			gDeviceData->SetDataDeviceArray(index, &deviceEntry);		}		// if another IP interface has the same IP address,		// bring down and bring back up to restore routing entries		if (inInterfaceEntry->unnumbered) {			SInt32				numTableE;			// number of Interface Table Entries			TableIndexT			row;			InterfaceEntry_t		ifTableEntry;					numTableE = gInterfacesData->GetDataCount();			// for each row			for (row=numTableE; row>=1; row--) {				// get interface entry from table				if ( !gInterfacesData->GetDataInterfacesArray(row, &ifTableEntry) ) continue;				// skip if same interface				if (::EqualString(inInterfaceEntry->interfaceName, ifTableEntry.interfaceName,					false, false)) continue;				// same IP address??				if (ifTableEntry.interfaceAddr == inInterfaceEntry->interfaceAddr) {					// bring down					flags = 0;					result = GetInterfaceFlags(inInterfaceEntry->interfaceName, &flags);					flags &= ~IFF_UP;					result = SetInterfaceFlags(ifTableEntry.interfaceName, flags);					// bring back up					if (ifTableEntry.bringUp) flags |= IFF_UP;							result = SetInterfaceFlags(ifTableEntry.interfaceName, flags);				}			}		}	} while (false);	// Upate display to show any changes	if (inUpdate) {		UpdateInterfacesData();		gRoutesAction->UpdateRoutesData();	}		// Setup DNS Forwarding	if (!mProviderWillClose) gGatewayAction->SetupDNSForwarding();		// tell user what happened	if (result != kOTNoError) gLogAction->LogText("\p\rCInterfacesAction result: ", result);	return result;}// ---------------------------------------------------------------------------------//		¥ RemoveAll// ---------------------------------------------------------------------------------//	Remove All interfaces we createdvoidCInterfacesAction::RemoveAll(){	OTResult			result = kOTNoError;	DeviceEntry_t		deviceEntry;	ArrayIndexT			index, numDevices;	ArrayIndexT			row, numRows;	InterfaceEntry_t	interfaceEntry;	gLogAction->LogText("\p\rCInterfacesAction: begin RemoveAll()");	// stop waiting to restore interfaces	StopIdling();		// For each registered port (in DeviceData)	numDevices = gDeviceData->GetDataCount();	for (index=1; index<=numDevices; index++) {		if ( !gDeviceData->GetDataDeviceArray(index, &deviceEntry) ) continue;		if ((deviceEntry.ipLinkStream == nil) && (deviceEntry.arpLinkStream == nil)) continue;		// Found streams, remove corresponding interfaces from InterfacesTable		// Scan from last to first		numRows = gInterfacesData->GetDataCount();		for (row=numRows; row>=1; row--) {			// get interface entry from table			gInterfacesData->GetDataInterfacesArray(row, &interfaceEntry);			// compare to desired port			if (::EqualString(interfaceEntry.userPortName, deviceEntry.userPortName, true, false)) {				try {					// try to remove interface					result = RemoveInterface(&interfaceEntry, false);				}				catch (const LException& inErr) {					// catch any errors here to be sure we remove the others					result = inErr.GetErrorCode();				} 				if (result != kOTNoError) {					// command failed, update interfaces entry so it will appear in window					gInterfacesData->SetDataInterfaceEntry(&interfaceEntry);					gLogAction->LogText(						"\p\rCInterfacesAction - RemoveAll encountered OT error: ", result);				}			}		}	}		if (!mProviderWillClose) UpdateInterfacesData();		// unlink any remaining streams we didn't find (safety)	//result = DoIoctl(I_UNLINK, (void*)MUXID_ALL);	}// ---------------------------------------------------------------------------------//		¥ Provider Will Close// ---------------------------------------------------------------------------------//	Called by SnmpTask when provider is about to closevoidCInterfacesAction::ProviderWillClose(){			// Tell user what happened	gLogAction->LogText("\p\rCInterfacesAction: KOTProviderWillClose.");	// Set flag to mark start of dance	mProviderWillClose = true;	mIsMonitoringPPP = gResInfo->IsMonitoringPPP();	mIsDHCPServerOn = gDHCPData->GetDataDHCPServerOn();	    // Copy existing interfaces	if (mInterfacesData) mInterfacesData->Init();	else mInterfacesData = new CInterfacesData();	if (mInterfacesData) {		UInt32	count, i;		InterfaceEntry_t interfaceEntry;		count = gInterfacesData->GetDataCount();		for (i=1; i<=count; i++) {			gInterfacesData->GetDataInterfacesArray(i, &interfaceEntry);			mInterfacesData->SetDataInterfacesArray(i, &interfaceEntry);		}	}	    // Copy existing routes	if (gRoutesData->mRoutesData) gRoutesData->mRoutesData->Init();	else gRoutesData->mRoutesData = new CRoutesData();	if (gRoutesData->mRoutesData) {		UInt32	count, i;		RouteEntry_t routeEntry;		count = gRoutesData->GetDataCount();		for (i=1; i<=count; i++) {			gRoutesData->GetDataRoutesArray(i, &routeEntry);			gRoutesData->mRoutesData->SetDataRoutesArray(i, &routeEntry);		}	}	    // Copy existing filters	if (gFilterData->mFilterData) gFilterData->mFilterData->Init();	else gFilterData->mFilterData = new CFilterData();	if (gFilterData->mFilterData) {		UInt32	count, i;		FilterEntry_t filterEntry;		count = gFilterData->GetDataCount();		for (i=1; i<=count; i++) {			gFilterData->GetDataFilterArray(i, &filterEntry);			gFilterData->mFilterData->SetDataFilterArray(i, &filterEntry);		}	}	try {		// Remove any data link Streams we created		RemoveAll();	}	catch (const LException& inErr) {		// catch any errors here to be sure we reset the others		gLogAction->LogText("\p\rCInterfacesAction: unexpected result during RemoveAll ", inErr.GetErrorCode());	} 	try {		gResInfo->Reset(false);			// reset before othes since it uses them		gFilterAction->Terminate(false);		gPortMapAction->Terminate(false);		gRoutesAction->Terminate();		gDHCPAction->StopServing(false);		gDNSAction->StopServing(false);		gGatewayAction->DialupDNSClientStop(false);		gArpAction->Terminate();		Terminate();		gProxyControl->Terminate();	// do this last since others use it	}	catch (const LException& inErr) {		gLogAction->LogText("\p\rCInterfacesAction: unexpected result during tear down ", inErr.GetErrorCode());	} 	catch(...) {	    SysBeep(30);	} 		// reset any OT stuff for this application	::CloseOpenTransport();	mIsOTClosed = true;		if (gAppObject->GetState() != programState_Quitting) {		// setup to reload interfaces after a short delay		mTickStamp = ::TickCount();		mRetryCount = 5;		StartIdling();		gLogAction->LogText("\p\rCInterfacesAction: Waiting to restore interfaces");	}}// ---------------------------------------------------------------------------//		¥ SpendTime// ---------------------------------------------------------------------------//	Periodical function to delay before reloading interfacesvoidCInterfacesAction::SpendTime(const EventRecord &inMacEvent){#pragma unused (inMacEvent)	OTResult			result;	UInt32				tickStamp, tickDelta;	UInt8				forwarding;	OSStatus			err = noErr;		tickStamp = ::TickCount();	if (tickStamp >= mTickStamp) {		tickDelta = tickStamp - mTickStamp;	} else {		mTickStamp = ::TickCount();	}	if (tickDelta > 160) {	// about 2 seconds		do {			if (mIsOTClosed) {				// re-initialize OT				::InitOpenTransport();				mIsOTClosed = false;			}//            if (!CheckIPReady()) break; // don't force a connection			StopIdling();			gLogAction->LogText("\p\rCInterfacesAction: Restore interfaces.");			//	Create a tcp endpoint to force the InetConfigurator to fire			//	(blocks until TCP/IP is ready)			err = gProxyControl->AsyncOpenAndClose();			if ((err != noErr) && (err != kOTDuplicateFoundErr)) {				gLogAction->LogText("\p\rCInterfacesAction::SpendTime unexpected result from OT: ", err);				if (mRetryCount > 0) {					// try again in a little while					mRetryCount -= 1;					mTickStamp = ::TickCount();					//::CloseOpenTransport();					//mIsOTClosed = true;					StartIdling();				}				break;						}			// TCP/IP is ready, update interfaces			mProviderWillClose = false;			UpdateInterfacesData();			mProviderWasClosed = true;	// set flag to indicate we're restoring                        // re-open connection to our Proxy module			gProxyControl->ProxyConnect();    		// Filters    		// Load filters before interfaces for security    		ArrayIndexT     numConfigE, index;    		FilterEntry_t   filterEntry;			numConfigE = gFilterData->mFilterData->GetDataCount();			// For each filter			for (index=numConfigE; index>=1; index--) {				// get filter entry from config being loaded				if ( !gFilterData->mFilterData->GetDataFilterArray(index, &filterEntry) ) continue;				filterEntry.entryID = 0;    // add as new entry				result = gFilterAction->DoFilterEntry(&filterEntry, false);				if (result != kOTNoError) {					gLogAction->LogText("\p\r Restore filters OT result: ", result);				}							}			delete gFilterData->mFilterData;			gFilterData->mFilterData = nil;			// restore PPP monitoring (might need this to restore interfaces)			if (mIsMonitoringPPP) gResInfo->MonitorPPP(nil);			// restore IP forwarding			forwarding = gGatewayData->GetDataIPforwarding();			result = SetForwarding(forwarding);			    // other gateway settings remain in effect			// restore interfaces			if (mInterfacesData != nil) {				SInt32				numConfigE, numTableE, match;				ArrayIndexT 		index;				InterfaceEntry_t	interfaceEntry, tableEntry;				// check for new interface name that isn't in previous config				numTableE = gInterfacesData->GetDataCount();				for (index=1; index<=numTableE; index++) {					// get existing interface					if ( !gInterfacesData->GetDataInterfacesArray(index, &tableEntry) ) continue;					// look for name in previous config					match = gInterfacesData->MatchInterfaceInConfig(&tableEntry, mInterfacesData, &interfaceEntry);					if (match == kEntryNoMatch) break;				}				if (match == kEntryNoMatch) {					gLogAction->LogText("\p\r Unknown new interface detected, restore aborted.");					if (gApplicationMode == kModeApple) {						// quit since there is nothing to do						gAppObject->DoQuit(false);						break;					}				}				else {					// setup access to interface data					numConfigE = mInterfacesData->GetDataCount();					// For each interface					for (index=1; index<=numConfigE; index++) {						// get interface entry from config being loaded						if ( !mInterfacesData->GetDataInterfacesArray(index, &interfaceEntry) ) continue;						interfaceEntry.bringUp = true;						result = DoInterfaceEntry(&interfaceEntry, false);						if (result != kOTNoError) {							gLogAction->LogText("\p\r Restore interfaces OT result: ", result);						}									}				}				delete mInterfacesData;				mInterfacesData = nil;			}			UpdateInterfacesData();			// routes will automatically restore for defined interfaces			// still need to restore any additional routes    		gRoutesAction->UpdateRoutesData();    		result = gRoutesAction->LoadRtConfig(gRoutesData->mRoutesData);    		if (result == kOTNoError) {    			delete gRoutesData->mRoutesData;    			gRoutesData->mRoutesData = nil;    		}			// PortMap data is restored when masquerading is enabled						// restore DHCP Server if enabled			if (mIsDHCPServerOn) gDHCPAction->StartServing();			// restore Dialup DNS client if eanbled			gGatewayAction->DialupDNSClientStart();			mProviderWasClosed = false;		} while (false);	}}// ---------------------------------------------------------------------------------//		¥ FindSecondaryNATInterface// ---------------------------------------------------------------------------------// Find secondary NAT interface for use with TR Cable Modems// We assume this will be the first Ethernet interface currently configuredUInt32CInterfacesAction::FindSecondaryNATInterface(){	ArrayIndexT			numTableE, row;	InterfaceEntry_t	ifTableEntry;	DeviceEntry_t		deviceEntry;	UInt32				result = 0;			// scan list of interfaces	numTableE = gInterfacesData->GetDataCount();	for (row=1; row<=numTableE; row++) {		if ( !gInterfacesData->GetDataInterfacesArray(row, &ifTableEntry) ) continue;		if (::EqualString("\plo0", ifTableEntry.interfaceName, false, false)) continue;		// get interface info 		if (gDeviceData->FindDataDeviceArray(nil, ifTableEntry.portName, nil, &deviceEntry)) {			// if its an Ethernet devices, return index;			if ((deviceEntry.deviceType  == kOTEthernetDevice) ||				(deviceEntry.deviceType  == kOTFastEthernetDevice)) {				result = row;				break;			}		}	}	return result;}// ---------------------------------------------------------------------------------//		¥ FindPrivateInterface// ---------------------------------------------------------------------------------// Find private interface to enable directed broadcast// We assume this will be the first interface besides lo0 that isn't masqueradedUInt32CInterfacesAction::FindPrivateInterface(){	ArrayIndexT			numTableE, row;	InterfaceEntry_t	ifTableEntry;	UInt32				result = 0;			// scan list of interfaces	numTableE = gInterfacesData->GetDataCount();	for (row=1; row<=numTableE; row++) {		if ( !gInterfacesData->GetDataInterfacesArray(row, &ifTableEntry) ) continue;		// ignore the loopback interface		if (::EqualString("\plo0", ifTableEntry.interfaceName, false, false)) continue;		// if its not masqueraded, return index;		if (ifTableEntry.bringUp && !ifTableEntry.masquerading) {			result = row;			break;		}	}	return result;}// ---------------------------------------------------------------------------//		¥ GetDNSAddress// ---------------------------------------------------------------------------//	Get DNS address for the selected interface (currently interface 0)StringPtrCInterfacesAction::GetDNSAddress(Str255 outAddressString){		ResultT result;		// try to use address we got from PPP if any	if (gResInfo->mPPPDNSAddress) {		IP_NumToStr(gResInfo->mPPPDNSAddress, outAddressString);	}	else {		// use address TCP/IP already has if any		InetInterfaceInfo	info;		result = ::OTInetGetInterfaceInfo(&info, 0);		if ((result == kOTNoError) && (info.fDNSAddr)) {			IP_NumToStr(info.fDNSAddr, outAddressString);		}		else outAddressString[0] = 0;	}	return outAddressString;}// ---------------------------------------------------------------------------------//		¥ EnableMasquerading// ---------------------------------------------------------------------------------//	Configure and begin IP MasqueradingOTResultCInterfacesAction::EnableMasquerading(InterfaceEntry_t* inInterfaceEntry){	NetNumber_t			excludeNetwork;	OTResult			result;	Str31				str;    ArrayIndexT	        row, numRows;    InterfaceEntry_t    tableInterfaceEntry;    UInt32		        theHash;	do {		// ignore if no address		if (inInterfaceEntry == nil) break;		if (inInterfaceEntry->interfaceAddr == 0) break;				// make sure table information is current		UpdateInterfacesData();				// stop any previous masquerading		if (mNatTask) mNatTask->PauseNat(inInterfaceEntry);				// create a NAT task object if we don't already have one		if (mNatTask == nil) {			mNatTask = new CNatTask();			ThrowIfNil_(mNatTask);		}		// set exclude network in module (a network that should not be translated)    	theHash = HashName(inInterfaceEntry->portName);		excludeNetwork.address = 0;		excludeNetwork.mask = 0;		// get user preference if any	        if (gGatewayData->GetDataExcludeFromNAT()) {            gGatewayData->GetDataExcludeNet(&excludeNetwork);        }        else {        	// check for more than one interface on this port        		// if yes, make other interface a private network        		// then turn on masquerading        	// scan interface table        	numRows = gInterfacesData->GetDataCount();        	for (row=1; row<=numRows; row++) {        		gInterfacesData->GetDataInterfacesArray(row, &tableInterfaceEntry);        		// check if same port        		if (theHash == HashName(tableInterfaceEntry.portName)) {        			// and not same interface?        			if ( !::EqualString(inInterfaceEntry->interfaceName, tableInterfaceEntry.interfaceName, false, false) ) {        				// and network does not overlap        				if ((tableInterfaceEntry.interfaceAddr & tableInterfaceEntry.netMask) !=        					(inInterfaceEntry->interfaceAddr & tableInterfaceEntry.netMask)) {        					// tell module to not translate packets        					// received from or sent to this network        					excludeNetwork.address	= tableInterfaceEntry.interfaceAddr;        					excludeNetwork.mask		= tableInterfaceEntry.netMask;        				}        				break;        			}        		}        	}        }		gInterfacesData->SetDataNATexcludeNetwork(&excludeNetwork);		// turn on masquerading		mNatTask->StartNat(inInterfaceEntry);				// update InterfacesData list of NAT port names from NAT module		mNatTask->UpdateNatPortNames();		// set current NAT table for Port Mapping window		gPortMapData->SetDataPortMapHash(theHash);		// set current NAT address		gPortMapData->SetDataNATaddress(inInterfaceEntry->interfaceAddr);		// enable forwarding if not already		UInt8		forwarding;		forwarding = gGatewayData->GetDataIPforwarding();		if (forwarding == kForwardingNever) {			SetForwarding(kForwardingAutomatic);		}				// load any static mapping		// check if restoring previously saved settings		if (gPortMapData->mPortMapData != nil) {			// if addOnly, do any previous settings first			if (gGatewayData->GetDataAddOnly()) {				result = gPortMapAction->LoadPortMapConfig(gPortMapData);			}			result = gPortMapAction->LoadPortMapConfig(gPortMapData->mPortMapData);			if (result == kOTNoError) {				delete gPortMapData->mPortMapData;				gPortMapData->mPortMapData = nil;			}			if (result != kOTNoError) {				gLogAction->LogText("\p\rCInterfacesAction - Error restoring PortMap settings: ", result);			}		}		else {			// otherwise restore existing settings			result = gPortMapAction->LoadPortMapConfig(gPortMapData);		}		// Add a permanent NAT entry to map directed broadcasts (do this after restore)			// get option setting		Boolean	mapBroadcast = true;		::GetIndString(str, rSTRN_OptionSettings, kOptionMapBroadcast);		if ( BeginsWith(str, "\pMapBroadcast") && GetKeywordValue(str, str) ) {			long value;			::StringToNum(str, &value);			mapBroadcast = value;		}		row = FindPrivateInterface();		if (gInterfacesData->GetDataInterfacesArray(row, &tableInterfaceEntry) && mapBroadcast) {			PortMapEntry_t	portMapEntry;			UInt32			addr, mask;			bzero((UInt8*)&portMapEntry, sizeof(PortMapEntry_t));			// map apparent broadcast address			addr = gPortMapData->GetDataNATaddress();			mask = inInterfaceEntry->netMask;			if (mask == 0) {				// determine classic network mask				if ( (addr & 0x80000000) == 0 )					mask = 0xff000000;				else if ( (addr & 0xC0000000) == 0x80000000 )					mask = 0xffff0000;				else if ( (addr & 0xE0000000) == 0xC0000000 )					mask = 0xffffff00;			}			mask = ~mask;			portMapEntry.apparent.address = addr | mask;			// to actual broadcast address			addr = tableInterfaceEntry.interfaceAddr;			mask = tableInterfaceEntry.netMask;			mask = ~mask;			portMapEntry.actual.address = addr | mask;			// set protocol and flags			portMapEntry.protocol = kProtocolUDP;			portMapEntry.flags |= kFlagActive + kFlagPermanent + kFlagNoRestore;			gPortMapAction->Init();			result = gPortMapAction->DoPortMapEntry(&portMapEntry, true);		}				// restore exposed host address if any		UInt32 dataID;		dataID = DATA_ID(kGatewayData, kDataExposedHost);		gGatewayAction->ListenToMessage(msg_SignalDataEvent, &dataID);		// register service with NSL		IP_NumToStr(inInterfaceEntry->interfaceAddr, str);		gResInfo->RegisterWithNSL(str);	} while (false);	return result;}// ---------------------------------------------------------------------------------//		¥ DisableMasquerading// ---------------------------------------------------------------------------------//	Disable masquerading on this interfaceOTResultCInterfacesAction::DisableMasquerading(InterfaceEntry_t* inInterfaceEntry){		OTResult 		result = kOTNoError;	proxy_names_t	proxyNames;	UInt32			theHash = 0;	short			i;	Boolean			inList;		// check if masquerading on this port	gInterfacesData->GetDataProxyNames(&proxyNames);	theHash = HashName(inInterfaceEntry->portName);	inList = false;	if (theHash != 0) {		for (i=0; i<=kNatNumDim; i++) {			if (theHash == proxyNames.NatPortName[i]) {				inList = true;				break;			}			}	}		//if ((inList) && (inInterfaceEntry->bringUp)) {			if (inList) {				// make sure table information is current		UpdateInterfacesData();		// check for more than one interface on this port			// if no, turn off masquerading on this port			// if yes, update private network or turn off masquerading		// scan interface table		ArrayIndexT	row, numRows, count;		InterfaceEntry_t tableInterfaceEntry;		numRows = gInterfacesData->GetDataCount();		count = 0;		for (row=1; row<=numRows; row++) {			gInterfacesData->GetDataInterfacesArray(row, &tableInterfaceEntry);			// check if same port			if (theHash == HashName(tableInterfaceEntry.portName)) count += 1;		}		if (count > 1) {			// We might be masquerading behind another interface on this port.			// Check if our address matches the masquerading address			if (inInterfaceEntry->interfaceAddr == gPortMapData->GetDataNATaddress()) {				// Yes, disable masquerading on this port.				count = 1;	// steal code from below				// fall through			}			else {				// if not user specified				if (!gGatewayData->GetDataExcludeFromNAT()) {    				// No, it doesn't match.  Masquerading on port but not interface.    				// if network doesn't overlap    				if ((inInterfaceEntry->interfaceAddr  & inInterfaceEntry->netMask) !=    					(gPortMapData->GetDataNATaddress() & inInterfaceEntry->netMask)) {        				// Update the actual network address        				NetNumber_t			excludeNetwork;        				excludeNetwork.address = inInterfaceEntry->interfaceAddr;        				excludeNetwork.mask = inInterfaceEntry->netMask;        				gInterfacesData->SetDataNATexcludeNetwork(&excludeNetwork);        				mNatTask->SetExcludeNetwork(inInterfaceEntry->portName, &excludeNetwork);        				// tell user        				Str31 str;        				gLogAction->LogText("\p\rMasquerading Set Actual Network: ");        				IP_NumToStr(excludeNetwork.address, str);        				gLogAction->LogText(str);    				}    			}			}		}		if (count <= 1) {			// pause NAT on this port			if (mNatTask) {				gResInfo->DeregisterWithNSL();				mNatTask->PauseNat(inInterfaceEntry);				// update list of NAT port names				mNatTask->UpdateNatPortNames();				gInterfacesData->GetDataProxyNames(&proxyNames);				// we just turned off NAT on one interface				// find new current interface or set to zero				inList = false;				for (i=kNatNumDim-1; i>=0; i--) {					if (proxyNames.NatPortName[i] != 0) {						InterfaceEntry_t	interfaceEntry;						// set current NAT table for Port Mapping window						gPortMapData->SetDataPortMapHash(proxyNames.NatPortName[i]);									// set current NAT address						if (gPortMapData->FindCurrentNATinterface(&interfaceEntry)) {							gPortMapData->SetDataNATaddress(interfaceEntry.interfaceAddr);						}						// update data object for current table						gPortMapAction->UpdatePortMapData();						inList = true;						break;					}				}				if (!inList) {		// no masquerading on any port					// set current NAT table for Port Mapping window					gPortMapData->SetDataPortMapHash(0);					// set current NAT address					gPortMapData->SetDataNATaddress(0);					// release NAT task					delete mNatTask;					mNatTask = nil;					gLogAction->LogText("\p\rMasquerading stopped.");				}			}		}	}	return result;}#pragma mark --- ioctl ---// ---------------------------------------------------------------------------------//		¥ DoIoctl// ---------------------------------------------------------------------------------//	Send synchronous ioctl to IP moduleOTResultCInterfacesAction::DoIoctl(UInt32 inCmd, void* inData){	OTResult	result;		result = kOTNoError;		do {		if (!mEndpoint) {			// create an endpoint to listen for provider events			mEndpoint = new CTurboUDPEndpoint(kRawIPName);			// Register to receive other event notifications			if (mEndpoint) mEndpoint->AddListener(this);				}		// Make sure we have a stream to IP module.		if (!mIpStream) {			UOpenTptSupport::StartOpenTransport();			mIpStream = ::OTStreamOpen(MI_IP_NAME, 0, &result);			if (result != kOTNoError) {				break;			}						// Switch the stream in sync/blocking mode.  To make the			// code easier, we're going to do this synchronously.			(void) ::OTStreamSetBlocking(mIpStream);			(void) ::OTStreamSetSynchronous(mIpStream);		}		// issue requested ioctl		result = ::OTStreamIoctl(mIpStream, inCmd, inData);	} while (false);	return result;}// ---------------------------------------------------------------------------------//		¥ GetOTParameter// ---------------------------------------------------------------------------------//	Using Mentat Named DispatchOTResultCInterfacesAction::GetOTParameter(ConstStr255Param inName, Str255 outValue){	UInt8		nameLen;	OTResult	result = kOTNoError;	// get parameter lengths and check them	nameLen = inName[0];	if (nameLen >= kMaxNDDStringSize) {		::SysBeep(30);		return kOTBadOptionErr;	}	// copy name to buffer	LString::CopyPStr(inName, mNDDString);	// set to be null terminated	mNDDString[nameLen+1] = 0;	// setup I_STR ioctl structure	SetupIoctl(&mStri, ND_GET, (char*)&mNDDString[1], kMaxNDDStringSize);		result = DoIoctl(I_STR, &mStri);	// do ioctl	if (result >= 0) {		// get returned value		if ((0 < mStri.ic_len) && (mStri.ic_len < 255)) {			mNDDString[0] = mStri.ic_len;			LString::CopyPStr(mNDDString, outValue);		}	} else {		gLogAction->LogText("\p\rCInterfacesAction - GetOTParameter OT result: ", result);		}	return result;}// ---------------------------------------------------------------------------------//		¥ SetOTParameter// ---------------------------------------------------------------------------------OTResultCInterfacesAction::SetOTParameter(ConstStr255Param inName, ConstStr255Param inValue){	UInt8		nameLen, valueLen;	OTResult	result = kOTNoError;	// get parameter lengths and check them	nameLen = inName[0];	valueLen = inValue[0];	if ((nameLen+valueLen) >= kMaxNDDStringSize) {		::SysBeep(30);		return kOTBadOptionErr;	}	// copy name to buffer	LString::CopyPStr(inName, mNDDString);	// copy value to buffer immediately after name	LString::CopyPStr(inValue, &mNDDString[nameLen+1]);	// set them both to be null terminated	mNDDString[nameLen+1] = 0;	mNDDString[nameLen+1+valueLen+1] = 0;		// setup I_STR ioctl structure	SetupIoctl(&mStri, ND_SET, (char*)&mNDDString[1], kMaxNDDStringSize);		result = DoIoctl(I_STR, &mStri);	// do ioctl	LStr255	str;	str = "\p\rSetOTParameter: ";	str += inName;	str += "\p=";	str += inValue;	gLogAction->LogText(str);	if (result < 0) {		gLogAction->LogText("\p\rCInterfacesAction - SetOTParameter OT result: ", result);	}	return result;}// ---------------------------------------------------------------------------------//		¥ SetForwarding// ---------------------------------------------------------------------------------// Set forwarding in IP module and update GatewayDataOTResultCInterfacesAction::SetForwarding(UInt8 inForwarding){	OTResult	result;	switch (inForwarding) {		case kForwardingNever:			result = SetOTParameter(kForwardingName, "\p0");			gGatewayData->SetDataIPforwarding(inForwarding);			break;		case kForwardingAlways:			result = SetOTParameter(kForwardingName, "\p1");			gGatewayData->SetDataIPforwarding(inForwarding);			break;		case kForwardingAutomatic:			result = SetOTParameter(kForwardingName, "\p2");			gGatewayData->SetDataIPforwarding(inForwarding);			break;		default:			result = kEINVALErr;			break;	}	if (result != kOTNoError) {		gLogAction->LogText("\p\rSetForwarding unexpected result: ", result);	}	return result;}