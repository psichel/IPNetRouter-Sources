// ===========================================================================//	CNatTask.cp			©1997 Sustainable Softworks. All rights reserved.// ===========================================================================//	Network Address Translation Task for streams module#include "CompileFlags.h"#include "CNatTask.h"#include "CLogAction.h"#include "IPSupport.h"#include "MacSupport.h"#include "Autopush.h"#include "CResidentIfInfo.h"#include "CProxyControl.h"#include "CInterfacesData.h"#include "CPortMapData.h"#include "CGatewayData.h"#include <LPreferencesFile.h>#include <UResourceMgr.h>#include <UModalDialogs.h>#include <LCaption.h>#include <OpenTransport.h>#include <OpenTptClient.h>#include <OpenTptInternet.h>#include <OpenTptDevLinks.h>#include <stropts.h>// open stream flags (read/write)#define O_RDWR				0x02// Globalsextern CLogAction*		gLogAction;extern CResidentIfInfo*	gResInfo;extern CInterfacesData* gInterfacesData;extern CPortMapData*	gPortMapData;extern CProxyControl*	gProxyControl;extern CGatewayData*	gGatewayData;// ---------------------------------------------------------------------------//		¥ CNatTask// ---------------------------------------------------------------------------CNatTask::CNatTask(){	UInt8 i;		for (i=0; i<kNatNumDim; i++) {		mNatTableCount[i] = 0;	}}// ---------------------------------------------------------------------------//		¥ ~CNatTask// ---------------------------------------------------------------------------CNatTask::~CNatTask(){	OTResult		result = kProxyNoError;		// normal stop (on all interfaces)	PauseNat(nil);	LThread::Yield();}// ---------------------------------------------------------------------------------//		¥ StartNat// ---------------------------------------------------------------------------------//	Start NatvoidCNatTask::StartNat(InterfaceEntry_t* inInterfaceEntry){		OTResult		result = kProxyNoError;	struct strioctl	streamCommand;	LStr255			text;	Str31			str;	UInt32			portNameHash = 0;	// Set up connection to Proxy module	gProxyControl->ProxyConnect();		do {		gLogAction->LogText("\p\rSetup IP Masquerading");		// We set the NAT portName first to designate an available NAT table		// -----------------------------------------		// Send IOCTL to set proxy port name		if (inInterfaceEntry == nil) {			result = kENXIOErr;			break;		}		portNameHash = HashName(inInterfaceEntry->portName);		SetupIoctl(&streamCommand, I_SetPortName,			(char*)&portNameHash, sizeof(proxy_name_t));		result = gProxyControl->ProxyIoctl(I_STR, &streamCommand);		if (result != kProxyNoError) {			gLogAction->LogText("\p\rCNatTask - All NAT tables in use");			break;		}		else {			text = "\p\r    Proxy interface: ";			text += inInterfaceEntry->portName;			gLogAction->LogText(text);		}		// Send IOCTL to set proxy address		proxy_network_t	natNetwork;		natNetwork.portNameHash = portNameHash;		natNetwork.net.address = inInterfaceEntry->interfaceAddr;		natNetwork.net.mask = inInterfaceEntry->netMask;		SetupIoctl(&streamCommand, I_SetApparentAddress,			(char*)&natNetwork, sizeof(proxy_network_t));		result = gProxyControl->ProxyIoctl(I_STR, &streamCommand);		if (result != kProxyNoError) {			gLogAction->LogText("\p\rCNatTask - Set Proxy Address table error");			break;		}		text = "\p\r    Proxy address: ";		IP_NumToStr(inInterfaceEntry->interfaceAddr, str);		text += str;		gLogAction->LogText(text);		// Send IOCTL to set actual network		NetNumber_t	excludeNetwork;		gInterfacesData->GetDataNATexcludeNetwork(&excludeNetwork);		result = SetExcludeNetwork(inInterfaceEntry->portName, &excludeNetwork);		if (result != kProxyNoError) {			break;		}		// Send IOCTL to set MSS Clamp		proxy_mss_t			proxyMSS;		proxyMSS.portNameHash = portNameHash;		proxyMSS.mssClamp = inInterfaceEntry->mtu - 50;		// We use MSS = MTU - 50		if (!gGatewayData->GetDataLimitMTUForPPPoE()) proxyMSS.mssClamp = 0;		SetupIoctl(&streamCommand, I_ClampMSS,			(char*)&proxyMSS, sizeof(proxy_mss_t));		result = gProxyControl->ProxyIoctl(I_STR, &streamCommand);		if (result != kProxyNoError) {			gLogAction->LogText("\p\rCNatTask - Set MSS Clamp error");			break;		}		else {			gLogAction->LogText("\p\r    MSS Clamp: ");			if (proxyMSS.mssClamp) {				::NumToString(proxyMSS.mssClamp, str);				gLogAction->LogText(str);			} else gLogAction->LogText("\poff");		}		// Send IOCTL to turn on NAT		SetupIoctl(&streamCommand, I_NatOn,			(char*)&portNameHash, sizeof(proxy_name_t));		result = gProxyControl->ProxyIoctl(I_STR, &streamCommand);		if (result != kProxyNoError) {			gLogAction->LogText("\p\rCNatTask - Turn NAT on table error");			break;		}		// enable NAT on local interface		if (gGatewayData->GetDataEnableLocalNAT()) {			result = gProxyControl->ProxyIoctl(I_LocalNatOn, nil);			if (result == kOTNoError)				gLogAction->LogText("\p\r    NAT on local interface enabled");		} else {			result = gProxyControl->ProxyIoctl(I_LocalNatOff, nil);			if (result == kOTNoError)				gLogAction->LogText("\p\r    NAT on local interface disabled");		}		// enable TRCableModem if selected		if (gGatewayData->GetDataTRCableModem()) {			result = gProxyControl->ProxyIoctl(I_TRCableModem, nil);			if (result == kOTNoError)				gLogAction->LogText("\p\r    TR Cable Modem enabled");		} else {			result = gProxyControl->ProxyIoctl(I_TRCableModemOff, nil);			if (result == kOTNoError)				gLogAction->LogText("\p\r    TR Cable Modem disabled");		}				// initialize last age time so we can check later		// if we need to age the NAT table		::OTGetTimeStamp(&mLastStamp);		// Start idling		this->StartIdling();				gLogAction->LogText("\p\rMasquerading started.");	} while (false);	if (result != kProxyNoError) {		gLogAction->LogText("\p\rCNatTask: Unable to configure IP Masquerading.");	}}// ---------------------------------------------------------------------------------//		¥ Pause NAT// ---------------------------------------------------------------------------------//	Pause NATvoidCNatTask::PauseNat(InterfaceEntry_t* inInterfaceEntry){	UInt32			portNameHash = 0;	struct strioctl	streamCommand;	OTResult		result;	proxy_names_t	proxyNames;	UInt8			i;	// get hashed portName if any	if (inInterfaceEntry) {		portNameHash = HashName(inInterfaceEntry->portName);	}	else {		// if no interface is specified, stop on all interfaces		StopIdling();	}		gInterfacesData->GetDataProxyNames(&proxyNames);	for (i=0; i<kNatNumDim; i++) {		if (((portNameHash != 0) && (portNameHash == proxyNames.NatPortName[i])) ||			(portNameHash == 0)) {			// pause NAT on this interface			SetupIoctl(&streamCommand, I_NatOff,				(char*)&proxyNames.NatPortName[i], sizeof(proxy_name_t));			result = gProxyControl->ProxyIoctl(I_STR, &streamCommand);			if (result != kProxyNoError) {				gLogAction->LogText("\p\rCNatTask - Turn NAT off table error");			} else {				if (inInterfaceEntry) {					LStr255 text;					text = "\p\rCNatTask - stopped masquerading on: ";					text += inInterfaceEntry->interfaceName;					gLogAction->LogText(text);				}			}		}	}}// ---------------------------------------------------------------------------------//		¥ SetExcludeNetwork()// ---------------------------------------------------------------------------------OTResultCNatTask::SetExcludeNetwork(Str32 inPortName, NetNumber_t* inNetwork){		OTResult		result = kProxyNoError;	struct strioctl	streamCommand;	LStr255			text;	Str31			str;	UInt32			portNameHash = 0;	portNameHash = HashName(inPortName);    // send IOCTL to set ExcludeFromNAT    if (gGatewayData->GetDataExcludeFromNAT())	    gProxyControl->ProxyIoctl(I_ExcludeFromNATOn, nil);	else	    gProxyControl->ProxyIoctl(I_ExcludeFromNATOff, nil);	// Send IOCTL to set exclude network	proxy_network_t proxyNetwork;	proxyNetwork.portNameHash = portNameHash;	proxyNetwork.net = *inNetwork;	SetupIoctl(&streamCommand, I_SetExcludeNetwork,		(char*)&proxyNetwork, sizeof(proxy_network_t));	result = gProxyControl->ProxyIoctl(I_STR, &streamCommand);	if (result != kProxyNoError) {		gLogAction->LogText("\p\rCNatTask - Set Actual Network table error");	} else {		text = "\p\r    Actual network: ";		if (gGatewayData->GetDataExcludeFromNAT()) text = "\p\r    Exclude network: ";		if (proxyNetwork.net.address == 0) text += "\pnone";		else {			text += "\pIP=";			IP_NumToStr(proxyNetwork.net.address, str);			text += str;			text += "\p Mask=";			IP_NumToStr(proxyNetwork.net.mask, str);			text += str;		}		gLogAction->LogText(text);	}	return result;}// ---------------------------------------------------------------------------//		¥ SpendTime// ---------------------------------------------------------------------------//	Periodical function to test if stat message times outvoidCNatTask::SpendTime(const EventRecord &inMacEvent){#pragma unused (inMacEvent)	struct strioctl		stri;	proxy_age_t			proxyAge;	OTResult			result;	proxy_names_t		proxyNames;	UInt8				i;	UInt32 				deltaTime;	gInterfacesData->GetDataProxyNames(&proxyNames);	// if more than 30 second since we last aged the NAT table	deltaTime = OTElapsedMilliseconds(&mLastStamp);	if (deltaTime > 30000) {		::OTGetTimeStamp(&mLastStamp);		// age each active NAT table		for (i=0; i<kNatNumDim; i++) {			// as table fills, try to age out more aggresively			proxyAge.age = 2880;	// 24 hours						if (mNatTableCount[i] > 128) proxyAge.age = 1440;	// 12 hours			if (mNatTableCount[i] > 256) proxyAge.age = 480;	//  4 hours			if (mNatTableCount[i] > 384) proxyAge.age = 240;	//  2 hours			if (mNatTableCount[i] > 500) proxyAge.age = 60;		// 30 minutes			proxyAge.portNameHash = proxyNames.NatPortName[i];			if (proxyAge.portNameHash) {				SetupIoctl(&stri, I_AgeNatTable, (char*)&proxyAge, sizeof(proxy_age_t));				result = gProxyControl->ProxyIoctl(I_STR, &stri);				if (result == kProxyNoError) {					// proxyAge.age is number of entries in table					mNatTableCount[i] = proxyAge.age;				} else {					gLogAction->LogText("\p\rCNatTask - Age NAT table error ", result);				}			}		}			}}// ---------------------------------------------------------------------------------//		¥ UpdateNatPortNames// ---------------------------------------------------------------------------------//	UpdateNatPortNamesOTResultCNatTask::UpdateNatPortNames(){		OTResult		result = kProxyNoError;	struct strioctl	streamCommand;	proxy_names_t	proxyNames;	// Set up connection to Proxy module	gProxyControl->ProxyConnect();	SetupIoctl(&streamCommand, I_GetPortNames,		(char*)&proxyNames, sizeof(proxy_names_t));	result = gProxyControl->ProxyIoctl(I_STR, &streamCommand);	if (result == kProxyNoError) {		gInterfacesData->SetDataProxyNames(&proxyNames);	}	else {		gLogAction->LogText("\p\rCNatTask - Unable to Get NAT port names ", result);	}	return result;}