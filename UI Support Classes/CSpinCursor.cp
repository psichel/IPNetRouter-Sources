// =================================================================================//	CSpinCursor.cp	 		©1996 Sustainable Softworks. All rights reserved.// =================================================================================//	Display spinning cursor to indicate waiting for network operation#pragma once#include "CSpinCursor.h"#include "MacSupport.h"UInt16	CSpinCursor::sRefCount = 0;// ---------------------------------------------------------------------------//		¥ CSpinCursor// ---------------------------------------------------------------------------//	ConstructorCSpinCursor::CSpinCursor(LWindow* inWindow)	: LAttachment(msg_AdjustCursor, false){	// initialize animated cursor structures	acurs = nil;		/* used in SpinBWCursor */	InitCursors();	mPrevTick = 0;	mWindow = inWindow;	// remember the parent window	}// ---------------------------------------------------------------------------//		¥ ~CSpinCursor// ---------------------------------------------------------------------------//	DestructorCSpinCursor::~CSpinCursor(){	short		numFrames, i;	CursHandle	cursH;	if (acurs != nil) {		// Don't release cursors if another window is still be using them		if (sRefCount <= 1) {			sRefCount = 0;			// release each cursor resource			numFrames = (**acurs).cnt;			for(i = 0; i < numFrames; i++) {				cursH = (**acurs).curs[i].h;				if (cursH) ::ReleaseResource((Handle)cursH);			}		} else sRefCount -= 1;		::DisposeHandle((Handle)acurs);	}}// ---------------------------------------------------------------------------//		¥ ExecuteSelf// ---------------------------------------------------------------------------//	Attachment function//		Empty since we just want to prevent the normal AdjustCursorSelf.//		Constructor : LAttachment(msg_AdjustCursor, false)voidCSpinCursor::ExecuteSelf(const EventRecord &inMacEvent){}// ---------------------------------------------------------------------------//		¥ SpendTime// ---------------------------------------------------------------------------//	periodical to test if ready to advance to next cursorvoidCSpinCursor::SpendTime(const EventRecord &inMacEvent){	if ((::TickCount() - mPrevTick) > 30) {		// spin every .5 second									// Find out where the mouse is		Rect	windowRect;		Point	thePoint = inMacEvent.where;		mWindow->GlobalToPortPoint(thePoint);		mWindow->CalcPortFrameRect(windowRect);		windowRect.top -= 18;	// include title bar		// spin cursor if mouse is in window		if ( ::PtInRect(thePoint, &windowRect) ) {			SpinCursor(1);		}		mPrevTick = ::TickCount();	}}// ---------------------------------------------------------------------------//		¥ InitCursors// ---------------------------------------------------------------------------//	Generic entry that handles color or B&WvoidCSpinCursor::InitCursors(){	InitBWCursors();}// ---------------------------------------------------------------------------//		¥ InitBWCursors// ---------------------------------------------------------------------------//	Initialize our black and white animated cursor structurevoidCSpinCursor::InitBWCursors(){	Handle resH;	CursHandle cursH;	short numFrames, i, id;	OSErr err = noErr;			// get animated cursor resource	err = ECGetResource('acur', 128, &resH);	if (err != noErr) return;	acurs = (CursorHList) resH;	// make a copy we'll modify	err = ::HandToHand(&(Handle)acurs);	::ReleaseResource(resH);	if (err != noErr) {		acurs = nil;		return;	}	sRefCount += 1;	// replace each cursor id with its handle	numFrames = (**acurs).cnt;	for(i = 0; i < numFrames; i++)	{		id = (**acurs).curs[i].i.i;		cursH = ::GetCursor(id);		(**acurs).curs[i].h = cursH;	}}// ---------------------------------------------------------------------------//		¥ SpinCursor// ---------------------------------------------------------------------------//	Generic entry that handles color or B&W.//		Transit the cursor to the next in the series.//		delta should be 1 to go forward, -1 to go backward.voidCSpinCursor::SpinCursor(short inDelta){		SpinBWCursor(inDelta);}// ---------------------------------------------------------------------------//		¥ SpinBWCursor// ---------------------------------------------------------------------------voidCSpinCursor::SpinBWCursor(short inDelta){	short c;	CursHandle cursH;		if(acurs != nil) {		// find the cursor at offset delta from current        c = (**acurs).current + inDelta;        // wrap if necessary        if (c >= (**acurs).cnt) c = 0;        else if (c < 0) c = (**acurs).cnt-1;        // update current        (**acurs).current = c;        // get handle and set cursor if handle isn't null        cursH = (**acurs).curs[c].h;        if (cursH != nil) SetCursor(*cursH);	}}