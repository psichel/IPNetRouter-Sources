// =================================================================================//	CConfigureTable.cp			©1996-1999 Sustainable Softworks All rights reserved.// =================================================================================//	Configurable table object to display common TCP/IP information#include "CConfigureTable.h"#include "CConfigureConst.h"#include "CSubnetCalcWindow.h"#include <OpenTransport.h>#include "Cwindow.h"#include <PP_Messages.h>#include "AGAColors.h"#include "CIPRouterApp.h"#include "IPRouterCommon.h"#include "IPSupport.h"#include "MacSupport.h"#include <LString.h>#include <Icons.h>#include "ICAPI.h"// Globalsextern CIPRouterApp* gAppObject;extern ICInstance gICInstance;// ---------------------------------------------------------------------------------//		¥ CConfigureTable(LStream*)// ---------------------------------------------------------------------------------CConfigureTable::CConfigureTable(	LStream	*inStream )		: CDisplayTable( inStream ){		// initialize adjustable widths to the default fixed width	for (TableIndexT col=1; col<=kMaxDCols; col++) {		mMultiColWidth[col] = mColWidth;		mColType[col] = kColTypeNone;	// type to unknown	}		mCommentData = nil;	// Initialize for no comment data	mHiliteStyle = kHiliteNone;	mSelectionStart = 0;	mSelectionEnd = 0;	mNumComments = 1;	mWindow = nil;	mFormatH = nil;	// initialize table data	TableCellT		tCell;	TableItemW	tData;	tData.hi = 0;	tData.lo = 0;	for (tCell.row=1; tCell.row<=mRows; tCell.row++) {		for (tCell.col=1; tCell.col<=mCols; tCell.col++) {						SetCellData( tCell, &tData );		}	}}// ---------------------------------------------------------------------------------//		¥ ~CConfigureTable// ---------------------------------------------------------------------------------CConfigureTable::~CConfigureTable(){	if (mCommentData) delete mCommentData;	if (mFormatH) DisposeHandle(mFormatH);}// ---------------------------------------------------------------------------------//		¥ SetWindow// ---------------------------------------------------------------------------------voidCConfigureTable::SetWindow(LWindow* inWindow){	mWindow = inWindow;}#pragma mark --- Geometry ---// ---------------------------------------------------------------------------//		¥ Insert/Remove Rows// ---------------------------------------------------------------------------voidCConfigureTable::InsertRows(	SInt32		inHowMany,	TableIndexT	inAfterRow,	void		*inCellData){		// +++ Bounds check input params		if (mCellData != nil) {		mCellData->InsertItemsAt(inHowMany * mCols, inAfterRow * mCols + 1,									inCellData);	}	if (mCommentData != nil) {		mCommentData->InsertItemsAt(inHowMany * mNumComments,				inAfterRow * mNumComments + 1, "\p ", 2);	}									mRows += inHowMany;		ResizeImageBy(0, inHowMany * mRowHeight, true);}voidCConfigureTable::RemoveRows(	SInt32		inHowMany,	TableIndexT	inFromRow){		// +++ Bounds check input params		if (mCellData != nil) {		mCellData->RemoveItemsAt(inHowMany * mCols,									(inFromRow - 1) * mCols + 1);	}	if (mCommentData != nil) {		mCommentData->RemoveItemsAt(inHowMany * mNumComments,									(inFromRow - 1) * mNumComments + 1);	}	mRows -= inHowMany;		ResizeImageBy(0, -inHowMany * mRowHeight, true);}// ---------------------------------------------------------------------------//		¥ Set Column Type// ---------------------------------------------------------------------------voidCConfigureTable::SetColType(	UInt8		inType,	TableIndexT	inFromCol,	TableIndexT	inToCol){TableIndexT		col;	if ((inFromCol <= inToCol) && (inToCol <= kMaxDCols)) {		for (col=inFromCol; col<=inToCol; col++)			mColType[col] = inType;	}}// ---------------------------------------------------------------------------//		¥ Get Column Type// ---------------------------------------------------------------------------UInt8CConfigureTable::GetColType( TableIndexT inCol ){	return mColType[inCol];}// ---------------------------------------------------------------------------//		¥ Set Column Width// ---------------------------------------------------------------------------voidCConfigureTable::SetColWidth(	SInt16		inWidth,	TableIndexT	inFromCol,	TableIndexT	inToCol){TableIndexT		col;SInt32			adjWidth = 0;	for (col=1; col<=mCols; col++)			// compute total old width		adjWidth += mMultiColWidth[col];	if ((inFromCol <= inToCol) && (inToCol <= kMaxDCols)) {		for (col=inFromCol; col<=inToCol; col++)			mMultiColWidth[col] = inWidth;	}	for (col=1; col<=mCols; col++)			// subtract total new width		adjWidth -= mMultiColWidth[col];			ResizeImageBy(adjWidth, 0, true);}// ---------------------------------------------------------------------------//		¥ Get Column Width// ---------------------------------------------------------------------------SInt16CConfigureTable::GetColWidth( TableIndexT inCol ){	return mMultiColWidth[inCol];}// ---------------------------------------------------------------------------//		¥ Fetch Local Cell Frame// ---------------------------------------------------------------------------BooleanCConfigureTable::FetchLocalCellFrame(	const TableCellT	&inCell,	Rect				&outCellFrame){								// Get Top-Left in Image coordinates	SPoint32	cellImage;	cellImage.h = 0;	for (TableIndexT col=1; col<=(inCell.col-1); col++)		cellImage.h += mMultiColWidth[col];		cellImage.v = (inCell.row - 1) * mRowHeight;									// Check if Cell intersects the Frame	Boolean	intersectsFrame = ImageRectIntersectsFrame(									cellImage.h, cellImage.v,									cellImage.h + mMultiColWidth[inCell.col],									cellImage.v + mRowHeight);									// Convert to Local coordinates	ImageToLocalPoint(cellImage, topLeft(outCellFrame));	outCellFrame.right = outCellFrame.left + mMultiColWidth[inCell.col];	outCellFrame.bottom = outCellFrame.top + mRowHeight;		return intersectsFrame;}// ---------------------------------------------------------------------------//		¥ Fetch Local Content Frame// ---------------------------------------------------------------------------//	Get the content frame leaving room for a cell borderBooleanCConfigureTable::FetchLocalContentFrame(	const TableCellT	&inCell,	Rect				&outCellFrame){	Boolean	intersectsFrame = FetchLocalCellFrame( inCell, outCellFrame );	outCellFrame.bottom -= 1;	outCellFrame.right -= 1;	return intersectsFrame;}// ---------------------------------------------------------------------------//		¥ Fetch Local Row Frame// ---------------------------------------------------------------------------BooleanCConfigureTable::FetchLocalRowFrame(	const TableIndexT	&inRow,	Rect				&outRowFrame){	TableCellT	tCell;	Rect		theFrame;		tCell.row = inRow;	tCell.col = 1;	Boolean intersectsFrame = FetchLocalContentFrame(tCell, outRowFrame);	tCell.col = mCols;	FetchLocalContentFrame(tCell, theFrame);	outRowFrame.right = theFrame.right;	if (mSelectionStart != mSelectionEnd) {		if (mSelectionStart < inRow) {			 tCell.row = mSelectionStart;			 FetchLocalContentFrame(tCell, theFrame);			 outRowFrame.top = theFrame.top;		} else {			tCell.row = mSelectionEnd;			FetchLocalContentFrame(tCell, theFrame);			outRowFrame.bottom = theFrame.bottom;		}	}	// stay within the table border	CalcLocalFrameRect(theFrame);	::SectRect(&theFrame, &outRowFrame, &outRowFrame);	return intersectsFrame;}// ---------------------------------------------------------------------------//		¥ Fetch Cell Hit By// ---------------------------------------------------------------------------voidCConfigureTable::FetchCellHitBy(	const SPoint32	&inImagePt,	TableCellT		&outCell){//	outCell.row = (inImagePt.v - 1) / (mRowHeight+1) + 1;	outCell.row = (inImagePt.v - 1) / mRowHeight + 1;	TableIndexT	cIndex	= 0;	SInt32		tWidth	= 0;	while ( (cIndex < mCols) && (inImagePt.h > tWidth) ) {		cIndex += 1;//		tWidth += mMultiColWidth[cIndex] + 1;		tWidth += mMultiColWidth[cIndex];	}	outCell.col = cIndex;}// ---------------------------------------------------------------------------//		¥ Set Comment Data Size// ---------------------------------------------------------------------------// Create DynamicArray for holding comment data// mCommentData must not already be allocatedvoidCConfigureTable::SetCommentDataSize(	SInt32	inCommentDataSize, UInt8 inNumComments=1){	// remember how many comments per row	mNumComments = inNumComments;	mCommentDataSize = inCommentDataSize;		if ((mCommentData == nil) && (inCommentDataSize > 0)) {		mCommentData = new LArray(inCommentDataSize);		mCommentData->InsertItemsAt(mRows*mNumComments, 1, "\p", 1); // (numItems, inAt, *item, itemSize)	}}// ---------------------------------------------------------------------------//		¥ Fetch Comment Data Index// ---------------------------------------------------------------------------SInt32CConfigureTable::FetchCommentDataIndex(	const TableIndexT	inRow, const TableIndexT inSelect){	return (SInt32) ((inRow - 1) * mNumComments + inSelect);}#pragma mark --- Data and Selection ---// ---------------------------------------------------------------------------//		¥ ClearTable()// ---------------------------------------------------------------------------voidCConfigureTable::ClearTable(){	// initialize table data	TableCellT		tCell;	TableItemW		tData;	tData.hi = 0;	tData.lo = 0;	for (tCell.row=1; tCell.row<=mRows; tCell.row++) {		// keep last column to cache names from previous trace if any		for (tCell.col=1; tCell.col<=(mCols - 1); tCell.col++) {						SetCellData( tCell, &tData );		}	}}// ---------------------------------------------------------------------------//		¥ ClearRow()// ---------------------------------------------------------------------------voidCConfigureTable::ClearRow(TableIndexT inRow){	// clear table row	TableCellT		tCell;	TableItemW		tData;	tCell.row = inRow;	tData.hi = 0;	tData.lo = 0;	for (tCell.col=1; tCell.col<=mCols; tCell.col++) {					SetCellData( tCell, &tData );	}	RefreshRow(inRow);}// ---------------------------------------------------------------------------//		¥ Set Comment Data// ---------------------------------------------------------------------------//	Set comment data for displayvoidCConfigureTable::SetCommentData( TableIndexT inRow,  UInt8 inSelect, ConstStr255Param inStr){	// (inCount, inAtIndex, *inValue, inItemSize)	mCommentData->AssignItemsAt(1, FetchCommentDataIndex(inRow, inSelect),		inStr, inStr[0]+1);}// ---------------------------------------------------------------------------//		¥ Get Comment Data// ---------------------------------------------------------------------------//	Get comment data for displayBooleanCConfigureTable::GetCommentData(TableIndexT inRow,  UInt8 inSelect, Str255 outStr){	Boolean result = false;		if (mCommentData != nil) {		result = mCommentData->FetchItemAt(FetchCommentDataIndex(inRow, inSelect), outStr);	}	return result;}// ---------------------------------------------------------------------------//		¥ Get Row IP Addr// ---------------------------------------------------------------------------//	Get IP address from specified table row (if any)UInt32CConfigureTable::GetRowIPAddr( TableIndexT inRow ){	TableCellT		theCell;	TableItemW		tData;	tData.hi = 0;	tData.lo = 0;	theCell.row = inRow;	for (theCell.col=1; theCell.col<=mCols; theCell.col++) {		if (GetColType(theCell.col) == kColTypeIPAddr) {			GetCellData( theCell, &tData );			break;		}	}		return tData.hi;}// ---------------------------------------------------------------------------//		¥ Click Cell// ---------------------------------------------------------------------------//  Handle click in cell.voidCConfigureTable::ClickCell(	const TableCellT		&inCell,	const SMouseDownEvent&	inMouseDown){//	TableCellT	theCell;	UInt32	IPAddr;	// if Shift key down, set flag to extend selection	Boolean extendFlag;	if (inMouseDown.macEvent.modifiers & shiftKey) extendFlag = true;	else extendFlag = false;	// check for double click	if (GetClickCount() == 2) {			// Get IP Address from clicked row of table		IPAddr = GetRowIPAddr( inCell.row );						// If trace has found an address, try to invoke ping		if (IPAddr != 0) {			// ping test//			ObeyCommand(cmd_TestConnectivity, nil);		}	} else {		SelectRow(inCell, extendFlag);	}}// ---------------------------------------------------------------------------//		¥ Select Row// ---------------------------------------------------------------------------//  Select a table row, or extend the selection to include a range of rowsvoidCConfigureTable::SelectRow(	const TableCellT &inCell, Boolean inExtendFlag){	if (IsTarget()) {		if ((inCell.row != mSelectedCell.row) ||			((mSelectionStart != mSelectionEnd) && (!inExtendFlag))) {			FocusDraw();			UnhiliteCell(mSelectedCell);					mSelectedCell = inCell;			if (inExtendFlag && mSelectionStart) {				if (inCell.row > mSelectionStart) mSelectionEnd = inCell.row;				else mSelectionStart = inCell.row;			} else {				mSelectionStart = mSelectedCell.row;				mSelectionEnd = mSelectedCell.row;					}			HiliteCell(inCell);		}	} else {		// not target		// become target so we can unhilite when no longer target		this->SwitchTarget(this);		FocusDraw();		if (mHiliteStyle != kHiliteNone) {			UnhiliteCell(mSelectedCell);		}		mSelectedCell = inCell;		if (inExtendFlag && mSelectionStart) {			if (inCell.row > mSelectionStart) mSelectionEnd = inCell.row;			else mSelectionStart = inCell.row;		} else {			mSelectionStart = mSelectedCell.row;			mSelectionEnd = mSelectedCell.row;				}		HiliteCell(inCell);	}}// ---------------------------------------------------------------------------//		¥ DontBeTarget// ---------------------------------------------------------------------------//	Commander will no longer be the Target////	Subclasses should override this function if they wish to behave//	differently when they are and are not the Target. At entry, the class//	variable sTarget points to this Commander. sTarget will be changed//	soon afterwards to the new target.voidCConfigureTable::DontBeTarget(){	// if window is still active, another pane has been selected	// so unhilite table selection.	if (IsActive()) {		FocusDraw();		UnhiliteCell(mSelectedCell);		mSelectionStart = 0;		mSelectionEnd = 0;	}}// ---------------------------------------------------------------------------//		¥ LaunchURL// ---------------------------------------------------------------------------voidCConfigureTable::LaunchURL(Str63 inScheme){	UInt32		IPAddr;	ICError 	err;	long 		selStart, selEnd;	Str63		str;	LStr255		URLStr;	if (gICInstance) {		// if there is a selection, invoke corresponding action		if ((inScheme[0] > 0) && (mSelectionStart != 0) && (mSelectionStart == mSelectionEnd)) {			URLStr = inScheme;			// Get IP Address from selected row of table			IPAddr = GetRowIPAddr(mSelectionStart);			if (IPAddr != 0) {				IP_NumToStr(IPAddr, str);				// append address to scheme				URLStr += str;				// Launch URL via Internet Config				selStart = 0;				selEnd = URLStr[0];				err = ICLaunchURL(gICInstance, "\p", (char*)&URLStr[1], URLStr[0],	&selStart, &selEnd);			}		}	}}// ---------------------------------------------------------------------------//		¥ HandleKeyPress// ---------------------------------------------------------------------------//	Return true if the Window handles the keystrokeBooleanCConfigureTable::HandleKeyPress(	const EventRecord&	inKeyEvent){	Boolean		keyHandled = true;	SInt16		theKey = inKeyEvent.message & charCodeMask;	TableCellT	theCell;	switch (theKey) {			case char_Tab:			if (mWindow) {				LEditField* theEditField = (LEditField*) mWindow->FindPaneByID( 2 );				if (theEditField) theEditField->SwitchTarget(theEditField);						}			break;		case char_UpArrow:			GetSelectedCell(theCell);			theCell.row -= 1;			if (IsValidCell(theCell)) {				SelectRow(theCell, false);				AdjustView(theCell);			}			break;		case char_DownArrow:			GetSelectedCell(theCell);			theCell.row += 1;			if (IsValidCell(theCell)) {				SelectRow(theCell, false);				AdjustView(theCell);			}			break;		// Generate GURL for companion IPNetMonitor tools		case 't':		case 'T':			if (inKeyEvent.modifiers & cmdKey) {				LaunchURL("\pping://");			}			break;		case 'r':		case 'R':			if (inKeyEvent.modifiers & cmdKey) {				LaunchURL("\ptraceroute://");			}			break;		// Generate GURL for Helper applications		case '1':		case '2':		case '3':		case '4':			if ((inKeyEvent.modifiers & cmdKey) && gICInstance) {				UInt32		IPAddr;				ICError 	err;				long 		selStart, selEnd;				Str255		str;				LStr255		URLStr;				// get URL scheme of corresponding helper from resource				::GetIndString( str , rSTRN_GURLHelpers, (theKey-'0') );				// if we found a scheme and				// there is a selection, invoke corresponding action				if ((str[0] > 0) && (mSelectionStart != 0) && (mSelectionStart == mSelectionEnd)) {					URLStr = str;					// Get IP Address from selected row of table					IPAddr = GetRowIPAddr(mSelectionStart);					if (IPAddr != 0) {						IP_NumToStr(IPAddr, str);						// append address to scheme						URLStr += str;						// Launch URL via Internet Config						selStart = 0;						selEnd = URLStr[0];						err = ICLaunchURL(gICInstance, "\p", (char*)&URLStr[1], URLStr[0],	&selStart, &selEnd);					}				}			}			break;		default:			keyHandled = LCommander::HandleKeyPress(inKeyEvent);			break;	}	return keyHandled;}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------BooleanCConfigureTable::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean			cmdHandled = true;	TableItemW		tData;	TableCellT		tCell;	LWindow*		theWindow;	Str255			str;	switch (inCommand) {			case cmd_SelectAll:			tCell.col = 1;			tCell.row = 1;			// erase previous selection if any			FocusDraw();			UnhiliteCell(tCell);			// set selection range to include each row containing data			mSelectionStart = 1;			do {				GetCellData( tCell, &tData );				if (tData.hi) mSelectionEnd = tCell.row;				tCell.row += 1;			} while ((tCell.row <= mRows) && tData.hi);			// display new selection			tCell.row = mSelectionEnd;			mSelectedCell = tCell;			HiliteCell(mSelectedCell);			break;		case cmd_Copy:			DoCopy();			break;		case cmd_SubnetCalculator:			// Create the Subnet Calculator Window			theWindow = InvokeWindow(kNameSubnetCalculator, gAppObject);			theWindow->Show();			// if there is a selection, invoke corresponding action			if ((mSelectionStart != 0) && (mSelectionStart == mSelectionEnd)) {				// Get IP Address from selected row of table				tData.hi = GetRowIPAddr(mSelectionStart);				if (tData.hi != 0) {					((CSubnetCalcWindow*)theWindow)->InvokeSubnetCalcWindow( IP_NumToStr(tData.hi, str) );				}			}			break;		default:			cmdHandled = mSuperCommander->ProcessCommand(inCommand, ioParam);			break;	}	return cmdHandled;}// ---------------------------------------------------------------------------//		¥ FindCommandStatus// ---------------------------------------------------------------------------//	This function enables our menu commands.voidCConfigureTable::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	UInt16		&outMark,	Str255		outName){	TableItemW	tData;	TableCellT		tCell;	switch (inCommand) {		case cmd_Copy:					// allow copy if there's data			tCell.row = mSelectionStart;			tCell.col = 1;			GetCellData( tCell, &tData );			if (tData.hi) outEnabled = true;			else outEnabled = false;			outUsesMark = false;			break;		case cmd_SelectAll:				// allow select all is there's data			tCell.row = 1;			tCell.col = 1;			GetCellData( tCell, &tData );			if (tData.hi) outEnabled = true;			else outEnabled = false;			outUsesMark = false;			break;		default:			mSuperCommander->ProcessCommandStatus(inCommand, outEnabled,								outUsesMark, outMark, outName);			break;	}}// override to handle copy from table rowvoidCConfigureTable::DoCopy(){}// space over to desired column position from lineOffsetvoidCConfigureTable::SpaceOver(Handle inDestH, UInt32& ioDestLen,					TableIndexT inLineOffset, TableIndexT inColOffset){	SInt32	numToAdd;	numToAdd = inColOffset - (ioDestLen - inLineOffset);	if (numToAdd > 0) {		::OTMemset((*inDestH)+ioDestLen, (UInt8)' ', numToAdd);//		::BlockMove("                                ",//			(*inDestH)+ioDestLen, numToAdd);		ioDestLen += numToAdd;	}}// append stringvoidCConfigureTable::AppendString(Handle inDestH, UInt32& ioDestLen, ConstStr255Param inStr){	::OTMemcpy((*inDestH)+ioDestLen, &inStr[1], inStr[0]);//	::BlockMove(&inStr[1], (*inDestH)+ioDestLen, inStr[0]);	ioDestLen += inStr[0];}#pragma mark --- Drawing ---voidCConfigureTable::HiliteCell(	const TableCellT&	inCell){	Rect		rowFrame;		if (IsValidCell(inCell)) {		FetchLocalRowFrame(inCell.row, rowFrame);		if (rowFrame.bottom) {		// not empty			ApplyForeAndBackColors();			UDrawingUtils::SetHiliteModeOn();			if (IsActive()) {				InvertRect(&rowFrame);				mHiliteStyle = kHiliteSelect;			} else {				StColorPenState::Normalize();				::PenMode(srcXor);				::FrameRect(&rowFrame);				mHiliteStyle = kHiliteInactive;			}		}	}}voidCConfigureTable::UnhiliteCell(	const TableCellT&	/* inCell */){	Rect		rowFrame;	if (IsValidCell(mSelectedCell)) {		FetchLocalRowFrame(mSelectedCell.row, rowFrame);		if (rowFrame.bottom) {		// not empty			switch (mHiliteStyle) {				case kHiliteSelect:					// Undo select hiliting					ApplyForeAndBackColors();					UDrawingUtils::SetHiliteModeOn();					InvertRect(&rowFrame);					break;				case kHiliteInactive:					// Undo inactive hiliting					UDrawingUtils::SetHiliteModeOn();					StColorPenState::Normalize();					::PenMode(srcXor);					::FrameRect(&rowFrame);					break;				default:					// shouldn't be Unhiliting if no hilite is in effect					Assert_(mHiliteStyle != kHiliteNone);					break;			}	// end switch		}		mHiliteStyle = kHiliteNone;	}}voidCConfigureTable::ActivateSelf(){	FocusDraw();	UnhiliteCell(mSelectedCell);	// Undo inactive hiliting	HiliteCell(mSelectedCell);		// Do active hiliting}// ---------------------------------------------------------------------------//		¥ Adjust View// ---------------------------------------------------------------------------//	Scroll the image to include the specified cell//		return true if the view was scrolledBooleanCConfigureTable::AdjustView(const TableCellT &inCell){	Boolean scrolled = false;	// get cell position (local coordinates)	Rect	cellFrame;	FetchLocalCellFrame( inCell, cellFrame );	// get the view frame in local coordinates	Rect	viewFrame;	CalcLocalFrameRect(viewFrame);	// calculate the vertical offset needed to	// include the cellFrame in the viewFrame	//	negative offest means scroll up or backward	SPoint32	scrollAmount;	scrollAmount.h = 0;	scrollAmount.v = 0;	if (cellFrame.top < viewFrame.top) {		scrollAmount.v = cellFrame.top - viewFrame.top;		scrolled = true;	} else if (cellFrame.bottom > viewFrame.bottom) {		scrollAmount.v = cellFrame.bottom - viewFrame.bottom;		scrolled = true;	}	if (scrolled == true) {		ScrollImageBy(scrollAmount.h, scrollAmount.v, true);	}	return scrolled;}// ---------------------------------------------------------------------------//		¥ Draw Cell// ---------------------------------------------------------------------------voidCConfigureTable::DrawCell(	const TableCellT	&inCell){	Rect		cellFrame;	TableItemW	tData;	UInt8		colType;			Str31		str;	UInt8		*dp;	OSErr		err = noErr;	if (FetchLocalContentFrame(inCell, cellFrame)) {		// draw white background		::PenNormal();		ApplyForeAndBackColors();		::EraseRect(&cellFrame);		// draw border around cell		::InsetRect(&cellFrame, -1, -1);		::PenPat(&UQDGlobals::GetQDGlobals()->gray);		if (PaneInColor (this)) {			StColorState	saveColor;			RGBColor		emptyColor;			emptyColor = gAGAColorArray[6];			::RGBForeColor(&emptyColor);			::FrameRect(&cellFrame);		} else { ::FrameRect(&cellFrame); }		::PenPat(&UQDGlobals::GetQDGlobals()->black);				// draw contents		::TextFont(applFont);		::TextFace(0);	// normal		::TextSize(9);		// Get cell data		GetCellData( inCell, &tData );		// Handle each column based its Column Data Type		colType = GetColType(inCell.col);		switch (colType) {			case kColTypeNumber:				// display a number if not zero				if (tData.hi != kItemNone) {					if (tData.hi < 10) ::MoveTo(cellFrame.left + 16, cellFrame.bottom - 4);					else ::MoveTo(cellFrame.left + 10, cellFrame.bottom - 4);					NumToString(tData.hi, str);					DrawString(str);				}				break;			case kColTypeMark:				// display check mark or cross if indicated				// data indicates whether a reply was received				if (tData.hi != kItemNone) {					dp = (UInt8*)&tData;					cellFrame.left += 1;					cellFrame.right = cellFrame.left + 16;					if (dp[0] == kItemCheck)						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Check);					else if (dp[0] == kItemCross)						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Cross);					else if (dp[0] == kItemCheck2)						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Check2);					else if (dp[0] == kItemCross2)						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Cross2);					Assert_(err == noErr);					cellFrame.left += 16;					cellFrame.right = cellFrame.left + 16;					if (dp[1] == kItemCheck)						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Check);					else if (dp[1] == kItemCross)						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Cross);					else if (dp[1] == kItemCheck2)						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Check2);					else if (dp[1] == kItemCross2)						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Cross2);					Assert_(err == noErr);					cellFrame.left += 16;					cellFrame.right = cellFrame.left + 16;					if (dp[2] == kItemCheck)						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Check);					else if (dp[2] == kItemCross)						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Cross);					else if (dp[2] == kItemCheck2)						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Check2);					else if (dp[2] == kItemCross2)						err = ::PlotIconID (&cellFrame, atNone, ttNone, ricsN_Cross2);					Assert_(err == noErr);				}				break;			case kColTypeSeconds:				// display time for reply if any				// data is transit time in milliseconds				if (tData.hi != kItemNone) {					::MoveTo(cellFrame.left + 8, cellFrame.bottom - 4);					// show seconds and hundredths					// convert to decimal string in seconds					MSecToString(tData.hi, str);					DrawString(str);				}				break;			case kColTypeIPAddr:				// display IP Address if not zero				if (tData.hi != kItemNone) {					MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);					IP_NumToStr( tData.hi, str );					DrawString( str );				}				break;			case kColTypeHWAddr:				// display HW Address if not zero				if ((tData.hi != kItemNone) || (tData.lo>>16 != kItemNone)) {					MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);					HW_NumToHexStr( (MACAddr_t*)&tData, str );					DrawString( str );				}				break;			case kColTypeTime:				if (tData.hi != kItemNone) {					LStr255 timeDateStr;					MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);					// build time string					// setup formatting resource					if (mFormatH == nil) {						OSErr		err;						mFormatH = ::GetIntlResource(0);	// Get 'itl0' resource						err = ::HandToHand(&mFormatH);		// Get a copy						if (err != noErr) mFormatH = nil;						// modify to use 24 hour time						(**(Intl0Hndl)mFormatH).timeCycle = 0;					}					// void DateString (long dateTime,DateFormlongFlag,char *result,Handle intlHandle);					::DateString(tData.hi, shortDate, str, nil);					timeDateStr += str;					timeDateStr += "\p ";					// void TimeString (long dateTime,Boolean wantSeconds,char *result,Handle intlHandle);							::TimeString(tData.hi, true, str, mFormatH);					timeDateStr += str;					DrawString( timeDateStr );				}				break;			case kColTypeComment1:			case kColTypeComment2:			case kColTypeComment3:				UInt8 commentID;				commentID = colType - kColTypeComment1 + 1;				// display comment data if any				if (tData.hi == kCommentFlag) {					MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);					if (mCommentData != nil) {						Str255 commentData;						GetCommentData(inCell.row, commentID, commentData);						DrawString(commentData);					}				}				break;			default:									// ### Debugging									// Draw cell row & column number inside									// frame of cell				::MoveTo(cellFrame.left + 8, cellFrame.bottom - 4);					Str31	str;				NumToString(inCell.row, str);				DrawString(str);				DrawString("\p,");				NumToString(inCell.col, str);				DrawString(str);				break;		}	}}