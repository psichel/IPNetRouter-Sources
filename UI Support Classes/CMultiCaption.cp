// =================================================================================//	CMultiCaption.cp				©1996 Sustainable Softworks All rights reserved.// =================================================================================//	Display multiple captions for column headings//		Individual captions are separated by "|" in the descriptor.//		Use SetColWidth to adjust caption widths.//		Width of zero means no more captions.#include "CMultiCaption.h"#include "AGAColors.h"#include "CConfigureTable.h"// ---------------------------------------------------------------------------------//		¥ CreateMultiCaptionStream [static]// ---------------------------------------------------------------------------------CMultiCaption *CMultiCaption::CreateMultiCaptionStream(	LStream	*inStream ){	return new CMultiCaption( inStream );}// ---------------------------------------------------------------------------------//		¥ CMultiCaption(LStream*)// ---------------------------------------------------------------------------------CMultiCaption::CMultiCaption(	LStream	*inStream )		: LCaption( inStream ){	inStream->ReadData(&mCols, sizeof(mCols));	inStream->ReadData(&mColWidth, sizeof(mColWidth));		// initialize column widths to the default fixed width	for (TableIndexT col=1; col<=kMaxCols; col++) {		mMultiColWidth[col] = mColWidth;	}}// ---------------------------------------------------------------------------------//		¥ ~CMultiCaption// ---------------------------------------------------------------------------------CMultiCaption::~CMultiCaption(){}// ---------------------------------------------------------------------------------//		¥ Set Width From Table// ---------------------------------------------------------------------------------voidCMultiCaption::SetWidthFromTable(CConfigureTable* inTable){	TableIndexT numRows, numCols, col;	SInt16 width;		inTable->GetTableSize(numRows, numCols);	for (col=1; col<=numCols; col++) {		width = inTable->GetColWidth(col);		SetColWidth(width, col, col);	}}// ---------------------------------------------------------------------------------//		¥ Set Column Width// ---------------------------------------------------------------------------------voidCMultiCaption::SetColWidth(	SInt16		inWidth,	TableIndexT	inFromCol,	TableIndexT	inToCol){TableIndexT		col;SInt32			newWidth = 0;	if ((inFromCol <= inToCol) && (inToCol <= kMaxCols)) {		for (col=inFromCol; col<=inToCol; col++)			mMultiColWidth[col] = inWidth;	}	for (col=1; col<=mCols; col++)				// compute new width		newWidth += mMultiColWidth[col];		mFrameSize.width = newWidth;	}// ---------------------------------------------------------------------------//		¥ Get Column Width// ---------------------------------------------------------------------------SInt16CMultiCaption::GetColWidth( TableIndexT inCol ){	return mMultiColWidth[inCol];}// ---------------------------------------------------------------------------//		¥ DrawSelf// ---------------------------------------------------------------------------//	Draw the CaptionvoidCMultiCaption::DrawSelf(){	Rect	frame, border;	CalcLocalFrameRect(frame);	SInt16	frameEnd;	LStr255 subString;	UInt8	startPos, endPos;		SInt16	just = UTextTraits::SetPortTextTraits(mTxtrID);		RGBColor	textColor;	::GetForeColor(&textColor);		ApplyForeAndBackColors();	::RGBForeColor(&textColor);		// for each column	// get the substring to display in this column	// adjust frame for this column	endPos = 0;	frameEnd	= frame.right;	frame.right = frame.left;	for (TableIndexT col=1; col<=mCols; col++) {		// get next substring		startPos = endPos + 1;		endPos = mText.Find( '|', startPos );		if (endPos == 0) endPos = startPos;		subString.Assign( mText, startPos, endPos-startPos );		// set frame for this column		frame.left = frame.right;		frame.right = frame.left + mMultiColWidth[col];		// if last column, set to right end		if (col == mCols) frame.right = frameEnd;		border = frame;		// if (width != 0) and not beyond end of frame, draw the string		if ((mMultiColWidth[col] != 0) && (frame.right <= frameEnd)) {			frame.top += 3;		// adjust vertical position 			UTextDrawing::DrawWithJustification((Ptr)&subString[1], subString[0], frame, just);			frame.top -= 3;			// draw the border			border.right += 1;			::InsetRect(&border, 1, 1);			if (PaneInColor(this)) DimRaisedLTRect(&border);			::InsetRect(&border, -1, -1);			::FrameRect(&border);		}	}}