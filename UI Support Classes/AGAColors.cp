// ===========================================================================//	AGAColors.cp// ===========================================================================//	“Apple Grayscale Appearance” compliant colors//	Copyright © 1996 Chrisoft (Christophe ANDRES)  All rights reserved.////	You may use this source code in any application (commercial, shareware, freeware,//	postcardware, etc), but not remove this notice (no need to acknowledge the use of//	this class in the about box)//	You may not sell this source code in any form. This source code may be placed on //	publicly accessable archive sites and source code disks. It may not be placed on //	profit archive sites and source code disks without the permission of the author, //	Christophe ANDRES.//	//	    This source code is distributed in the hope that it will be useful,//	    but WITHOUT ANY WARRANTY; without even the implied warranty of//	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.////	If you make any change or improvement on this class, please send the improved/changed//	version to : chrisoft@calva.net or Christophe ANDRES//                                     20, rue Prosper Mérimée//                                     67100 STRASBOURG//                                     FRANCE//// ===========================================================================//	AGAColors.h			<- double-click + Command-D to see declaration////	AGAColors define the colors of the “Apple Grayscale Appearance for System 7.5”//		and some related routines////		Version : 1.1////		Change History (most recent first, date in US form : mm/dd/yy):////						05/25/96	ca		Changed PaneInColor to return false if less than 16 colors//						05/20/96	M™H		Added the A1 to A4 colors needed for LAGADiscloTriangle//						05/15/96	ca		Added the “A” color which is needed only for the Indeterminate progress indicator//														Replaced HasAGAColors with PaneInColor, which carries the same purpose, but is better//														and was designed and submitted by Michael(tm) Hamel <mhamel@adi.co.nz> (Thanks ;)//						05/11/96	ca		Increased release version to 1.1//														Added HasAGAColors to check if a pane can draw in color//														Added Change History//						04/22/96	ca		file made available//														(version 1.0)////		To Do://#pragma once#include "AGAColors.h"#include <QuickDraw.h>#include <UEnvironment.h>const RGBColor gAGAColorArray[] = {	{0xFFFF, 0xFFFF, 0xFFFF},		//	W																		{0xEEEE, 0xEEEE, 0xEEEE}, 	//	1																		{0xDDDD, 0xDDDD, 0xDDDD}, 	//	2																		{0xCCCC, 0xCCCC, 0xCCCC}, 	//	3																		{0xBBBB, 0xBBBB, 0xBBBB}, 	//	4																		{0xAAAA, 0xAAAA, 0xAAAA}, 	//	5																		{0x9999, 0x9999, 0x9999}, 	//	6																		{0x8888, 0x8888, 0x8888},		//	7																		{0x7777, 0x7777, 0x7777},		//	8																		{0x6666, 0x6666, 0x6666},		//	9																		{0x5555, 0x5555, 0x5555},		//	10																		{0x4444, 0x4444, 0x4444},		//	11																		{0x2222, 0x2222, 0x2222},		//	12																		{0x0000, 0x0000, 0x0000},		//	B																		{0x3333, 0x3333, 0x3333},		//	A															<05/15/96	ca>																		{0xCCCC, 0xCCCC, 0xFFFF},		//	A1														<05/20/96 M™H> for LAGADiscloTriangle																		{0x9999, 0x9999, 0xFFFF},		//	A2																		{0x6666, 0x6666, 0xCCCC},		//	A3																		{0x3333, 0x3333, 0x9999}		//	A4																	};// -Contributed by Michael(tm) Hamel <mhamel@adi.co.nz>------------------------------------------------------------Boolean PaneInColor (LPane* aPane)// Return false if any part of this pane is on a monochrome device - M™H{	Rect pRect;	GDHandle aDevice;	Rect iSect;	if (!UEnvironment::HasFeature(env_SupportsColor))		return false;			if (!aPane->CalcPortFrameRect(pRect))		return false;		// Outside QD space, so its academic really			aPane->PortToGlobalPoint(topLeft(pRect));	aPane->PortToGlobalPoint(botRight(pRect));	aDevice = ::GetDeviceList();	while (aDevice!=nil)		{			if (::TestDeviceAttribute(aDevice,screenActive) &&		  	 	::TestDeviceAttribute(aDevice,screenDevice))		  	{		   		::SectRect(&((**aDevice).gdRect),&pRect,&iSect);		   		if (iSect.left!=iSect.right)			 			if ((**((**aDevice).gdPMap)).pixelSize < 4)																			//	<05/25/96	ca>			 				return false;				}			aDevice = ::GetNextDevice(aDevice);		}	return true;}// ---------------------------------------------------------------------------//		• DimensionRect// ---------------------------------------------------------------------------//	Draw shading lines around a rectangle to give it a dimensioned 3D look//		06/06/96		Peter SichelvoidDimSunkRect(Rect *inFrame){	Rect frame = *inFrame;	StColorState	saveColors;	RGBColor			emptyColor;	::PenNormal();	emptyColor = gAGAColorArray[7];	::RGBForeColor(&emptyColor);	::MoveTo(frame.left, frame.bottom-2);	::LineTo(frame.left, frame.top);	::LineTo(frame.right-2, frame.top);	emptyColor = gAGAColorArray[W];	::RGBForeColor(&emptyColor);	::MoveTo(frame.left+1, frame.bottom-1);	::LineTo(frame.right-1, frame.bottom-1);	::LineTo(frame.right-1, frame.top+1);}voidDimRaisedRect(Rect *inFrame){	Rect frame = *inFrame;	StColorState	saveColors;	RGBColor			emptyColor;	::PenNormal();	emptyColor = gAGAColorArray[W];	::RGBForeColor(&emptyColor);	::MoveTo(frame.left, frame.bottom-2);	::LineTo(frame.left, frame.top);	::LineTo(frame.right-2, frame.top);	emptyColor = gAGAColorArray[7];	::RGBForeColor(&emptyColor);	::MoveTo(frame.left+1, frame.bottom-1);	::LineTo(frame.right-1, frame.bottom-1);	::LineTo(frame.right-1, frame.top+1);}// Dimension left and top border onlyvoidDimRaisedLTRect(Rect *inFrame){	Rect frame = *inFrame;	StColorState	saveColors;	RGBColor			emptyColor;	::PenNormal();	emptyColor = gAGAColorArray[W];	::RGBForeColor(&emptyColor);	::MoveTo(frame.left, frame.bottom-1);	::LineTo(frame.left, frame.top);	::LineTo(frame.right-1, frame.top);}voidDimSunkLTRect(Rect *inFrame){	Rect frame = *inFrame;	StColorState	saveColors;	RGBColor			emptyColor;	::PenNormal();	emptyColor = gAGAColorArray[9];	::RGBForeColor(&emptyColor);	::MoveTo(frame.left, frame.bottom-1);	::LineTo(frame.left, frame.top);	::LineTo(frame.right-1, frame.top);}