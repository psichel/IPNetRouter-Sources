// ===========================================================================//	CEditField.cp			  ©1996 Sustainable Softworks All rights reserved.// ===========================================================================//	Add custom shaded border to LEditfield#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include "CEditField.h"#include "IPRouterCommon.h"#include "AGAColors.h"#include <LStream.h>#include <UDrawingState.h>// ---------------------------------------------------------------------------//		¥ CreateEditFieldStream// ---------------------------------------------------------------------------//	Create a new EditField object from the data in a StreamCEditField*CEditField::CreateEditFieldStream(	LStream	*inStream){	return (new CEditField(inStream));}// ---------------------------------------------------------------------------//		¥ CEditField(LStream*)// ---------------------------------------------------------------------------//	Construct an EditField from the data in a StreamCEditField::CEditField(	LStream	*inStream)		: LEditField(inStream){	// add attachment to fix erase bug when field is empty	mEditAttachment = new CEditAttachment();	AddAttachment(mEditAttachment);	// reset rects to accomodate custom border	AlignTextEditRects();	SelectAll();}// ---------------------------------------------------------------------------//		¥ ~CEditField// ---------------------------------------------------------------------------//	DestructorCEditField::~CEditField(){	if (mEditAttachment) delete mEditAttachment;}// ---------------------------------------------------------------------------//		¥ HandleKeyPress// ---------------------------------------------------------------------------//	Handle <Return>, <Enter> passed up from an EditField////	Return true if the Window handles the keystrokeBooleanCEditField::HandleKeyPress(	const EventRecord&	inKeyEvent){	Boolean		keyHandled = true;	SInt16		theKey = inKeyEvent.message & charCodeMask;	switch (theKey) {			default:			if (UKeyFilters::IsActionKey(theKey)) {				BroadcastMessage(msg_FieldActionKey, this);			}			// inherit behavior			keyHandled = LEditField::HandleKeyPress(inKeyEvent);			break;	}		return keyHandled;}// ---------------------------------------------------------------------------//		¥ DrawBox// ---------------------------------------------------------------------------//	Draw box around an EditFieldvoidCEditField::DrawBox(){		// Box around an EditField is outset from the Text by 2 pixels.		// The box itself is 1 pixel thick, drawn in the foreground color		// of the Pane (not necessarily the same as the text color). If		// the EditField is disabled, the box draws with a gray pattern.		//		// The 1 pixel rectangle between the box and the text draws in		// the background color of the text.	StColorState	saveColors;			// Preserve color state	Rect			frame;	CalcLocalFrameRect(frame);	::PenNormal();	DimSunkRect(&frame);		// PAS custom shaded 3D look	::InsetRect(&frame, 1, 1);	// PAS one more pixel for shaded border			// Draw empty area between Box and Text. On entry, the fore		// and back colors for the Text are in effect (as set in FocusDraw).		// Use Text back color as the fore color for the empty area.		::InsetRect(&frame, 1, 1);	RGBColor	emptyColor;	::GetBackColor(&emptyColor);	::RGBForeColor(&emptyColor);	::FrameRect(&frame);			// Draw border around EditField			::InsetRect(&frame, -1, -1);	if (mEnabled != triState_On) {		// Disabled EditField has gray border		::PenPat(&UQDGlobals::GetQDGlobals()->gray);	}		ApplyForeAndBackColors();	::FrameRect(&frame);}// ---------------------------------------------------------------------------//		¥ AlignTextEditRects// ---------------------------------------------------------------------------//	Align the view and destination rectangles of the Toolbox TextEdit//	record with the Frame of an EditFieldvoidCEditField::AlignTextEditRects(){	Rect	textFrame;	if (!CalcLocalFrameRect(textFrame)) {						// Frame is outside QD Space. Put textFrame  at the				// upper left limit of QD Space (extreme negative coords).				// That location is guaranteed to be offscreen (unless				// you have a control longer than 32K pixels) since PP				// Image coordinates start at (0,0) and are never negative.		textFrame.left = min_Int16;		textFrame.right = textFrame.left + mFrameSize.width;		textFrame.top = min_Int16;		textFrame.bottom = textFrame.top + mFrameSize.height;	}		if (mHasBox) {		::InsetRect(&textFrame, 3, 3);	// PAS leave one more pixel for border	}									// Set TextEdit view and dest rectangles									//   to be the same as the Frame	(**mTextEditH).viewRect = textFrame;	(**mTextEditH).destRect = textFrame;		AdjustTextWidth(false);	::TECalText(mTextEditH);		// Let TextEdit adjust line breaks}// ---------------------------------------------------------------------------//		¥ AdjustTextWidth// ---------------------------------------------------------------------------//	Adjust the width of the destination rectangle of the Toolbox TextEdit//	record////	This function does nothing if WordWrap is ON. If WordWrap is OFF, this//	function sets the width of the TextEdit destination rectangle to either//	the width of the text or a very large number, depending on the value//	of inShrinkToText.////	This adjustment is needed to make autoscrolling work properly when//	WordWrap is off. While entering text, the destination rectangle should be//	very wide so that the text doesn't word wrap. However, while clicking,//	it should be just as wide as the text so that the EditField does not//	autoscroll past the edge of the text.voidCEditField::AdjustTextWidth(	Boolean	inShrinkToText){	if (!mHasWordWrap) {			// Adjust only if WordWrap is OFF				Rect	textFrame;			// Get size of editable text area		CalcLocalFrameRect(textFrame);		if (mHasBox) {			::InsetRect(&textFrame, 3, 3);	// PAS leave one more pixel for border		}				SInt16	destWidth = 4000;	// Very Wide				if (inShrinkToText) {		// Width of the Text in the EditField			Point	startPoint = ::TEGetPoint(0, mTextEditH);			Point	endPoint = ::TEGetPoint((**mTextEditH).teLength,												mTextEditH);			destWidth = endPoint.h - startPoint.h;						if (destWidth < textFrame.right - textFrame.left) {				destWidth = textFrame.right - textFrame.left;			}		}											// Direction to extend dest rect depends									//   on the text justification		SInt16	just = (**mTextEditH).just;		if (just == teFlushDefault) {									// For left justificaton, GetSysDirection									//    returns teFlushDefault									//    For right, teFlushRight			just = ::GetSysDirection();		}				switch (just) {					case teFlushLeft:		// Text fixed on left and grows right			case teFlushDefault:				(**mTextEditH).destRect.right = (**mTextEditH).destRect.left + destWidth;				break;							case teFlushRight:		// Text grows to the left				(**mTextEditH).destRect.left = (**mTextEditH).destRect.right - destWidth;				break;							case teCenter: {		// Text grows left and right				SInt16	center = (textFrame.left + textFrame.right) / 2;				(**mTextEditH).destRect.left = center - 2000;				(**mTextEditH).destRect.right = center + 2000;				break;			}		}	}}