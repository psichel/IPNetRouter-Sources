// ===========================================================================//	CArpData.cp			©1998 Sustainable Softworks, All rights reserved.// ===========================================================================// Arp Data (corresponds to Arp window)#include "CArpData.h"#include "CArpConst.h"#include "CConfigDocument.h"#include "IPSupport.h"#include <LString.h>// ---------------------------------------------------------------------------------//		¥ CArpData	[Constructor]// ---------------------------------------------------------------------------------CArpData::CArpData(){	mArpArray = nil;	Init();	bzero((UInt8*)&mArpEntry, sizeof(ArpEntry_t));}// ---------------------------------------------------------------------------------//		¥ ~CArpData	[Destructor]// ---------------------------------------------------------------------------------CArpData::~CArpData(){	if (mArpArray) delete mArpArray;	mArpArray = nil;}// ---------------------------------------------------------------------------------//		¥ Init// ---------------------------------------------------------------------------------//	Initialize Arp data storagevoidCArpData::Init(){	UInt32	count;		// Inteface array	if (mArpArray == nil) {		// allocate array object if needed		mArpArray	= new LArray(sizeof(ArpEntry_t));		ThrowIfNil_(mArpArray);	} else {		// remove any previous elements		count = mArpArray->GetCount();		if (count > 0) {			// (inCount, atIndex)			mArpArray->RemoveItemsAt(count, 1);		}	}}// ---------------------------------------------------------------------------------//		¥ MatchArpEntry// ---------------------------------------------------------------------------------//	Compare Arp Entries//	Return values://		kEntryMatch		(entry is already configured, ignore)//		kEntryNoMatch	(remove existing entry)SInt32CArpData::MatchArpEntry(ArpEntry_t* inArpEntry1, ArpEntry_t* inArpEntry2){	SInt32	result = kArpEntryNoMatch;		do {		// same interface name?		if (!::EqualString(inArpEntry1->interfaceName,						   inArpEntry2->interfaceName, false, false)) break;		// same protocol address?		if (inArpEntry1->protocolAddr != inArpEntry2->protocolAddr) break;		// same protocol mask?		if (inArpEntry1->protocolMask != inArpEntry2->protocolMask) break;		// same hardware address?		if (inArpEntry1->hardwareAddr.first4 != inArpEntry2->hardwareAddr.first4) break;		if (inArpEntry1->hardwareAddr.last2 != inArpEntry2->hardwareAddr.last2) break;		// same flags		if (inArpEntry1->arpFlags != inArpEntry2->arpFlags) break;		// Everything matches, we're done		result = kArpEntryMatch;	} while (false);		return result;}// ---------------------------------------------------------------------------------//		¥ ArpEntryToString// ---------------------------------------------------------------------------------// Convert an Arp Entry to a text string for exportStringPtrCArpData::ArpEntryToString(ArpEntry_t* inEntry, Str255 outStr){	LStr255	textStr;	Str31	str;	// default to empty	textStr = "\p";		if (inEntry->record) {		// arp entry		textStr += "\p+arp";		textStr += kDelimiterStr;		// interface name		textStr += inEntry->interfaceName;		textStr += kDelimiterStr;		// protocolAddr		IP_NumToStr(inEntry->protocolAddr, str);		textStr += str;		textStr += kDelimiterStr;				// protocolMask		IP_NumToStr(inEntry->protocolMask, str);		textStr += str;		textStr += kDelimiterStr;		// hardwareAddr		HW_NumToHexStr(&inEntry->hardwareAddr, str);		textStr += str;		textStr += kDelimiterStr;				// flags		if (inEntry->arpFlags & kArpFlagPermanent) {			textStr += kArpFlagPermanentStr;			textStr += kDelimiterStr;						}		if (inEntry->arpFlags & kArpFlagPublish) {			textStr += kArpFlagPublishStr;			textStr += kDelimiterStr;						}		if (inEntry->arpFlags & kArpFlagMapping) {			textStr += kArpFlagMappingStr;			textStr += kDelimiterStr;						}	}	return LString::CopyPStr(textStr, outStr, sizeof(Str255));}#pragma mark --- Accessors ---// ---------------------------------------------------------------------------------//		¥ SignalDataChange// ---------------------------------------------------------------------------------// Used to tell our document when data has changedvoidCArpData::SignalDataChange(){	SignalDataEvent( DATA_ID(kArpData, kDataChange) );}// ---------------------------------------------------------------------------------//		¥ SetDataArpEntry// ---------------------------------------------------------------------------------// Set/Get Config Entry (corresponds to parameters in config area of window)voidCArpData::SetDataArpEntry(ArpEntry_t* inEntry){	mArpEntry = *inEntry;	SignalDataEvent( DATA_ID(kArpData, kDataArpEntry) );}voidCArpData::GetDataArpEntry(ArpEntry_t* outEntry){	*outEntry = mArpEntry;}// ---------------------------------------------------------------------------------//		¥ SetDataArpArray// ---------------------------------------------------------------------------------// Write element to Arp array, insert new element if beyond end of array// and return index of where element was written.ArrayIndexTCArpData::SetDataArpArray(ArrayIndexT index, ArpEntry_t* inEntry){	ArrayIndexT	count;	ArrayIndexT	result;		count = mArpArray->GetCount();	if (index <= count) {		// assign element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mArpArray->AssignItemsAt(1, index, inEntry, sizeof(ArpEntry_t));	} else {		// insert element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mArpArray->InsertItemsAt(1, index, inEntry, sizeof(ArpEntry_t));	}	SignalDataEvent( DATA_ID(kArpData, kDataArpArrayOffset + result) );		return result;}// ---------------------------------------------------------------------------------//		¥ GetDataArpArray// ---------------------------------------------------------------------------------// Get element from Arp array at index.// Return false if index is out of range.BooleanCArpData::GetDataArpArray(ArrayIndexT index, ArpEntry_t* outEntry){	return mArpArray->FetchItemAt(index, outEntry);}// ---------------------------------------------------------------------------------//		¥ GetDataCount// ---------------------------------------------------------------------------------//	return number of elements in Arp arrayArrayIndexTCArpData::GetDataCount(){	return mArpArray->GetCount();}// ---------------------------------------------------------------------------------//		¥ SetDataCount// ---------------------------------------------------------------------------------// Set number of elements in Arp array.// Remove any elements after specified count and return count of last element// which could be less than the number requested.ArrayIndexTCArpData::SetDataCount(ArrayIndexT count){	ArrayIndexT	num;	ArrayIndexT result;	ArrayIndexT index;		// remove any elements beyond count	result = count;	num = mArpArray->GetCount();	if (num < count) {		result = num;	}	else if (num > count) {		// remove extras		// (inCount, atIndex)		mArpArray->RemoveItemsAt(num-count, count+1);		// signal corresponding elements have changed		for (index=count+1; index<=num; index++) {			SignalDataEvent( DATA_ID(kArpData, kDataArpArrayOffset + index) );		}	}		return result;}