// ===========================================================================//	CPortMapData.cp			©1998 Sustainable Softworks, All rights reserved.// ===========================================================================// Port Mapping data (corresponds to Port Mapping window)#include "CPortMapData.h"#include "CPortMapConst.h"#include "CConfigDocument.h"#include "IPSupport.h"// Globalsextern CInterfacesData* gInterfacesData;// ---------------------------------------------------------------------------------//		¥ CPortMapData	[Constructor]// ---------------------------------------------------------------------------------CPortMapData::CPortMapData(){	mPortMapArray = nil;	mPortMapEntry.apparent.address = 0;	mPortMapEntry.apparent.port = 0;	mPortMapEntry.age = 0;	mPortMapEntry.actual.address = 0;	mPortMapEntry.actual.port = 0;	mPortMapEntry.flags = kFlagPermanent;	mPortMapEntry.protocol = 0;	mNATaddress = 0;	mPermanentOnly = true;	mPortMapData = nil;	Init();}// ---------------------------------------------------------------------------------//		¥ ~CPortMapData	[Destructor]// ---------------------------------------------------------------------------------CPortMapData::~CPortMapData(){	if (mPortMapArray) delete mPortMapArray;	mPortMapArray = nil;	if (mPortMapData) delete mPortMapData;	mPortMapData = nil;}// ---------------------------------------------------------------------------------//		¥ Init// ---------------------------------------------------------------------------------//	Initialize PortMap data storagevoidCPortMapData::Init(){	UInt32	count;		// PortMap array	if (mPortMapArray == nil) {		// allocate array object if needed		mPortMapArray		= new LArray(sizeof(PortMapEntry_t));		ThrowIfNil_(mPortMapArray);	} else {		// remove any previous elements		count = mPortMapArray->GetCount();		if (count > 0) {			// (inCount, atIndex)			mPortMapArray->RemoveItemsAt(count, 1);		}	}}// ---------------------------------------------------------------------------------//		¥ MatchPortMapEntry// ---------------------------------------------------------------------------------//	Compare two Port Map entries//	Ignore 'flags' and 'age' since were only interested in the mappingBooleanCPortMapData::MatchPortMapEntry(PortMapEntry_t* inEntry1, PortMapEntry_t* inEntry2){	Boolean result = false;	do {		if (inEntry1->apparent.address	!= inEntry2->apparent.address)	break;		if (inEntry1->apparent.port		!= inEntry2->apparent.port)		break;		if (inEntry1->portRange			!= inEntry2->portRange)			break;		if (inEntry1->actual.address	!= inEntry2->actual.address)	break;		if (inEntry1->actual.port		!= inEntry2->actual.port)		break;		if (inEntry1->protocol			!= inEntry2->protocol)			break;		result = true;	} while (false);		return result;}// ---------------------------------------------------------------------------------//		¥ FindMatchPortMapEntry// ---------------------------------------------------------------------------------//	Return index of matching entry, or zero if none foundArrayIndexTCPortMapData::FindMatchPortMapEntry(PortMapEntry_t* inEntry){	ArrayIndexT		numE, row, result;	PortMapEntry_t	portMapEntry;		result = 0;	numE = GetDataCount();	for (row=1; row<=numE; row++) {		if ( !GetDataPortMapArray(row, &portMapEntry) ) continue;		if ( MatchPortMapEntry(inEntry, &portMapEntry) ) {			result = row;			break;		}	}	return result;}// ---------------------------------------------------------------------------------//		¥ PortMapEntryToString// ---------------------------------------------------------------------------------// Convert an PortMap Entry to a text string for exportStringPtrCPortMapData::PortMapEntryToString(PortMapEntry_t* inEntry, Str255 outStr){	LStr255	textStr;	Str31	str;	// add entry	if (inEntry->flags & kFlagActive) textStr = "\p+map";	else textStr = "\p-map";	textStr += kDelimiterStr;			// protocol	switch (inEntry->protocol) {		case kProtocolTCP:			textStr += kProtocolTCPStr;			break;		case kProtocolUDP:			textStr += kProtocolUDPStr;			break;		case kProtocolICMP:			textStr += kProtocolICMPStr;			break;		case kProtocolGRE:			textStr += kProtocolGREStr;			break;		case kProtocolAny:			textStr += kProtocolAnyStr;			break;		default:			NumToString(inEntry->protocol, str);							textStr += str;	}	textStr += kDelimiterStr;	// apparent endpoint	IP_NumToStr(inEntry->apparent.address, str);	textStr += str;	textStr += "\p:";	::NumToString(inEntry->apparent.port, str);	textStr += str;	if (inEntry->portRange) {		textStr += "\p-";		::NumToString(inEntry->apparent.port+inEntry->portRange, str);		textStr += str;	}	textStr += kDelimiterStr;	// actual endpoint	IP_NumToStr(inEntry->actual.address, str);	textStr += str;	textStr += "\p:";	::NumToString(inEntry->actual.port, str);	textStr += str;	if (inEntry->portRange) {		textStr += "\p-";		::NumToString(inEntry->actual.port+inEntry->portRange, str);		textStr += str;	}	textStr += kDelimiterStr;	// age	::NumToString(inEntry->age, str);	textStr += str;	textStr += kDelimiterStr;	// flags	if (inEntry->flags & kFlagStatic) {		textStr += kFlagStaticStr;		textStr += kDelimiterStr;	}	// Don't need other flags for static entries, but display for debugging	if (inEntry->flags & kFlagPermanent) {		textStr += kFlagPermanentStr;		textStr += kDelimiterStr;	}	if (inEntry->flags & kFlagNoRestore) {		textStr += kFlagNoRestoreStr;		textStr += kDelimiterStr;	}	if (inEntry->flags & kFlagDNSForwarding) {		textStr += kFlagDNSForwardingStr;		textStr += kDelimiterStr;	}	return LString::CopyPStr(textStr, outStr, sizeof(Str255));}#pragma mark --- Accessors ---// ---------------------------------------------------------------------------------//		¥ SignalDataChange// ---------------------------------------------------------------------------------// Used to tell our document when data has changedvoidCPortMapData::SignalDataChange(){	SignalDataEvent( DATA_ID(kPortMapData, kDataChange) );}// ---------------------------------------------------------------------------------//		¥ SetDataPortMapEntry// ---------------------------------------------------------------------------------// Set of Get Config Entry (corresponds to parameters in config area of window)voidCPortMapData::SetDataPortMapEntry(PortMapEntry_t* inEntry){	mPortMapEntry = *inEntry;	SignalDataEvent( DATA_ID(kPortMapData, kDataPortMapEntry) );}voidCPortMapData::GetDataPortMapEntry(PortMapEntry_t* outEntry){	*outEntry = mPortMapEntry;}// ---------------------------------------------------------------------------------//		¥ SetDataPortMapArray// ---------------------------------------------------------------------------------// Write element to PortMap array, insert new element if beyond end of array// and return index of where element was written.ArrayIndexTCPortMapData::SetDataPortMapArray(ArrayIndexT index, PortMapEntry_t* inEntry){	ArrayIndexT	count;	ArrayIndexT	result;		count = mPortMapArray->GetCount();	if (index <= count) {		// assign element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mPortMapArray->AssignItemsAt(1, index, inEntry, sizeof(PortMapEntry_t));	} else {		// insert element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mPortMapArray->InsertItemsAt(1, index, inEntry, sizeof(PortMapEntry_t));	}	SignalDataEvent( DATA_ID(kPortMapData, kDataPortMapArrayOffset + result) );		return result;}// ---------------------------------------------------------------------------------//		¥ GetDataPortMapArray// ---------------------------------------------------------------------------------// Get element from PortMap array at index.// Return false if index is out of range.BooleanCPortMapData::GetDataPortMapArray(ArrayIndexT index, PortMapEntry_t* outEntry){	return mPortMapArray->FetchItemAt(index, outEntry);}// ---------------------------------------------------------------------------------//		¥ RemoveDataPortMapArray// ---------------------------------------------------------------------------------// Remove element from PortMap array at index.// Return false if index is out of range.BooleanCPortMapData::RemoveDataPortMapArray(ArrayIndexT index){	Boolean result;		result = mPortMapArray->ValidIndex(index);	if (result) {		mPortMapArray->RemoveItemsAt(1, index);	}	return result;}// ---------------------------------------------------------------------------------//		¥ GetDataCount// ---------------------------------------------------------------------------------//	return number of elements in PortMap arrayArrayIndexTCPortMapData::GetDataCount(){	return mPortMapArray->GetCount();}// ---------------------------------------------------------------------------------//		¥ SetDataCount// ---------------------------------------------------------------------------------// Set number of elements in PortMap array.// Remove any elements after specified count and return count of last element// which could be less than the number requested.ArrayIndexTCPortMapData::SetDataCount(ArrayIndexT count){	ArrayIndexT	num;	ArrayIndexT result;	ArrayIndexT index;		// remove any elements beyond count	result = count;	num = mPortMapArray->GetCount();	if (num < count) {		result = num;	}	else if (num > count) {		// remove extras		// (inCount, atIndex)		mPortMapArray->RemoveItemsAt(num-count, count+1);		// signal corresponding elements have changed		for (index=count+1; index<=num; index++) {			SignalDataEvent( DATA_ID(kPortMapData, kDataPortMapArrayOffset + index) );		}	}		return result;}// ---------------------------------------------------------------------------------//		¥ SetDataPortMapHash// ---------------------------------------------------------------------------------voidCPortMapData::SetDataPortMapHash(UInt32 inValue){	if (inValue != mPortMapHash) {		mPortMapHash = inValue;		SignalDataEvent( DATA_ID(kPortMapData, kDataPortMapHash) );	}}UInt32CPortMapData::GetDataPortMapHash(){	return mPortMapHash;}// ---------------------------------------------------------------------------------//		¥ SetDataNATaddress// ---------------------------------------------------------------------------------voidCPortMapData::SetDataNATaddress(UInt32 inValue){	if (mNATaddress != inValue) {		mNATaddress =  inValue;		SignalDataEvent( DATA_ID(kPortMapData, kDataNATaddress) );			}}UInt32CPortMapData::GetDataNATaddress()			{ return mNATaddress; }// ---------------------------------------------------------------------------------//		¥ FindCurrentNATinterface// ---------------------------------------------------------------------------------//	Find current NAT interface based on portMapHashBooleanCPortMapData::FindCurrentNATinterface(InterfaceEntry_t*	outEntry){	ArrayIndexT			index;	ArrayIndexT			num;	InterfaceEntry_t	entry;	UInt32				theHash;	NetNumber_t			excludeNetwork;	Boolean				result = false;	theHash = GetDataPortMapHash();	if (theHash != 0) {		gInterfacesData->GetDataNATexcludeNetwork(&excludeNetwork);		// scan the interfaces data		num = gInterfacesData->GetDataCount();		for (index=1; index<=num; index++) {			gInterfacesData->GetDataInterfacesArray(index, &entry);			if ((theHash == HashName(entry.portName)) &&				(entry.interfaceAddr != excludeNetwork.address)) {				*outEntry = entry;				result = true;				break;			}		}	}	return result;}// ---------------------------------------------------------------------------------//		¥ SetDataPermanentOnly// ---------------------------------------------------------------------------------voidCPortMapData::SetDataPermanentOnly(Boolean inValue){	if (inValue != mPermanentOnly) {		mPermanentOnly = inValue;		SignalDataEvent( DATA_ID(kPortMapData, kDataPortMapPermanentOnly) );	}}BooleanCPortMapData::GetDataPermanentOnly(){	return mPermanentOnly;}// ---------------------------------------------------------------------------------//		¥ GetDataPermanentCount// ---------------------------------------------------------------------------------ArrayIndexTCPortMapData::GetDataPermanentCount(){	ArrayIndexT	count;	ArrayIndexT	index;	ArrayIndexT	permanentCount;	PortMapEntry_t entry;		count = GetDataCount();	permanentCount = 0;	for (index=1; index<=count; index++) {		if (GetDataPortMapArray(index, &entry)) {			if (entry.flags & kFlagPermanent) permanentCount += 1;		}	}		return permanentCount;}