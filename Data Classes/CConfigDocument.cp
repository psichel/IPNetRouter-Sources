// =================================================================================//	CConfigDocument.cp				©1997 Sustainable Softworks. All Rights Reserved.// =================================================================================#include <LFile.h>#include <LPrintout.h>#include <LPlaceHolder.h>#include <LString.h>#include <LArray.h>#include <LWindow.h>#include <PP_Messages.h>#include <UMemoryMgr.h>#include <UWindows.h>#include <LThread.h>#include <UThread.h>#include "MacSupport.h"#include "IPSupport.h"#include "IPRouterCommon.h"#include "CIPRouterApp.h"#include "CLogAction.h"#include "CConfigDocument.h"#include "CInterfacesWindow.h"#include "CRoutesConst.h"#include "CPortMapAction.h"#include "CPortMapConst.h"#include "CFilterTable.h"#include "CInterfacesData.h"#include "CInterfacesAction.h"#include "CRoutesData.h"#include "CRoutesAction.h"#include "CPortMapData.h"#include "CFilterData.h"#include "CFilterAction.h"#include "CGatewayData.h"#include "CConnectionData.h"#include "CDeviceData.h"#include "CDHCPData.h"// Globalsextern CLogAction*			gLogAction;extern CResidentIfInfo* 	gResInfo;extern CInterfacesData*		gInterfacesData;extern CInterfacesAction*	gInterfacesAction;extern CRoutesData*			gRoutesData;extern CRoutesAction*		gRoutesAction;extern CPortMapData*		gPortMapData;extern CPortMapAction*		gPortMapAction;extern CFilterData*			gFilterData;extern CFilterAction*		gFilterAction;extern CGatewayData*		gGatewayData;extern CConnectionData*		gConnectionData;extern CDeviceData*			gDeviceData;extern CDHCPData*			gDHCPData;extern CIPRouterApp*		gAppObject;extern UInt8				gApplicationMode;// ---------------------------------------------------------------------------------//		¥ CConfigDocument(LCommander*, FSSpec*)// ---------------------------------------------------------------------------------CConfigDocument::CConfigDocument(	LCommander	*inSuper,	FSSpec		*inFileSpec )		: LSingleDoc( inSuper ){	// initialization	mDeleteFile = false;		// reset first PPP attempt	gResInfo->mFirstPPPflag = true;		// Scan OT Port Registry to  make sure we have latest info	gDeviceData->LoadDataDeviceArray();	// Update Interfaces and Routes data in case FBA so window doesn't//	gInterfacesAction->UpdateInterfacesData();//	gRoutesAction->UpdateRoutesData();	// Create window for our document.	mWindow = InvokeWindow(kNameInterfaces, this);	// connect to data classes	gInterfacesData->AddListener(this);	gRoutesData->AddListener(this);	gPortMapData->AddListener(this);	gFilterData->AddListener(this);	gGatewayData->AddListener(this);	gDHCPData->AddListener(this);		// Set name of window or open file.	if (inFileSpec == nil) {		NameNewDoc();				// if not FBA		if (!(gApplicationMode & kModeFBA)) {			// Update Interfaces and Routes data so we are not dependent on If window			gInterfacesAction->UpdateInterfacesData();			gRoutesAction->UpdateRoutesData();			// Make the window visible.			if (mWindow) mWindow->Show();		}					} else {				try {			OpenFile( *inFileSpec );		} catch (const LException& inErr) {			// error opening file, try to tell the user what happened			gLogAction->LogText("\p\rUnable to open or create settings document: ", inErr.GetErrorCode());		}	}}// ---------------------------------------------------------------------------------//		¥ ~CConfigDocument	[Destructor]// ---------------------------------------------------------------------------------CConfigDocument::~CConfigDocument(){		// disconnect from data classes	gInterfacesData->RemoveListener(this);	gRoutesData->RemoveListener(this);	gPortMapData->RemoveListener(this);	gFilterData->RemoveListener(this);	gGatewayData->RemoveListener(this);}// ---------------------------------------------------------------------------------//		¥ NameNewDoc// ---------------------------------------------------------------------------------voidCConfigDocument::NameNewDoc(){	// Setup the document title. Start with the default title.	LStr255	theTitle( "\pUntitled" );		// Finally, set window title or config name	SetConfigName( theTitle );}// ---------------------------------------------------------------------------------//		¥ SetConfigName// ---------------------------------------------------------------------------------//	Save name of configuration filevoidCConfigDocument::SetConfigName(ConstStr255Param inConfigName){	LString::CopyPStr(inConfigName, mConfigName);}// ---------------------------------------------------------------------------------//		¥ GetConfigName// ---------------------------------------------------------------------------------//	Get name of configuration filevoidCConfigDocument::GetConfigName(Str255 outConfigName) const{	LString::CopyPStr(mConfigName, outConfigName);}// ---------------------------------------------------------------------------------//		¥ OpenFile// ---------------------------------------------------------------------------------voidCConfigDocument::OpenFile(	FSSpec	&inFileSpec ){	OTResult result;		try {		mDoQuit = false;		// Create a new file object.		mFile = new LFile( inFileSpec );				// Open the data fork.		mFile->OpenDataFork( fsRdWrPerm );				// Read the entire file and close the file.		Handle	theTextH = mFile->ReadDataFork();		mFile->CloseDataFork();		// Put the contents in data objects		// and clear the dirty flag.		result = ImportFromText( theTextH );					SetModified( false );		// Dispose of the text.		::DisposeHandle( theTextH );		// Set window title to the name of the file.		//mWindow->SetDescriptor( inFileSpec.name );		SetConfigName( inFileSpec.name );				// Flag that document has an associated file.		mIsSpecified = true;		// Delete the file if so requested		// OSErr FSpDelete(const FSSpec *spec);		if (mDeleteFile) {			OSStatus result;			result = ::FSpDelete(&inFileSpec);			mIsSpecified = false;		}				if (mDoQuit) {			ObeyCommand(cmd_Quit, nil);		}		else {			// Handle UponOpen setting unless "Option" key is down					if ((gGatewayData->GetDataUponOpen() == kConfigureDisplay) || OptionKeyDown()) {				// make window visible				if (mWindow) mWindow->Show();			} else {				// no Option key				if (gGatewayData->GetDataUponOpen() == kConfigureQuit) {					// tell App to quit without removing interfaces					ObeyCommand(cmd_Quit, nil);				} else {					// close windows					if (mWindow) mWindow->AttemptClose();					else AttemptClose(true);				}			}		}			} catch (...) {		// Cleanup and rethrow the error.		delete this;		throw;		}}// ---------------------------------------------------------------------------//		¥ AttemptClose// ---------------------------------------------------------------------------//	Try to close a Document.////	The Document might not close if it is modified and the user cancels//	the operation when asked whether to save the changes.voidCConfigDocument::AttemptClose(	Boolean	/* inRecordIt */){	Boolean	closeIt = true;	FSSpec	fileSpec = {1, 1, "\p"};		//if (IsModified()) {	if (false) {		UInt16	answer;		Str63	appName;		::GetIndString(appName, STRx_Standards, str_ProgramName);		Str255	docName;		answer = 0;		::ParamText(appName, GetDescriptor(docName), "\p", "\p");		if (!(gApplicationMode & kModeFBA)) {			UDesktop::Deactivate();			SInt16 answer = ::CautionAlert(ALRT_SaveChangesClosing, nil);			UDesktop::Activate();		}		if (answer == answer_Save) {			if (mIsSpecified) {				DoSave();				SendAEClose(kAEYes, fileSpec, false);							} else {				closeIt = AskSaveAs(fileSpec, false);				if (closeIt) {					SendAEClose(kAEYes, fileSpec, false);				}			}					} else if (answer == answer_Cancel) {			closeIt = false;					} else { // answer == answer_No			SendAEClose(kAENo, fileSpec, false);		}			} else {		SendAEClose(kAENo, fileSpec, false);	}		if (closeIt) {		Close();	}}// ---------------------------------------------------------------------------------//		¥ DoAESave// ---------------------------------------------------------------------------------voidCConfigDocument::DoAESave(	FSSpec	&inFileSpec,	OSType	inFileType ){	// Delete the existing file object.	delete mFile;		// Make a new file object.	mFile = new LFile( inFileSpec );		// Get the proper file type.	OSType	theFileType = 'TEXT';	if ( inFileType != fileType_Default ) theFileType = inFileType;	// Make new file on disk	//	Use IPNLink ('IPnl') as creator	mFile->CreateNewDataFile( 'IPnl', theFileType );		// Write out the data.	DoSave();	// Change window title to reflect the new name.	//mWindow->SetDescriptor( inFileSpec.name );	SetConfigName( inFileSpec.name );	// Document now has a specified file.	mIsSpecified = true;}// ---------------------------------------------------------------------------------//		¥ DoSave// ---------------------------------------------------------------------------------voidCConfigDocument::DoSave(){	// Open the data fork.	mFile->OpenDataFork( fsRdWrPerm );	// Get the text from the text view.	//Handle	theTextH = mTextView->GetTextHandle();		// Count number of interfaces and routes and allocate a big enough block	UInt32 count, size;	count = gInterfacesData->GetDataCount();	size = count * kMaxInterfaceSize;	count = gRoutesData->GetDataCount();	size += count * kMaxRouteSize;	count = gPortMapData->GetDataPermanentCount();	size += count * kMaxPortMapSize;	count = gFilterData->GetDataCount();	size += count * kMaxFilterSize;	count = gDHCPData->GetDataCountDHCPStaticCfg();	size += count * kMaxDHCPSize;	count = gDHCPData->GetDataCountDHCPDynamicCfg();	size += count * kMaxDHCPSize;	count = gDHCPData->GetDataCountDHCPLeaseData();	size += count * kMaxDHCPSize;		size += 200;						// extra for command overhead	Handle theTextH = ::NewHandle(size);	ThrowIfMemFail_(theTextH);	if (theTextH == nil) {		OSErr err = ::MemError();		gLogAction->LogText("\p\rMemory error while saving configuration", err);	}	else {		// output text to buffer		SInt32 outSize = ExportToText( theTextH );		if (outSize > 0) {				// Lock the text handle.			StHandleLocker	theLock( theTextH );						// Write the text to the file.			mFile->WriteDataFork( *theTextH, outSize );		}		else {			gLogAction->LogText("\p\rExport to text buffer too small");				}		// Close the data fork.		mFile->CloseDataFork();		// Dispose of the text.		::DisposeHandle( theTextH );		// Saving makes doc un-dirty.		SetModified( false );	}}// ---------------------------------------------------------------------------------//		¥ DoRevert// ---------------------------------------------------------------------------------voidCConfigDocument::DoRevert(){	// Open the data fork.	mFile->OpenDataFork( fsRdWrPerm );	// Read the entire file contents and close the file.	Handle	theTextH = mFile->ReadDataFork();	mFile->CloseDataFork();		// Put the contents in data objects	// and clear the dirty flag.	ImportFromText( theTextH );	SetModified( false );		// Dispose of the text.	::DisposeHandle( theTextH );	// Refresh the text view.//	mTextView->Refresh();}// ---------------------------------------------------------------------------------//		¥ FindCommandStatus// ---------------------------------------------------------------------------------voidCConfigDocument::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	UInt16		&outMark,	Str255		outName ){	switch ( inCommand ) {	//		case cmd_Print://		case cmd_PrintOne://		{//			// Short circuit the printing commands//			// since this example doesn't print.//			outEnabled = false;//		}//		break;		default:		{			// Call inherited.			LSingleDoc::FindCommandStatus( inCommand,				outEnabled, outUsesMark, outMark, outName );		}		break;	}}// ---------------------------------------------------------------------------//		¥ GetDescriptor// ---------------------------------------------------------------------------//	Pass back the name of a DocumentStringPtrCConfigDocument::GetDescriptor(	Str255	outDescriptor) const{	if ((mFile != nil) && mIsSpecified) {		FSSpec	fileSpec;			// Document name is same as its File		mFile->GetSpecifier(fileSpec);		LString::CopyPStr(fileSpec.name, outDescriptor);	//	} else if (mWindow != nil) {	// No File, use name of its Window//		mWindow->GetDescriptor(outDescriptor);	} else {	// No File, use config name		GetConfigName(outDescriptor);		}		return outDescriptor;}BooleanCConfigDocument::AllowSubRemoval(	LCommander	*inSub){	if (inSub == mWindow) {				// Check if the current AppleEvent is a "close" event			// sent to the Window. If so, we handle it as if the			// "close" event were sent to the Document			 		AppleEvent	currentEvent;		DescType	theType;		DescType	theAttr = typeNull;		Size		theSize;		::AEGetTheCurrentEvent(&currentEvent);		if (currentEvent.descriptorType != typeNull) {			::AEGetAttributePtr(&currentEvent, keyEventClassAttr,				typeType, &theType, &theAttr, sizeof(DescType),				&theSize);			if (theAttr == kAECoreSuite) {				::AEGetAttributePtr(&currentEvent, keyEventIDAttr,					typeType, &theType, &theAttr, sizeof(DescType),					&theSize);				if (theAttr == kAEClose) {					DoAEClose(currentEvent);					return false;				}			}		}				AttemptClose(true);			// A non-AppleEvent close		return false;	} else {		return true;	}}// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------// Handle notification when data in a data class changesvoidCConfigDocument::ListenToMessage(	MessageT	inMessage,	void		*ioParam ){	switch ( inMessage ) {				case msg_SignalDataEvent:			UInt32 dataID = *(UInt32*)ioParam;			switch (dataID) {				case DATA_ID(kGatewayData, kDataIPforwarding):				case DATA_ID(kGatewayData, kDataUponOpen):				case DATA_ID(kGatewayData, kDataExposedHost):				case DATA_ID(kGatewayData, kDataExposedHostAddress):				case DATA_ID(kGatewayData, kDataDialupDNS):				case DATA_ID(kGatewayData, kDataDialupUsername):				case DATA_ID(kGatewayData, kDataDialupPassword):				case DATA_ID(kGatewayData, kDataDisconnectAtQuit):				case DATA_ID(kGatewayData, kDataDialOnDemand):				case DATA_ID(kGatewayData, kDataShowPPPdialogs):				case DATA_ID(kGatewayData, kDataEnableLocalNAT):				case DATA_ID(kGatewayData, kDataDNSForwarding):				case DATA_ID(kGatewayData, kDataLimitMTUForPPPoE):				case DATA_ID(kGatewayData, kDataTRCableModem):								case DATA_ID(kInterfacesData, kDataChange):				case DATA_ID(kRoutesData, kDataChange):				case DATA_ID(kPortMapData, kDataChange):				case DATA_ID(kFilterData, kDataChange):				case DATA_ID(kGatewayData, kDataChange):				case DATA_ID(kDHCPStatusData, kDataChange):					SetModified(true);					break;			}			break;	}}#pragma mark -- import/export --// ---------------------------------------------------------------------------------//		¥ ImportFromText// ---------------------------------------------------------------------------------//	Read text from handle and store corresponding config data in//	data objects////	Format of text file is as follows://		#command				! a command keyword//		+i <param>...			! interface spec, bring up//		-i <param>...			! interface spec, don't bring up//		+r <param>...			! add route//		-r <param>...			! delete route//		<not+or->				! a comment line//		#end					! end of data in file//SInt32CConfigDocument::ImportFromText(Handle inTextH){	OSStatus	result = kOTNoError;	UInt8*		dp;	SInt32		start, end, pos, eol;	SInt32		ifIndex, rtIndex, portMapIndex, filterIndex;	SInt32		staticCfgIndex, dynamicCfgIndex, leaseDataIndex;	long		theNum;	DeviceEntry_t	info;	Boolean		foundInfo;	Str255		str;	// data class elements	InterfaceEntry_t	interfaceEntry;	RouteEntry_t		routesEntry;	PortMapEntry_t		portMapEntry;	FilterEntry_t		filterEntry;		// get length of text we read in	end = ::GetHandleSize(inTextH);		// end = one past last char	// temporary data class for saved Interfaces	if (gInterfacesData->mInterfacesData == nil) {		gInterfacesData->mInterfacesData = new CInterfacesData();		ThrowIfNil_(gInterfacesData->mInterfacesData);	} else gInterfacesData->mInterfacesData->Init();	// temporary data class for saved routes	if (gRoutesData->mRoutesData == nil) {		gRoutesData->mRoutesData = new CRoutesData();		ThrowIfNil_(gRoutesData->mRoutesData);	} else gRoutesData->mRoutesData->Init();	// temporary data class for saved port map data	// port map data is reloaded each time masquerading is enabled	// but we still might need a temporary class during restore.	if (gPortMapData->mPortMapData == nil) {		gPortMapData->mPortMapData = new CPortMapData();		ThrowIfNil_(gPortMapData->mPortMapData);	} else gPortMapData->mPortMapData->Init();	// temporary data class for saved filters	if (gFilterData->mFilterData == nil) {		gFilterData->mFilterData = new CFilterData();		ThrowIfNil_(gFilterData->mFilterData);	} else gFilterData->mFilterData->Init();	// setup to initialize defaults that are not seen unless addOnly	Boolean	seenUponOpen = false;	Boolean seenIPforwarding = false;	Boolean seenExposedHost = false;	Boolean seenDialupDNS = false;	Boolean	seenRemainConnected = false;	Boolean seenDisconnectAtQuit = false;	Boolean seenShowPPPdialogs = false;	Boolean seenEnableLocalNAT = false;	Boolean seenDNSForwarding = false;	Boolean seenLimitMTUForPPPoE = false;	Boolean seenTRCableModem = false;	Boolean seenDialOnDemand = false;	Boolean seenExcludeFromNAT = false;	Boolean	seenAddOnly = false;	// remember DHCP commands for later	gDHCPData->mSeenDHCPServerOn = false;	gDHCPData->mSeenDHCPVerboseLogging = false;	// begin scanning text	ifIndex = 0;	rtIndex = 0;	portMapIndex = 0;	filterIndex = 0;	staticCfgIndex = 0;	dynamicCfgIndex = 0;	leaseDataIndex = 0;	start = 0;	while (start < end) {		// get pointer to text (dereference handle in case it moved)		dp = (UInt8*)(*inTextH);				// look at first character of line		// check for command		if (dp[start] == '#') {        	UInt8* cp;        	UInt32 len;			// Get command			cp = &dp[start];			eol = FindByte('\r', dp, start, end);			// look for end command			if ((eol == 0) || (eol-start > 254)) break;			LStr255 cmdStr( &dp[start], (UInt8)(eol-start) );			len = eol-start;			start = eol + 1;								// advance to get next line			cmdStr.SetCompareFunc(LString::CompareIgnoringCase);	// ignore case            // #set/keyword=value/			if (cmdStr.BeginsWith(kSetStr)) {			    LStr255 nameStr;			    Str31 valueStr;        		UInt32 value;        		pos = 1;                // skip #set/       			pos = FindByte(kDelimiterChar, cp, pos, len);       			if (pos == 0) continue;       			// get parameters           		do {           			// keyword value pair           			pos += 1;           			pos = GetParamString(cp, pos, len, nameStr);           			if (pos == 0) break;           			GetKeywordValue(nameStr, valueStr);                    // match keyword                        // Exposed Host Address                    if (nameStr.BeginsWith(kExposedHostAddressStr)) {        				value = IP_StrToInt(valueStr);        				gGatewayData->SetDataExposedHost(kExposedHostAddress);        				gGatewayData->SetDataExposedHostAddress(value);        				seenExposedHost = true;                    }                        // DHCP Verbose Logging                    if (nameStr.BeginsWith(kDHCPVerboseLoggingStr)) {        				if (::EqualString(valueStr, kValueOnStr, false, false)) {                            gDHCPData->mSeenDHCPVerboseLogging = true;                        }                    }                        // PPP Name                    if (nameStr.BeginsWith(kPPPNameStr)) {        				LString::CopyPStr(valueStr, gResInfo->mPPPName);                    }                        // Gateway Settings                        // ExcludeFromNAT                    if (nameStr.BeginsWith(kExcludeFromNATStr)) {                        if (::EqualString(valueStr, kValueOnStr, false, false))                            gGatewayData->SetDataExcludeFromNAT(true);                        seenExcludeFromNAT = true;                    }                        // ExcludeNet                    if (nameStr.BeginsWith(kExcludeNetStr)) {                        NetNumber_t net;                        UInt8 len = IPprefixLen_StrToInt(valueStr);                        net.address = IP_StrToInt(valueStr);                        net.mask = 0xFFFFFFFF << (32-len);                        gGatewayData->SetDataExcludeNet(&net);                    }               } while (pos < len);            }			else if (cmdStr.BeginsWith(kConfigureQuitStr)) {				gGatewayData->SetDataUponOpen(kConfigureQuit);				seenUponOpen = true;			}			else if (cmdStr.BeginsWith(kConfigureDisplayStr)) {				gGatewayData->SetDataUponOpen(kConfigureDisplay);				seenUponOpen = true;			}			else if (cmdStr.BeginsWith(kConfigureOnlyStr)) {				gGatewayData->SetDataUponOpen(kConfigureOnly);				seenUponOpen = true;			}			else if (cmdStr.BeginsWith("\p#end")) break;			// end of config data			else if (cmdStr.BeginsWith(kForwardingAlwaysStr)) {				gGatewayData->SetDataIPforwarding(kForwardingAlways);				seenIPforwarding = true;			}			else if (cmdStr.BeginsWith(kForwardingAutomaticStr)) {				gGatewayData->SetDataIPforwarding(kForwardingAutomatic);				seenIPforwarding = true;			}			else if (cmdStr.BeginsWith(kForwardingNeverStr)) {				gGatewayData->SetDataIPforwarding(kForwardingNever);				seenIPforwarding = true;			}			// exposed host			else if (cmdStr.BeginsWith(kExposedHostNoneStr)) {				gGatewayData->SetDataExposedHost(kExposedHostNone);				seenExposedHost = true;			}			else if (cmdStr.BeginsWith(kExposedHostGatewayStr)) {				gGatewayData->SetDataExposedHost(kExposedHostGateway);				seenExposedHost = true;			}			else if (cmdStr.BeginsWith(kExposedHostAddressStr)) {				UInt32 value;				GetKeywordValue(cmdStr, str);				value = IP_StrToInt(str);				gGatewayData->SetDataExposedHost(kExposedHostAddress);				gGatewayData->SetDataExposedHostAddress(value);				seenExposedHost = true;			}			// dialupDNS=Username^Password			else if (cmdStr.BeginsWith(kDialupDNSOffStr)) {				gGatewayData->SetDataDialupDNS(false);				seenDialupDNS = true;			}			else if (cmdStr.BeginsWith(kDialupDNSStr)) {				LStr255 loginStr;				UInt8 posA;				// get login string Username^Password				if (GetKeywordValue(cmdStr, str)) {					loginStr = str;					posA = loginStr.Find('^');					if (posA != 0) {						loginStr.Assign( loginStr, posA+1 );	// password						str[0] = posA-1;					// username						gGatewayData->SetDataDialupUsername(str);						gGatewayData->SetDataDialupPassword(loginStr);						// enable dialupDNS only if we have login parameters						gGatewayData->SetDataDialupDNS(true);						seenDialupDNS = true;											}				}			}			// remain connected			else if (cmdStr.BeginsWith(kRemainConnectedStr)) {				gGatewayData->SetDataRemainConnected(true);				seenRemainConnected = true;			}			else if (cmdStr.BeginsWith(kDisconnectAtQuitOffStr)) {				gGatewayData->SetDataDisconnectAtQuit(false);				seenDisconnectAtQuit = true;			}			else if (cmdStr.BeginsWith(kDisconnectAtQuitStr)) {				gGatewayData->SetDataDisconnectAtQuit(true);				seenDisconnectAtQuit = true;			}			else if (cmdStr.BeginsWith(kDisconnectStr)) {				gResInfo->DisconnectPPP(nil);			}			else if (cmdStr.BeginsWith(kConnectStr)) {				gResInfo->ConnectPPP(nil);			}			else if (cmdStr.BeginsWith(kPPPNameStr)) {				GetKeywordValue(cmdStr, gResInfo->mPPPName);							}			else if (cmdStr.BeginsWith(kShowPPPdialogsOffStr)) {				gGatewayData->SetDataShowPPPdialogs(false);				seenShowPPPdialogs = true;			}			else if (cmdStr.BeginsWith(kShowPPPdialogsStr)) {				gGatewayData->SetDataShowPPPdialogs(true);				seenShowPPPdialogs = true;			}			else if (cmdStr.BeginsWith(kEnableLocalNATOffStr)) {				gGatewayData->SetDataEnableLocalNAT(false);				seenEnableLocalNAT = true;			}			else if (cmdStr.BeginsWith(kEnableLocalNATStr)) {				gGatewayData->SetDataEnableLocalNAT(true);				seenEnableLocalNAT = true;			}			else if (cmdStr.BeginsWith(kDNSForwardingOffStr)) {				gGatewayData->SetDataDNSForwarding(false);				seenDNSForwarding = true;			}			else if (cmdStr.BeginsWith(kDNSForwardingStr)) {				gGatewayData->SetDataDNSForwarding(true);				seenDNSForwarding = true;			}			else if (cmdStr.BeginsWith(kLimitMTUForPPPoEOffStr)) {				gGatewayData->SetDataLimitMTUForPPPoE(false);				seenLimitMTUForPPPoE = true;			}			else if (cmdStr.BeginsWith(kLimitMTUForPPPoEStr)) {				gGatewayData->SetDataLimitMTUForPPPoE(true);				seenLimitMTUForPPPoE = true;			}			else if (cmdStr.BeginsWith(kTRCableModemOffStr)) {				gGatewayData->SetDataTRCableModem(false);				seenTRCableModem = true;			}			else if (cmdStr.BeginsWith(kTRCableModemStr)) {				gGatewayData->SetDataTRCableModem(true);				seenTRCableModem = true;			}			else if (cmdStr.BeginsWith(kDialOnDemandOffStr)) {				gGatewayData->SetDataDialOnDemand(false);				seenDialOnDemand = true;			}			else if (cmdStr.BeginsWith(kDialOnDemandStr)) {				gGatewayData->SetDataDialOnDemand(true);				seenDialOnDemand = true;			}			else if (cmdStr.BeginsWith(kAddOnlyStr)) {				gGatewayData->SetDataAddOnly(true);				seenAddOnly = true;			}			else if (cmdStr.BeginsWith(kDeleteStr)) {				mDeleteFile = true;			}			else if (cmdStr.BeginsWith(kQuitStr)) {				mDoQuit = true;			}			else if (cmdStr.BeginsWith(kDHCPServerOnStr)) {				gDHCPData->mSeenDHCPServerOn = true;			}			else if (cmdStr.BeginsWith(kDHCPVerboseLoggingStr)) {				gDHCPData->mSeenDHCPVerboseLogging = true;			}			else if (cmdStr.BeginsWith(kEndStr)) {				break;			}			continue;		}		// skip comments		if ((dp[start] != '+') && (dp[start] != '-')) {			pos = FindByte('\r', dp, start, end);			if (pos) {				start = pos + 1;	// advance to next				continue;			}			else break;	// if not found, exit		}				// first char is + or -		// find end of line		eol = FindByte('\r', dp, start, end);		if ((eol == 0) || (eol-start > 255)) break;		// get data from file and store in data objects		pos = start + 1;		if (dp[pos] == 'i') {			// get interface element			bzero((UInt8*)&interfaceEntry, sizeof(InterfaceEntry_t));			interfaceEntry.bringUp = (dp[start] == '+');			interfaceEntry.isDone = false;			// skip "+/-interface"			pos = FindByte(kDelimiterChar, dp, start, end);			if ((pos == 0) || (pos > eol)) break;			// get portName parameter (userPortName or portName)			start = pos + 1;			pos = GetParamString(dp, start, end, interfaceEntry.userPortName);			if ((pos == 0) || (pos > eol)) break;			// check for actual or user port name			foundInfo = gDeviceData->FindDataDeviceArray(nil, interfaceEntry.userPortName, nil, &info);			if (foundInfo) {				LString::CopyPStr(interfaceEntry.userPortName, interfaceEntry.portName);				LString::CopyPStr(info.userPortName, interfaceEntry.userPortName);			} else {				foundInfo = gDeviceData->FindDataDeviceArray(interfaceEntry.userPortName, nil, nil, &info);				if (foundInfo) {					LString::CopyPStr(info.portName, interfaceEntry.portName);				}			}			// get interfaceName			start = pos + 1;			pos = GetParamString(dp, start, end, interfaceEntry.interfaceName);			if ((pos == 0) || (pos > eol)) break;				// fill in missing interface name if known			if (foundInfo && (interfaceEntry.interfaceName[0] == 0)) {				LString::CopyPStr(info.interfaceName, interfaceEntry.interfaceName);			}			// get interfaceAddr			start = pos + 1;			pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;			interfaceEntry.interfaceAddr = IP_StrToInt(str);			// get netMask					start = pos+1;			pos = GetParamString(dp, start, end, str);			interfaceEntry.netMask = 0;			if ((pos > 0) && (pos <= eol)) {				interfaceEntry.netMask = IP_StrToInt(str);			}			// Need Gateway?			interfaceEntry.needGateway = false;			if (interfaceEntry.interfaceAddr == 0) {				if (foundInfo && info.needPPP) interfaceEntry.needGateway = true;			}			// masquerading, unnumbered, dhcp?			interfaceEntry.masquerading = false;			interfaceEntry.unnumbered = false;			interfaceEntry.dhcp = false;			interfaceEntry.wamnet = false;			interfaceEntry.mtu = 0;			while ((pos > 0) && (pos < eol)) {				start = pos+1;				pos = GetParamString(dp, start, end, str);				if (::EqualString(str, kMasqueradingStr, false, false))					interfaceEntry.masquerading = true;				else if (::EqualString(str, kUnnumberedStr, false, false))					interfaceEntry.unnumbered = true;				else if (::EqualString(str, kDhcpStr, false, false))					interfaceEntry.dhcp = true;				else if (::EqualString(str, kNoGatewayStr, false, false))					interfaceEntry.needGateway = false;				else if (::EqualString(str, kWamnetStr, false, false))					interfaceEntry.wamnet = true;				else {					Str31 paramStr;					if ( BeginsWith(str, kMtuStr) && GetKeywordValue(str, paramStr) ) {						::StringToNum(paramStr, &theNum);						interfaceEntry.mtu = theNum;					}				}			}			// insert element in ifData array			//	(inCount, inAtIndex, *inItem, inItemSize)			ifIndex += 1;			gInterfacesData->mInterfacesData->SetDataInterfacesArray(ifIndex, &interfaceEntry);					} else if (dp[pos] == 'r') {			// get route element			bzero((UInt8*)&routesEntry, sizeof(RouteEntry_t));			routesEntry.addRoute = (dp[start] == '+');			routesEntry.isDone = false;			// skip "+/-route"			pos = FindByte(kDelimiterChar, dp, start, end);			if ((pos == 0) || (pos > eol)) break;			// get routeType			start = pos + 1;			pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;			     if (::EqualString(str, kStrDirect, false, false))			     	routesEntry.routeType = IRE_RESOLVER;			else if (::EqualString(str, kStrPointToPoint, false, false))					routesEntry.routeType = IRE_SUBNET;			else if (::EqualString(str, kStrDefaultGateway, false, false))					routesEntry.routeType = IRE_GATEWAY;			else if (::EqualString(str, kStrNetwork, false, false))					routesEntry.routeType = IRE_NET;			else if (::EqualString(str, kStrHost, false, false))					routesEntry.routeType = IRE_ROUTE_ASSOC;			// get destination			start = pos + 1;			pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;			routesEntry.destination = IP_StrToInt(str);			UInt8 len = IPprefixLen_StrToInt(str);			routesEntry.netMask = 0xFFFFFFFF << (32 - len);			// get gateway					start = pos + 1;			pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;			routesEntry.gateway = IP_StrToInt(str);			// wamnet?			routesEntry.wamnet = false;			while ((pos > 0) && (pos < eol)) {				start = pos+1;				pos = GetParamString(dp, start, end, str);				if (::EqualString(str, kWamnetStr, false, false))					routesEntry.wamnet = true;			}			// insert element in RoutesData array			//	(inCount, inAtIndex, *inItem, inItemSize)			rtIndex += 1;			gRoutesData->mRoutesData->SetDataRoutesArray(rtIndex, &routesEntry);					} else if (dp[pos] == 'm') {			// get port map entry			bzero((UInt8*)&portMapEntry, sizeof(PortMapEntry_t));			if (dp[start] == '+') portMapEntry.flags |= kFlagActive;			portMapEntry.flags |= kFlagPermanent;	// we only save & restore static entries			// skip "+/-map"			pos = FindByte(kDelimiterChar, dp, start, end);			if ((pos == 0) || (pos > eol)) break;			// get protocol			start = pos + 1;			pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;			     if (::EqualString(str, kProtocolTCPStr, false, false))			     	portMapEntry.protocol = kProtocolTCP;			else if (::EqualString(str, kProtocolUDPStr, false, false))					portMapEntry.protocol = kProtocolUDP;			else if (::EqualString(str, kProtocolICMPStr, false, false))					portMapEntry.protocol = kProtocolICMP;			else if (::EqualString(str, kProtocolGREStr, false, false))					portMapEntry.protocol = kProtocolGRE;			else if (::EqualString(str, kProtocolAnyStr, false, false))					portMapEntry.protocol = kProtocolAny;			else {				::StringToNum(str, &theNum);				portMapEntry.protocol = theNum;			}			// get apparent endpoint (addr:port)			start = pos + 1;			pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;			UInt16 portA, portB;			Endpoint_StrToInt(str, &portMapEntry.apparent.address, &portA, &portB);			portMapEntry.apparent.port = portA;			if (portB > portA) portMapEntry.portRange = portB - portA;			// get actual endpoint (addr:port)					start = pos + 1;			pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;			Endpoint_StrToInt(str, &portMapEntry.actual.address, &portA, &portB);			portMapEntry.actual.port = portA;			// get age					start = pos + 1;			pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;			::StringToNum(str, &theNum);			portMapEntry.age = theNum;			// wamnet?			while ((pos > 0) && (pos < eol)) {				start = pos+1;				pos = GetParamString(dp, start, end, str);				if (::EqualString(str, kWamnetStr, false, false))					portMapEntry.flags |= kFlagWamnet;				if (::EqualString(str, kFlagStaticStr, false, false))					portMapEntry.flags |= kFlagStatic;			}			// insert element in portMapData array			//	(inCount, inAtIndex, *inItem, inItemSize)			portMapIndex += 1;			gPortMapData->mPortMapData->SetDataPortMapArray(portMapIndex, &portMapEntry);					} else if (dp[pos] == 'f') {			// get filter entry			bzero((UInt8*)&filterEntry, sizeof(FilterEntry_t));			if (dp[start] == '+') filterEntry.flags |= kFlagFilterActive;			// skip "+/-filter"			pos = FindByte(kDelimiterChar, dp, start, end);			if ((pos == 0) || (pos > eol)) break;			// filter port			start = pos + 1;			pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;				// try to match actual port name			if (gDeviceData->FindDataDeviceArray(nil, str, nil, &info)) {				filterEntry.portName = HashName(info.portName);			}				// try to match user port name			else if (gDeviceData->FindDataDeviceArray(str, nil, nil, &info)) {				filterEntry.portName = HashName(info.portName);			}				// no port name found			else filterEntry.portName = HashName(str);			// filter direction			start = pos + 1;			pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;			if (::EqualString(str, kDirectionReadStr, false, false))				filterEntry.flags |= kFlagDirectionRead;			// filter action			start = pos + 1;			pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;			if (::EqualString(str, kActionRejectStr, false, false))				filterEntry.flags |= kFilterReject << 1;			if (::EqualString(str, kActionOldRejectStr, false, false))				filterEntry.flags |=  kFilterReject << 1;			if (::EqualString(str, kActionNoDialStr, false, false))				filterEntry.flags |= kFilterNoDial << 1;			if (::EqualString(str, kActionTriggerStr, false, false))				filterEntry.flags |= kFilterTrigger << 1;			if (::EqualString(str, kActionLogStr, false, false))				filterEntry.flags |= kFilterLog << 1;			// get protocol			start = pos + 1;			pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;			     if (::EqualString(str, kProtocolTCPStr, false, false))			     	filterEntry.protocol = kProtocolTCP;			else if (::EqualString(str, kProtocolUDPStr, false, false))					filterEntry.protocol = kProtocolUDP;			else if (::EqualString(str, kProtocolICMPStr, false, false))					filterEntry.protocol = kProtocolICMP;			else if (::EqualString(str, kProtocolGREStr, false, false))					filterEntry.protocol = kProtocolGRE;			else if (::EqualString(str, kProtocolAnyStr, false, false))					filterEntry.protocol = kProtocolAny;			else {				::StringToNum(str, &theNum);				filterEntry.protocol = theNum;			}			// Ack Flag			start = pos + 1;			pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;			if (::EqualString(str, kFlagAckStr, false, false))				filterEntry.flags |= kFlagAck;			else if (::EqualString(str, kFlagNoAckStr, false, false))				filterEntry.flags |= kFlagNoAck;			// sourceNet			start = pos + 1;			pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;			filterEntry.sourceNet.address = IP_StrToInt(str);			UInt8 len = IPprefixLen_StrToInt(str);			filterEntry.sourceNet.mask = 0xFFFFFFFF << (32 - len);			// sourcePorts			filterEntry.sourcePorts.lo = 0;			filterEntry.sourcePorts.hi = 0;			start = pos + 1;			pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;			{				LStr255 theString;				LStr255 part;				UInt8	position;				SInt32	portNum;				theString = str;				// check for "-" indicating A-B				position = theString.Find('-');				if (position != 0) {					part.Assign(theString, 1, position-1);						if ( IsDigitString(part) ) {						::StringToNum(part, &portNum);						filterEntry.sourcePorts.lo = portNum;					}					part.Assign(theString, position+1);						if ( IsDigitString(part) ) {						::StringToNum(part, &portNum);						filterEntry.sourcePorts.hi = portNum;					}				} else {	// no "-", get port# if any					if ( IsDigitString(str) ) {						::StringToNum(str, &portNum);						filterEntry.sourcePorts.lo = portNum;					}								}			}			// destNet			start = pos + 1;			pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;			filterEntry.destNet.address = IP_StrToInt(str);			len = IPprefixLen_StrToInt(str);			filterEntry.destNet.mask = 0xFFFFFFFF << (32 - len);			// destPorts			filterEntry.destPorts.lo = 0;			filterEntry.destPorts.hi = 0;			start = pos + 1;			pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;			{				LStr255 theString;				LStr255 part;				UInt8	position;				SInt32 portNum;				theString = str;				// check for "-" indicating A-B				position = theString.Find('-');				if (position != 0) {					part.Assign(theString, 1, position-1);						if ( IsDigitString(part) ) {						::StringToNum(part, &portNum);						filterEntry.destPorts.lo = portNum;					}					part.Assign(theString, position+1);						if ( IsDigitString(part) ) {						::StringToNum(part, &portNum);						filterEntry.destPorts.hi = portNum;					}				} else {	// no "-", get port# if any					if ( IsDigitString(str) ) {						::StringToNum(str, &portNum);						filterEntry.destPorts.lo = portNum;					}								}			}			// WAMNET flag			while ((pos > 0) && (pos < eol)) {				start = pos+1;				pos = GetParamString(dp, start, end, str);				if (::EqualString(str, kWamnetStr, false, false))					filterEntry.flags |= kFlagWamnet;			}			// set EntryID to zero			filterEntry.entryID = 0;			// insert element in FilterData array			filterIndex += 1;			gFilterData->mFilterData->SetDataFilterArray(filterIndex, &filterEntry);		}				else if (dp[pos] == 'd') {			// get dhcp entry			DHCPStaticCfgEntry_t	staticCfgEntry;			DHCPDynamicCfgEntry_t	dynamicCfgEntry;			DHCPLeaseDataEntry_t	leaseDataEntry;						pos = GetParamString(dp, start, end, str);			if ((pos == 0) || (pos > eol)) break;			if (EqualString(str, kDHCPStaticCfgStr, false, false)) {				// get StaticCfg entry				if (gDHCPData->TextToStaticCfgEntry(dp, start, eol, &staticCfgEntry)) {					// insert element in status array					if (seenAddOnly) staticCfgIndex = gDHCPData->GetDataCountDHCPStaticCfg();					staticCfgIndex += 1;					gDHCPData->SetDataDHCPStaticCfgArray(staticCfgIndex, &staticCfgEntry);					str[0] = gDHCPData->StaticCfgEntryToText(&staticCfgEntry, &str[1], 254);					if (str[0]) {						gLogAction->LogText("\p\r ");						gLogAction->LogText(str);					}				}			}			else if (EqualString(str, kDHCPDynamicCfgStr, false, false)) {				// get DynamicCfg entry				if (gDHCPData->TextToDynamicCfgEntry(dp, start, eol, &dynamicCfgEntry)) {					// insert element in status array					if (seenAddOnly) dynamicCfgIndex = gDHCPData->GetDataCountDHCPDynamicCfg();					dynamicCfgIndex += 1;					gDHCPData->SetDataDHCPDynamicCfgArray(dynamicCfgIndex, &dynamicCfgEntry);					str[0] = gDHCPData->DynamicCfgEntryToText(&dynamicCfgEntry, &str[1], 254);					if (str[0]) {						gLogAction->LogText("\p\r ");						gLogAction->LogText(str);					}				}			}			else if (EqualString(str, kDHCPLeaseDataStr, false, false) ||					 EqualString(str, kDHCPmLeaseDataStr, false, false)) {				// get LeaseData entry				if (gDHCPData->TextToLeaseDataEntry(dp, start, eol, &leaseDataEntry)) {					// insert element in status array					if (seenAddOnly) leaseDataIndex = gDHCPData->GetDataCountDHCPLeaseData();					leaseDataIndex += 1;					gDHCPData->SetDataDHCPLeaseDataArray(leaseDataIndex, &leaseDataEntry);					str[0] = gDHCPData->LeaseDataEntryToText(&leaseDataEntry, &str[1], 254);					if (str[0]) {						gLogAction->LogText("\p\r ");						gLogAction->LogText(str);					}				}			}		}		// advance to get next line		start = eol + 1;	}	// while scanning (start < end)	if (!mDoQuit) {		// initialize defaults that were not seen unless "addOnly"		if (!seenAddOnly) {		// not addOnly			gGatewayData->SetDataAddOnly(false);			if (!seenUponOpen)			gGatewayData->SetDataUponOpen(kConfigureDisplay);			if (!seenIPforwarding)		gGatewayData->SetDataIPforwarding(kForwardingAutomatic);			if (!seenExposedHost)		gGatewayData->SetDataExposedHost(kExposedHostGateway);			if (!seenDialupDNS)			gGatewayData->SetDataDialupDNS(false);			if (!seenRemainConnected)	gGatewayData->SetDataRemainConnected(false);			if (!seenDisconnectAtQuit)	gGatewayData->SetDataDisconnectAtQuit(false);			if (!seenShowPPPdialogs)	gGatewayData->SetDataShowPPPdialogs(false);			if (!seenEnableLocalNAT)	gGatewayData->SetDataEnableLocalNAT(false);			if (!seenLimitMTUForPPPoE)	gGatewayData->SetDataLimitMTUForPPPoE(true);			if (!seenTRCableModem)		gGatewayData->SetDataTRCableModem(false);			if (!seenDialOnDemand)		gGatewayData->SetDataDialOnDemand(true);			if (!seenExcludeFromNAT)	gGatewayData->SetDataExcludeFromNAT(false);			if (!seenDNSForwarding) {				if (gApplicationMode & kModeApple) gGatewayData->SetDataDNSForwarding(true);				else gGatewayData->SetDataDNSForwarding(false);			}		}		// finish loading DHCP configuration		gDHCPData->SetDataCountDHCPStaticCfg(staticCfgIndex);		gDHCPData->SetDataCountDHCPDynamicCfg(dynamicCfgIndex);		gDHCPData->SetDataCountDHCPLeaseData(leaseDataIndex);				// Create thread to step through load sequence		// Call gResInfo to be Object Master so this document can go away		gResInfo->DoRestore();	}	// !mDoQuit	return result;}// ---------------------------------------------------------------------------------//		¥ ExportToText// ---------------------------------------------------------------------------------//	Get data from data objects and store as text in specified handle.//	Returns number of bytes written to buffer or -1 if buffer is too small.SInt32CConfigDocument::ExportToText(Handle inTextH){	UInt8*	dp;	SInt32	start, end;	LStr255	paramStr;	Str255	str;	UInt32 value;		end = ::GetHandleSize(inTextH);		// end = one past last char	// start at beginning of text buffer	start = 0;	// get vers resource	StResource versData( (ResType)'vers', 1, false, false );	// (...inThrowFail, inCurrResOnly)	if (versData.mResourceH) {		// display version info		paramStr = "\p! IPNetRouter ";		paramStr += (unsigned char*)&(*versData.mResourceH)[6];#if powerc		paramStr += "\p PPC";#else		paramStr += "\p 68K";#endif		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}    // Gateway Settings	// check for upon open setting	if (gGatewayData->GetDataUponOpen() == kConfigureQuit) {		paramStr = kConfigureQuitStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}	else if (gGatewayData->GetDataUponOpen() == kConfigureOnly) {		paramStr = kConfigureOnlyStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}	// check for forwarding	UInt8 forwarding = gGatewayData->GetDataIPforwarding();	if (forwarding == kForwardingAutomatic) {		paramStr = kForwardingAutomaticStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}	else if (forwarding == kForwardingAlways) {		paramStr = kForwardingAlwaysStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}	else if (forwarding == kForwardingNever) {		paramStr = kForwardingNeverStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}	// exposed host	value = gGatewayData->GetDataExposedHost();	if (value == kExposedHostNone) {		paramStr = kExposedHostNoneStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];				}	else if (value == kExposedHostAddress) {		paramStr = kExposedHostAddressStr;		paramStr += "\p=";		value = gGatewayData->GetDataExposedHostAddress();		IP_NumToStr(value, str);		paramStr += str;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];					}		// default to exposed host gateway	// check for dialupDNS	if (gGatewayData->GetDataDialupDNS()) {		paramStr = kDialupDNSStr;		paramStr += "\p=";		paramStr += gGatewayData->GetDataDialupUsername(str);		paramStr += "\p^";		paramStr += gGatewayData->GetDataDialupPassword(str);		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}		// check for remainConnected	if (gGatewayData->GetDataRemainConnected()) {		paramStr = kRemainConnectedStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}	// check for DisconnectAtQuit	if (gGatewayData->GetDataDisconnectAtQuit()) {		paramStr = kDisconnectAtQuitStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}	// check for show PPP dialogs	if (gGatewayData->GetDataShowPPPdialogs()) {		paramStr = kShowPPPdialogsStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}	// check for Enable Local NAT	if (gGatewayData->GetDataEnableLocalNAT()) {		paramStr = kEnableLocalNATStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}	// check for DNS Forwarding	{		if (gGatewayData->GetDataDNSForwarding()) paramStr = kDNSForwardingStr;		else paramStr = kDNSForwardingOffStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}	// check for Limit MTU for PPPoE	{		if (gGatewayData->GetDataLimitMTUForPPPoE()) paramStr = kLimitMTUForPPPoEStr;		else paramStr = kLimitMTUForPPPoEOffStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}	// check for TR Cable Modem	if (gGatewayData->GetDataTRCableModem()) {		paramStr = kTRCableModemStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}	// check for dial on demand	if (!gGatewayData->GetDataDialOnDemand()) {		paramStr = kDialOnDemandOffStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}	// ExcludeFromNAT	if (gGatewayData->GetDataExcludeFromNAT()) {		paramStr = kSetStr;		paramStr += kDelimiterStr;		paramStr += kExcludeFromNATStr;		paramStr += "\p=";		paramStr += kValueOnStr;		paramStr += kDelimiterStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}	// ExcludeNet	NetNumber_t net;	gGatewayData->GetDataExcludeNet(&net);	if (net.address) {		paramStr = kSetStr;		paramStr += kDelimiterStr;		paramStr += kExcludeNetStr;		paramStr += "\p=";		IP_NetToStr(net, str);		paramStr += str;		paramStr += kDelimiterStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}    // DHCP settings	// check for DHCP Server On	if (gDHCPData->GetDataDHCPServerOn()) {		paramStr = kDHCPServerOnStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}	// check for DHCP Verbose Logging	if (gDHCPData->GetDataDHCPVerboseLogging()) {		paramStr = kDHCPVerboseLoggingStr;		paramStr += "\p\r";		dp = (UInt8*)(*inTextH);		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];			}	// setup access to Interfaces data	InterfaceEntry_t	interfaceEntry;	ArrayIndexT			numConfigE, index;	numConfigE = gInterfacesData->GetDataCount();		// iterate over config to export data	for (index=1; index<=numConfigE; index++) {		if ( !gInterfacesData->GetDataInterfacesArray(index, &interfaceEntry) ) break;		if (interfaceEntry.wamnet) continue;	// skip WAM!NET entries		// write out entry as text if there is room		if ((start + kMaxInterfaceSize) < end) {			// Lock the text handle.			StHandleLocker	theLock( inTextH );			dp = (UInt8*)(*inTextH);	// dereference handle			paramStr = gInterfacesData->InterfaceEntryToString(&interfaceEntry, str);			// mark end of line			paramStr += "\p\r";			::BlockMove(&paramStr[1], &dp[start], paramStr[0]);			start += paramStr[0];		} else {			// buffer is too small			return -1;		}	}	// setup access to Routes data	RouteEntry_t	routesEntry;	//ArrayIndexT	numConfigE, index;	numConfigE = gRoutesData->GetDataCount();		// iterate over config to export data	for (index=1; index<=numConfigE; index++) {		if ( !gRoutesData->GetDataRoutesArray(index, &routesEntry) ) break;		if (routesEntry.wamnet) continue;	// skip WAM!NET entries		// write out entry as text if there is room		if ((start + kMaxRouteSize) < end) {			// Lock the text handle.			StHandleLocker	theLock( inTextH );			dp = (UInt8*)(*inTextH);	// dereference handle			paramStr = gRoutesData->RouteEntryToString(&routesEntry, str);			// mark end of line			paramStr += "\p\r";			::BlockMove(&paramStr[1], &dp[start], paramStr[0]);			start += paramStr[0];		} else {			 // buffer is too small			 return -1;		}	}	// setup access to PortMap data	PortMapEntry_t	portMapEntry;	//ArrayIndexT	numConfigE, index;	numConfigE = gPortMapData->GetDataCount();		// iterate over config to export data	for (index=1; index<=numConfigE; index++) {		if ( !gPortMapData->GetDataPortMapArray(index, &portMapEntry) ) break;		if (portMapEntry.flags & kFlagWamnet) continue;	// skip WAM!NET entries		if (portMapEntry.flags & kFlagNoRestore) continue;	// skip NoRestore entries		if (portMapEntry.flags & kFlagDNSForwarding) continue;	// skip DNSForwarding entries		// skip non static entries		if ((portMapEntry.flags & kFlagPermanent) == 0) continue;		// write out entry as text if there is room		if ((start + kMaxPortMapSize) < end) {			// Lock the text handle.			StHandleLocker	theLock( inTextH );			dp = (UInt8*)(*inTextH);	// dereference handle			paramStr = gPortMapData->PortMapEntryToString(&portMapEntry, str);			// mark end of line			paramStr += "\p\r";			::BlockMove(&paramStr[1], &dp[start], paramStr[0]);			start += paramStr[0];		} else {			 // buffer is too small			 return -1;		}	}		// Filter data is already saved in data object	FilterEntry_t	filterEntry;	//ArrayIndexT	numConfigE, index;	numConfigE = gFilterData->GetDataCount();	// show filter key	if (numConfigE > 0) {		paramStr = "\p! Port Name\\Direction\\Action\\Protocol\\TCP Ack\\Source Net\\Source Ports\\Dest Net\\Dest Ports\r";		::BlockMove(&paramStr[1], &dp[start], paramStr[0]);		start += paramStr[0];		}	// iterate over config to export data	for (index=1; index<=numConfigE; index++) {				if ( !gFilterData->GetDataFilterArray(index, &filterEntry) ) break;		if (filterEntry.flags & kFlagWamnet) continue;	// skip WAM!NET entries		if (filterEntry.age != 0) continue;	            // skip temporary trigger entries		// write out entry as text if there is room		if ((start + kMaxFilterSize) < end) {			// Lock the text handle.			StHandleLocker	theLock( inTextH );			dp = (UInt8*)(*inTextH);	// dereference handle			paramStr = gFilterData->FilterEntryToString(&filterEntry, str);			// mark end of line			paramStr += "\p\r";			::BlockMove(&paramStr[1], &dp[start], paramStr[0]);			start += paramStr[0];		} else {			 // buffer is too small			 return -1;		}	}	// setup access to DHCP Static Cfg data	DHCPStaticCfgEntry_t	staticCfgEntry;	ArrayIndexT				count;	count = gDHCPData->GetDataCountDHCPStaticCfg();		// iterate over config to export data	for (index=1; index<=count; index++) {		if ( !gDHCPData->GetDataDHCPStaticCfgArray(index, &staticCfgEntry) ) break;		// write out entry as text if there is room		if ((start + kMaxDHCPSize) < end) {			// Lock the text handle.			StHandleLocker	theLock( inTextH );			dp = (UInt8*)(*inTextH);	// dereference handle			start += gDHCPData->StaticCfgEntryToText(&staticCfgEntry,  &dp[start], end);			// mark end of line			AppendStr(dp, start, end, kDelimeterEOLStr);		} else {			// buffer is too small			return -1;		}	}	// setup access to DHCP Dynamic Cfg data	DHCPDynamicCfgEntry_t	dynamicCfgEntry;	count = gDHCPData->GetDataCountDHCPDynamicCfg();		// iterate over config to export data	for (index=1; index<=count; index++) {		if ( !gDHCPData->GetDataDHCPDynamicCfgArray(index, &dynamicCfgEntry) ) break;		// write out entry as text if there is room		if ((start + kMaxDHCPSize) < end) {			// Lock the text handle.			StHandleLocker	theLock( inTextH );			dp = (UInt8*)(*inTextH);	// dereference handle			start += gDHCPData->DynamicCfgEntryToText(&dynamicCfgEntry,  &dp[start], end);			// mark end of line			AppendStr(dp, start, end, kDelimeterEOLStr);		} else {			// buffer is too small			return -1;		}	}	// setup access to DHCP Lease Data data	DHCPLeaseDataEntry_t	leaseDataEntry;	count = gDHCPData->GetDataCountDHCPLeaseData();		// iterate over config to export data	for (index=1; index<=count; index++) {		if ( !gDHCPData->GetDataDHCPLeaseDataArray(index, &leaseDataEntry) ) break;		// write out entry as text if there is room		if ((start + kMaxDHCPSize) < end) {			// Lock the text handle.			StHandleLocker	theLock( inTextH );			dp = (UInt8*)(*inTextH);	// dereference handle			start += gDHCPData->LeaseDataEntryToText(&leaseDataEntry,  &dp[start], end);			// mark end of line			AppendStr(dp, start, end, kDelimeterEOLStr);		} else {			// buffer is too small			return -1;		}	}	// add end of data marker	paramStr = "\p#end\r";	dp = (UInt8*)(*inTextH);	::BlockMove(&paramStr[1], &dp[start], paramStr[0]);	start += paramStr[0];		return start;	// no error}// ---------------------------------------------------------------------------------//		¥ FindByte// ---------------------------------------------------------------------------------//	Find the position of a byte value in array dp from start to end.//	Returns offset to byte or zero if not foundSInt32CConfigDocument::FindByte(UInt8 byte, UInt8* dp, SInt32 start, SInt32 end){	SInt32	last;	SInt32	pos;	UInt8	hold;		pos = 0;	if (start < end) {		// check start is before end		// remember last byte and set it to what we're looking for so the loop		// will terminate without checking on each cycle		last = end-1;		hold = dp[last];		dp[last] = byte;				while (dp[start++] != byte) ;		dp[last] = hold;	// put last back		if (start <= last) pos = start-1;		else if (byte == hold) pos = last;	}	return pos;}// ---------------------------------------------------------------------------------//		¥ GetParamString// ---------------------------------------------------------------------------------// Get param string from array dp// Returns offset to one past end of parameter or zero if not found//	parameter is terminated by a 'kDelimiterChar' or '\r' or ending offsetSInt32CConfigDocument::GetParamString(UInt8* dp, SInt32 start, SInt32 end, Str63 outStr){	SInt32	pos, eol, len;	pos = 0;	if (start < end) {		// find end of line		eol = FindByte('\r', dp, start, end);		if (eol == 0) eol = end;		// find end of param		pos = FindByte(kDelimiterChar, dp, start, end);		if ((pos == 0) || (pos > eol)) pos = eol;		len = pos - start;		if ((len >= 0) && (len < 255)) {			outStr[0] = len;			::BlockMove(&dp[start], &outStr[1], len);		} else pos = 0;	}	return pos;}