// ===========================================================================//	CDeviceData.cp			©1998 Sustainable Softworks, All rights reserved.// ===========================================================================// Device data (corresponds to device window)#include "CDeviceData.h"#include "CLogAction.h"#include <OpenTransport.h>#include <OpenTptConfig.h>#include <OpenTptInternet.h>#include <OpenTptLinks.h>#include "UOpenTptSupport.h"#include "IPSupport.h"#include <LString.h>#include "CInterfacesAction.h"// Globalsextern CInterfacesAction*	gInterfacesAction;extern CLogAction*			gLogAction;// ---------------------------------------------------------------------------------//		¥ CDeviceData	[Constructor]// ---------------------------------------------------------------------------------CDeviceData::CDeviceData(){	mDeviceArray = nil;	Init();}// ---------------------------------------------------------------------------------//		¥ ~CDeviceData	[Destructor]// ---------------------------------------------------------------------------------CDeviceData::~CDeviceData(){	if (mDeviceArray) delete mDeviceArray;	mDeviceArray = nil;}// ---------------------------------------------------------------------------------//		¥ Init// ---------------------------------------------------------------------------------//	Initialize device data storagevoidCDeviceData::Init(){	UInt32	count;		// Device array	if (mDeviceArray == nil) {		// allocate array object if needed		mDeviceArray		= new LArray(sizeof(DeviceEntry_t));		ThrowIfNil_(mDeviceArray);	} else {		// remove any previous elements		count = mDeviceArray->GetCount();		if (count > 0) {			// (inCount, atIndex)			mDeviceArray->RemoveItemsAt(count, 1);		}	}}#pragma mark --- Accessors ---// ---------------------------------------------------------------------------------//		¥ SetDataDeviceArray// ---------------------------------------------------------------------------------// Write element to device array, insert new element if beyond end of array// and return index of where element was written.ArrayIndexTCDeviceData::SetDataDeviceArray(ArrayIndexT index, DeviceEntry_t* inEntry){	ArrayIndexT	count;	ArrayIndexT	result;		count = mDeviceArray->GetCount();	if (index <= count) {		// assign element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mDeviceArray->AssignItemsAt(1, index, inEntry, sizeof(DeviceEntry_t));	} else {		// insert element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mDeviceArray->InsertItemsAt(1, index, inEntry, sizeof(DeviceEntry_t));	}	SignalDataEvent( DATA_ID(kDeviceData, kDataDeviceArrayOffset + result) );		return result;}// ---------------------------------------------------------------------------------//		¥ GetDataDeviceArray// ---------------------------------------------------------------------------------// Get element from device array at index.// Return false if index is out of range.BooleanCDeviceData::GetDataDeviceArray(ArrayIndexT index, DeviceEntry_t* outEntry){	return mDeviceArray->FetchItemAt(index, outEntry);}// ---------------------------------------------------------------------------------//		¥ GetDataCount// ---------------------------------------------------------------------------------//	return number of elements in device arrayArrayIndexTCDeviceData::GetDataCount(){	return mDeviceArray->GetCount();}// ---------------------------------------------------------------------------------//		¥ LoadDataDeviceArray// ---------------------------------------------------------------------------------//	Scan OT port registry to load device data//// Notice we must not overwrite the ipLinkId or arpLinkId// For this reason, we compare each new device with existing// existing ones to keep the existing info whenever possible.voidCDeviceData::LoadDataDeviceArray(){	OTPortRecord	portInfo;	UInt32			index;	UInt32			trackNamesIndex;	UInt32			trackNames[kDeviceInfoDim];	UInt32			count, tCount;	UInt8			i, j;	Str31			str;	UInt16			deviceType;	Str255			userPortName;	LStr255			portName;	LStr255			moduleName;	DeviceEntry_t	deviceEntry;	DeviceEntry_t	tDeviceEntry;	CDeviceData		tDeviceData;	Boolean			isMacIPdevice;	Boolean			inList;	Boolean			firstScan;	LStr255			text;	const SInt16	kOTPrivateDevice = 50;	// CS-103837			UOpenTptSupport::StartOpenTransport();		// Log what we're about to do	// get vers resource	StResource versData( (ResType)'vers', 1, false, false );	// (...inThrowFail, inCurrResOnly)	if (versData.mResourceH) {		// display version info		text = "\p\rIPNetRouter ";		text += (unsigned char*)&(*versData.mResourceH)[6];		#if powerc		text += "\p PPC";		#else		text += "\p 68K";		#endif		gLogAction->LogText(text);	}	gLogAction->LogText("\p\r  Scanning OT port registry:");	// Scan available ports into temporary device array	// remember if this is our first scan since launching the program	firstScan = false;	count = GetDataCount();	if (count == 0) firstScan = true;	// setup to read ports into temporary array	tDeviceData.Init();	index = 0;	trackNamesIndex = 0;	deviceType = 0;	while (::OTGetIndexedPort(&portInfo, index)) {		index += 1;		// skip ports that are not available		if (portInfo.fPortFlags & kOTPortIsUnavailable) continue;		deviceType = OTGetDeviceTypeFromPortRef(portInfo.fRef);				moduleName = portInfo.fModuleName;		// check for MacIP device		isMacIPdevice = ::EqualString(moduleName, "\pddp", true, false);	// caseSens, diacSense		// build table entry for IP devices		if ((isMacIPdevice						) ||			(deviceType == kOTEthernetDevice	) ||			(deviceType == kOTFastEthernetDevice) ||			(deviceType == kOTATMSNAPDevice		) ||			(deviceType == kOTTokenRingDevice	) ||			(deviceType == kOTIrDADevice		) ||			(deviceType == kOTFDDIDevice		) ||			(deviceType == kOTMDEVDevice		) ||			(deviceType == kOTPrivateDevice		) ||			(deviceType == kOTPPPDevice			)) {			// get port name			portName = portInfo.fPortName;			if (isMacIPdevice) {				LString::CopyPStr("\pAppleTalk (MacIP)", userPortName);			} else {				::OTGetUserPortNameFromPortRef(portInfo.fRef, userPortName);			}			// remember what driver module names we have seen			trackNamesIndex += 1;			if (trackNamesIndex >= kDeviceInfoDim) {				gLogAction->LogText("\p\rTrackNames overflow, port scan aborted.");				break;			}			trackNames[trackNamesIndex] = HashName(moduleName);			// setup device info			bzero((UInt8*)&tDeviceEntry, sizeof(DeviceEntry_t));			LString::CopyPStr(portName, tDeviceEntry.portName);			LString::CopyPStr(userPortName, tDeviceEntry.userPortName);			if (firstScan) {				// just assign interface names in order					// check list of seen module names to set unique ID				count = 0;				for (i=0; i<trackNamesIndex; i++) {					if (trackNames[i] == trackNames[trackNamesIndex]) {						count += 1;					}				}					// build interface name from module name + ID				::NumToString(count, str);				moduleName += str;				LString::CopyPStr(moduleName, tDeviceEntry.interfaceName);			} else {				// Use moduleName as temporary interface name				// Then check to see which names are available				LString::CopyPStr(moduleName, tDeviceEntry.interfaceName);			}			// set other interface flags			tDeviceEntry.deviceType = deviceType;			tDeviceEntry.needArp = true;			tDeviceEntry.isMacIP = false;			tDeviceEntry.needPPP = false;			if ((deviceType == kOTPPPDevice) || (deviceType == kOTMDEVDevice)) {				tDeviceEntry.needArp = false;		// ad hoc - fix to use T_INFO_REQ				tDeviceEntry.needPPP = true;			}			if (isMacIPdevice) {				tDeviceEntry.needArp = true;				tDeviceEntry.isMacIP = true;									tDeviceEntry.needPPP = false;			}			// store new entry			tCount = tDeviceData.GetDataCount();			tDeviceData.SetDataDeviceArray(tCount+1, &tDeviceEntry);		}	}	// Have new list	// for each entry on existing list, check if it still exists and remove if necessary	count = GetDataCount();	for (j=1; j<=count; j++) {		GetDataDeviceArray(j, &deviceEntry);	// get entry		// scan new list to see if it's still there		inList = false;		tCount = tDeviceData.GetDataCount();		for (i=1; i<=tCount; i++) {			tDeviceData.GetDataDeviceArray(i, &tDeviceEntry);			// test for match			if (::EqualString(deviceEntry.portName, tDeviceEntry.portName, false, false)) {				inList = true;				break;			}		}		if (!inList) {			// Existing entry has no matching new entry. The port must have been unregistered. 			if (deviceEntry.ipLinkStream != 0) {				// Close the corresponding stream				::OTStreamClose( deviceEntry.ipLinkStream );				LStr255 text;				text = "\p\rClosing link stream for non existent port: ";				text += deviceEntry.portName;				gLogAction->LogText(text);			}			if (deviceEntry.arpLinkStream != 0) {				// Close the corresponding stream				::OTStreamClose( deviceEntry.arpLinkStream );						}			DeleteEntryDeviceArray(j);			j -= 1;			count = GetDataCount();		}	}		// Next, for each entry in new list, check if we already have it.	tCount = tDeviceData.GetDataCount();	for (i=1; i<=tCount; i++) {		tDeviceData.GetDataDeviceArray(i, &tDeviceEntry);		// for each new entry		inList = false;		count = GetDataCount();		for (j=1; j<=count; j++) {			GetDataDeviceArray(j, &deviceEntry);	// get entry			// if new entry is in existing list			if (::EqualString(deviceEntry.portName, tDeviceEntry.portName, false, false)) {				inList = true;				break;			}		}		if (inList) {			tDeviceData.DeleteEntryDeviceArray(i);			i -= 1;			tCount = tDeviceData.GetDataCount();		}	}		// Temporary list contains ports with names we don't yet have.	// For each of these ports, we need to assign an appropriate interface name	//  and add it to our list.	tCount = tDeviceData.GetDataCount();	for (i=1; i<=tCount; i++) {		short outFlags;		OTResult result;		tDeviceData.GetDataDeviceArray(i, &tDeviceEntry);		if (!firstScan) {			// Look for an unused interface name			for (j=0; j<kDeviceInfoDim; j++) {				::NumToString(j, str);				moduleName = tDeviceEntry.interfaceName;				moduleName += str;				// try to get interface flags for this name				result = kEINVALErr;				if (gInterfacesAction) {					result = gInterfacesAction->GetInterfaceFlags(moduleName, &outFlags);				}				// if unsuccessful, assume name is available				if (result != kOTNoError) break;			}			// use the name we found			LString::CopyPStr(moduleName, tDeviceEntry.interfaceName);		}		// add device entry to our actual list		count = GetDataCount();		SetDataDeviceArray(count+1, &tDeviceEntry);			}	// tell user what we found	// Show user the new list	count = GetDataCount();	for (j=1; j<=count; j++) {		GetDataDeviceArray(j, &deviceEntry);	// get entry			//Str31	str;		text = "\p\r  User Port Name: ";		text += deviceEntry.userPortName;		text += "\p  Port Name: ";		text += deviceEntry.portName;		text += "\p  Interface Name: ";		text += deviceEntry.interfaceName;		//text += "\p fPortFlags: ";		//::NumToString(portInfo.fPortFlags, str);		//text += str;		gLogAction->LogText(text);		gLogAction->Update();	}	SignalDataEvent( DATA_ID(kDeviceData, kDataArrayLoaded) );}// ---------------------------------------------------------------------------------//		¥ DeleteEntryDeviceArray// ---------------------------------------------------------------------------------//	Delete Device Entry from arrayvoidCDeviceData::DeleteEntryDeviceArray(ArrayIndexT index){	// inCount, inAtIndex	mDeviceArray->RemoveItemsAt(1, index);}// ---------------------------------------------------------------------------------//		¥ AnyNewInterfaces// ---------------------------------------------------------------------------------//	Test for any new interfacesBooleanCDeviceData::AnyNewInterfaces(){	DeviceEntry_t deviceEntry;	Boolean result = false;		if (mDeviceArray) {				LArrayIterator itor(*mDeviceArray, LArrayIterator::from_Start);				while (itor.Next(&deviceEntry)) {			if ((deviceEntry.ipLinkStream != nil) || (deviceEntry.arpLinkStream != nil)) {				result = true;				break;			}		}	}	return result;}// ---------------------------------------------------------------------------------//		¥ FindDataDeviceArray// ---------------------------------------------------------------------------------//	Find device data based on port or interface name//	Returns index of corresponding element, or zero if not foundArrayIndexTCDeviceData::FindDataDeviceArray(Str63 inUserPortName, Str63 inPortName,							Str63 inInterfaceName, DeviceEntry_t* outEntry){	UInt16		index, itemCount, result;	UInt8		pos, best;	result = 0;	itemCount = mDeviceArray->GetCount();	// user port name?	if (inUserPortName != nil) {		for (index=1; index<=itemCount; index++) {			mDeviceArray->FetchItemAt(index, outEntry);						if (::EqualString(inUserPortName, outEntry->userPortName, false, false)) {				result = index;				break;			}		}	}	// port name?	else if (inPortName != nil) {		for (index=1; index<=itemCount; index++) {			mDeviceArray->FetchItemAt(index, outEntry);						if (::EqualString(inPortName, outEntry->portName, false, false)) {				result = index;				break;			}		}	}	// use interface name?	else if (inInterfaceName != nil) {		// look for best (longest) match over 2 characters		best = 2;		// for each interfaceInfo		for (index=1; index<=itemCount; index++) {			mDeviceArray->FetchItemAt(index, outEntry);			pos = 1;			// scan until shorter string exhausted or char does not match			while ((pos <= inInterfaceName[0]) &&				   (pos <= outEntry->interfaceName[0])) {				if (inInterfaceName[pos] != outEntry->interfaceName[pos]) break;				pos += 1;			}			// remember best match			if (pos > best) {				best = pos;				result = index;			}					}		// get corresponding device info		if (result != 0) mDeviceArray->FetchItemAt(result, outEntry);	}		return result;}// ---------------------------------------------------------------------------------//		¥ HashFindDataDeviceArray// ---------------------------------------------------------------------------------//	Find device data from hashed port nameArrayIndexTCDeviceData::HashFindDataDeviceArray(UInt32 hashedName, DeviceEntry_t* outEntry){	UInt16		index, itemCount, result;	result = 0;	itemCount = mDeviceArray->GetCount();	if (hashedName != nil) {		for (index=1; index<=itemCount; index++) {			mDeviceArray->FetchItemAt(index, outEntry);						if (hashedName == HashName(outEntry->portName)) {				result = index;				break;			}		}	}		return result;}