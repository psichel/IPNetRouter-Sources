// ===========================================================================//	CInterfacesData.cp			©1998 Sustainable Softworks, All rights reserved.// ===========================================================================// Interfaces Data (corresponds to Interfaces window)#include "CInterfacesData.h"#include "CConfigDocument.h"#include "IPSupport.h"#include <LString.h>// ---------------------------------------------------------------------------------//		¥ CInterfacesData	[Constructor]// ---------------------------------------------------------------------------------CInterfacesData::CInterfacesData(){	mInterfacesArray = nil;	mInterfacesData = nil;	// link to temporary copy of interfaces 	Init();		mNATexcludeNetwork.address = 0;	mNATexcludeNetwork.mask = 0;	for (UInt8 i=0; i<kNatNumDim; i++) {		mProxyNames.NatPortName[i] = 0;	}	bzero((UInt8*)&mInterfaceEntry, sizeof(InterfaceEntry_t));}// ---------------------------------------------------------------------------------//		¥ ~CInterfacesData	[Destructor]// ---------------------------------------------------------------------------------CInterfacesData::~CInterfacesData(){	if (mInterfacesArray) delete mInterfacesArray;	mInterfacesArray = nil;	if (mInterfacesData) delete mInterfacesData;	mInterfacesData = nil;}// ---------------------------------------------------------------------------------//		¥ Init// ---------------------------------------------------------------------------------//	Initialize interfaces data storagevoidCInterfacesData::Init(){	UInt32	count;		// Inteface array	if (mInterfacesArray == nil) {		// allocate array object if needed		mInterfacesArray	= new LArray(sizeof(InterfaceEntry_t));		ThrowIfNil_(mInterfacesArray);	} else {		// remove any previous elements		count = mInterfacesArray->GetCount();		if (count > 0) {			// (inCount, atIndex)			mInterfacesArray->RemoveItemsAt(count, 1);		}	}}// ---------------------------------------------------------------------------------//		¥ MatchInterfaceInConfig// ---------------------------------------------------------------------------------//	Find matching interface entry in config and return entry and how it matches//	Return values://		kEntryNoMatch	(interface not found - no matching interface name)//		kEntryMatch		(interface is already configured, ignore)//			<one or more flags>//		kEntryNameMatch//		kEntryNeedAddr//		kEntryNeedFlags//		kEntryNeedMasquerading//		kEntryNeedDhcp//		kEntryNeedMtuSInt32CInterfacesData::MatchInterfaceInConfig(		InterfaceEntry_t*	inInterfaceEntry,		CInterfacesData*	inInterfaceConfig,		InterfaceEntry_t*	outInterfaceEntry){	ArrayIndexT		numConfigE, row;	SInt32			result = kEntryNoMatch;	// get number of interfaces in config	numConfigE = inInterfaceConfig->GetDataCount();	// for each interface in config	for (row=numConfigE; row>=1; row--) {		// get entry from config		if ( !inInterfaceConfig->GetDataInterfacesArray(row, outInterfaceEntry) ) continue;		// do they match?		result = MatchInterfaceEntry(inInterfaceEntry, outInterfaceEntry);		if (result != kEntryNoMatch) break;	}	return result;}// ---------------------------------------------------------------------------------//		¥ MatchInterfaceEntry// ---------------------------------------------------------------------------------//	Compare Interface Entries//	Return values://		kEntryNoMatch	(interface not found - no matching interface name)//		kEntryMatch		(interface is already configured, ignore)//			<one or more flags>//		kEntryNameMatch//		kEntryNeedAddr//		kEntryNeedFlags//		kEntryNeedMasquerading//		kEntryNeedDhcp//		kEntryNeedMtuSInt32CInterfacesData::MatchInterfaceEntry(InterfaceEntry_t* inInterfaceEntry1, InterfaceEntry_t* inInterfaceEntry2){	SInt32	result = kEntryNoMatch;		do {		// same interface name?		if (!::EqualString(inInterfaceEntry1->interfaceName,						   inInterfaceEntry2->interfaceName, false, false)) break;		// Found corresponding interface		result = kEntryMatch;		// same interface address?		if (inInterfaceEntry1->interfaceAddr != inInterfaceEntry2->interfaceAddr)			result |= kEntryNeedAddr;		// same interface mask?		if (inInterfaceEntry1->netMask != inInterfaceEntry2->netMask)			result |= kEntryNeedAddr;				// if we got this far, the interface matches so does not need to be removed		// now we check the flags				// test interface attributes		if ((inInterfaceEntry1->bringUp != inInterfaceEntry2->bringUp)			||			(inInterfaceEntry1->unnumbered != inInterfaceEntry2->unnumbered)																					) {			result |= kEntryNeedFlags;		}		if (inInterfaceEntry1->masquerading != inInterfaceEntry2->masquerading) {			result |= kEntryNeedMasquerading;		}		if (inInterfaceEntry1->dhcp != inInterfaceEntry2->dhcp) {			result |= kEntryNeedDhcp;		}		if (inInterfaceEntry1->mtu != inInterfaceEntry2->mtu) {			result |= kEntryNeedMtu;		}	} while (false);		return result;}// ---------------------------------------------------------------------------------//		¥ InterfaceEntryToString// ---------------------------------------------------------------------------------// Convert an Interfaces Entry to a text string for exportStringPtrCInterfacesData::InterfaceEntryToString(InterfaceEntry_t* inEntry, Str255 outStr){	LStr255	textStr;	Str31	str;	// bringUp?	if (inEntry->bringUp) textStr = "\p+interface";	else textStr = "\p-interface";	textStr += kDelimiterStr;			// userPortName	textStr += inEntry->userPortName;	textStr += kDelimiterStr;	// interfaceName		textStr += inEntry->interfaceName;	textStr += kDelimiterStr;	// interfaceAddr	// if it's a dynamic address, save as zero so we get a new one upon restore	if (inEntry->needGateway) {		IP_NumToStr(0, str);	} else {		IP_NumToStr(inEntry->interfaceAddr, str);	}	textStr += str;	textStr += kDelimiterStr;	// netMask	// if it's a dynamic address, save as zero so we get a new one upon restore	if (inEntry->needGateway) {		IP_NumToStr(0, str);	} else {		IP_NumToStr(inEntry->netMask, str);	}		textStr += str;	textStr += kDelimiterStr;	// masquerading	if (inEntry->masquerading) {		textStr += kMasqueradingStr;		textStr += kDelimiterStr;	}			// unnumbered	if (inEntry->unnumbered) {		textStr += kUnnumberedStr;		textStr += kDelimiterStr;	}			// dhcp	if (inEntry->dhcp) {		textStr += kDhcpStr;		textStr += kDelimiterStr;	}			return LString::CopyPStr(textStr, outStr, sizeof(Str255));}// ---------------------------------------------------------------------------------//		¥ InterfaceAddrToName// ---------------------------------------------------------------------------------// Find the Mentat interface name for an IP addressStringPtrCInterfacesData::InterfaceAddrToName(UInt32 inAddr, Str255 outStr){	UInt32	count, i;	InterfaceEntry_t interfaceEntry;	// default to empty (no name)	outStr[0] = 0;	// scan the list of interfaces for a matching IP address	count = GetDataCount();	for (i=1; i<=count; i++) {		GetDataInterfacesArray(i, &interfaceEntry);		if (interfaceEntry.interfaceAddr == inAddr) {			LString::CopyPStr(interfaceEntry.interfaceName, outStr, sizeof(Str63));			break;		}	}	return outStr;}// ---------------------------------------------------------------------------------//		¥ InterfaceNameToAddr// ---------------------------------------------------------------------------------// Find the Mentat interface name for an IP addressUInt32CInterfacesData::InterfaceNameToAddr(Str255 inName){	UInt32  outAddr;	UInt32	count, i;	InterfaceEntry_t interfaceEntry;	// default to 0	outAddr = 0;	// scan the list of interfaces for a matching IP address	count = GetDataCount();	for (i=1; i<=count; i++) {		GetDataInterfacesArray(i, &interfaceEntry);		if (::EqualString(interfaceEntry.interfaceName, inName, false, false)) {			outAddr = interfaceEntry.interfaceAddr;			break;		}	}	return outAddr;}#pragma mark --- Accessors ---// ---------------------------------------------------------------------------------//		¥ SignalDataChange// ---------------------------------------------------------------------------------// Used to tell our document when data has changedvoidCInterfacesData::SignalDataChange(){	SignalDataEvent( DATA_ID(kInterfacesData, kDataChange) );}// ---------------------------------------------------------------------------------//		¥ SetDataInterfaceEntry// ---------------------------------------------------------------------------------// Set of Get Config Entry (corresponds to parameters in config area of window)voidCInterfacesData::SetDataInterfaceEntry(InterfaceEntry_t* inEntry){	mInterfaceEntry = *inEntry;	SignalDataEvent( DATA_ID(kInterfacesData, kDataInterfaceEntry) );}voidCInterfacesData::GetDataInterfaceEntry(InterfaceEntry_t* outEntry){	*outEntry = mInterfaceEntry;}// ---------------------------------------------------------------------------------//		¥ SetDataInterfacesArray// ---------------------------------------------------------------------------------// Write element to Interfaces array, insert new element if beyond end of array// and return index of where element was written.ArrayIndexTCInterfacesData::SetDataInterfacesArray(ArrayIndexT index, InterfaceEntry_t* inEntry){	ArrayIndexT	count;	ArrayIndexT	result;		count = mInterfacesArray->GetCount();	if (index <= count) {		// assign element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mInterfacesArray->AssignItemsAt(1, index, inEntry, sizeof(InterfaceEntry_t));	} else {		// insert element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mInterfacesArray->InsertItemsAt(1, index, inEntry, sizeof(InterfaceEntry_t));	}	SignalDataEvent( DATA_ID(kInterfacesData, kDataInterfacesArrayOffset + result) );		return result;}// ---------------------------------------------------------------------------------//		¥ GetDataInterfacesArray// ---------------------------------------------------------------------------------// Get element from Interfaces array at index.// Return false if index is out of range.BooleanCInterfacesData::GetDataInterfacesArray(ArrayIndexT index, InterfaceEntry_t* outEntry){	return mInterfacesArray->FetchItemAt(index, outEntry);}// ---------------------------------------------------------------------------------//		¥ RemoveDataInterfacesArray// ---------------------------------------------------------------------------------// Remove element from Interfaces array at index.// Return false if index is out of range.BooleanCInterfacesData::RemoveDataInterfacesArray(ArrayIndexT index){	Boolean result;		result = mInterfacesArray->ValidIndex(index);	if (result) {		mInterfacesArray->RemoveItemsAt(1, index);	}	return result;}// ---------------------------------------------------------------------------------//		¥ GetDataCount// ---------------------------------------------------------------------------------//	return number of elements in Interfaces arrayArrayIndexTCInterfacesData::GetDataCount(){	return mInterfacesArray->GetCount();}// ---------------------------------------------------------------------------------//		¥ SetDataCount// ---------------------------------------------------------------------------------// Set number of elements in Interfaces array.// Remove any elements after specified count and return count of last element// which could be less than the number requested.ArrayIndexTCInterfacesData::SetDataCount(ArrayIndexT count){	ArrayIndexT	num;	ArrayIndexT result;	ArrayIndexT index;		// remove any elements beyond count	result = count;	num = mInterfacesArray->GetCount();	if (num < count) {		result = num;	}	else if (num > count) {		// remove extras		// (inCount, atIndex)		mInterfacesArray->RemoveItemsAt(num-count, count+1);		// signal corresponding elements have changed		for (index=count+1; index<=num; index++) {			SignalDataEvent( DATA_ID(kInterfacesData, kDataInterfacesArrayOffset + index) );		}	}		return result;}/*// ---------------------------------------------------------------------------------//		¥ SetDataNATaddress// ---------------------------------------------------------------------------------voidCInterfacesData::SetDataNATaddress(UInt32 inValue){	if (mNATaddress != inValue) {		mNATaddress =  inValue;		SignalDataEvent( DATA_ID(kInterfacesData, kDataNATaddress) );			}}UInt32CInterfacesData::GetDataNATaddress()			{ return mNATaddress; }*//*// ---------------------------------------------------------------------------------//		¥ SetDataNATinterface// ---------------------------------------------------------------------------------// The interfaceName uniquely identifies the IPIF we are masquerading on.// Update interfaces array to show this as needed.voidCInterfacesData::SetDataNATinterface(UInt32 inValue){	ArrayIndexT			index;	ArrayIndexT			num;	InterfaceEntry_t	entry;	if (mNATinterface != inValue) {		mNATinterface =  inValue;		SignalDataEvent( DATA_ID(kInterfacesData, kDataNATinterface) );				// update interfaces array to show which interface is masquerading		num = GetDataCount();		for (index=1; index<=num; index++) {			GetDataInterfacesArray(index, &entry);			if (entry.masquerading) {				// marked as masquerading, reset if needed				if (HashName(entry.interfaceName) != mNATinterface) {					entry.masquerading = false;					SetDataInterfacesArray(index, &entry);				}			}			else {				// marked as not masquerading, set if needed				if (HashName(entry.interfaceName) == mNATinterface) {					entry.masquerading = true;					SetDataInterfacesArray(index, &entry);				}			}			}	}}UInt32CInterfacesData::GetDataNATinterface()			{ return mNATinterface; }*/// ---------------------------------------------------------------------------------//		¥ SetDataNATexcludeNetwork// ---------------------------------------------------------------------------------voidCInterfacesData::SetDataNATexcludeNetwork(NetNumber_t* inNetwork){	mNATexcludeNetwork = *inNetwork;	SignalDataEvent( DATA_ID(kInterfacesData, kDataNATexcludeNetwork) );}voidCInterfacesData::GetDataNATexcludeNetwork(NetNumber_t* outNetwork){	*outNetwork = mNATexcludeNetwork;}// ---------------------------------------------------------------------------------//		¥ SetDataProxyNames// ---------------------------------------------------------------------------------voidCInterfacesData::SetDataProxyNames(proxy_names_t* inProxyNames){	mProxyNames = *inProxyNames;	SignalDataEvent( DATA_ID(kInterfacesData, kDataProxyNames) );	UpdateNatInterfaces();}voidCInterfacesData::GetDataProxyNames(proxy_names_t* outProxyNames){	*outProxyNames = mProxyNames;}// ---------------------------------------------------------------------------------//		¥ UpdateNatInterfaces// ---------------------------------------------------------------------------------// Update the InterfacesData array to show which interfaces are being masqueraded.// IP uses interface names to identify an IPIF on a Link Stream, whereas// OT uses port names to identify the targets of Link Streams.// We masquerade on any interface whose port name is in the proxyNames// array unless its IP address is the same as our "excludeNetwork".voidCInterfacesData::UpdateNatInterfaces(){	ArrayIndexT			index;	ArrayIndexT			num;	InterfaceEntry_t	entry;	UInt8				i;	Boolean				inList;	UInt32				theHash;	// update interfaces array to show which interfaces are masquerading	num = GetDataCount();	for (index=1; index<=num; index++) {		GetDataInterfacesArray(index, &entry);		if (entry.masquerading) {			// marked as masquerading, reset if needed				// is it our actual network?			if (entry.interfaceAddr == mNATexcludeNetwork.address) {				// yes mark as no longer masquerading				entry.masquerading = false;				SetDataInterfacesArray(index, &entry);						} else {				// is it not in the list of proxyNames?				inList = false;				theHash = HashName(entry.portName);				if (theHash != 0) {					for (i=0; i<kNatNumDim; i++) {						if (theHash == mProxyNames.NatPortName[i]) {							inList = true;							break;						}					}				}				if (!inList) {					entry.masquerading = false;					SetDataInterfacesArray(index, &entry);								}			}		}		else {			// marked as not masquerading, set if needed			theHash = HashName(entry.portName);			if (theHash != 0) {				for (i=0; i<kNatNumDim; i++) {					if (theHash == mProxyNames.NatPortName[i]) {						// portName matches, check it is not our Actual network						if (entry.interfaceAddr != mNATexcludeNetwork.address) {							entry.masquerading = true;							SetDataInterfacesArray(index, &entry);						}						break;					}				}			}		}		}}