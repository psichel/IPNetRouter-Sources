// ===========================================================================//	CInterfacesData.h			©1998 Sustainable Softworks, All rights reserved.// ===========================================================================// Interfaces Data (corresponds to Interfaces window)#ifndef _H_CInterfacesData#define _H_CInterfacesData#pragma once#include <LArray.h>	// maximum size a corresponding text entry in config document#define kMaxInterfaceSize	100#define kInterfaceNameDim	40		// size of InterfaceNameconst SInt16 kMaxInterfaces		= 200;	// maximum number of interfaces we'll handle// Interface Data Elementtypedef struct InterfaceEntry {	Str63	userPortName;	Str32	portName;	Str63	interfaceName;	UInt32	mentatIPIF;	UInt32	interfaceAddr;	UInt32	netMask;	UInt32	mtu;	void*	userCon;	Boolean	bringUp;	Boolean unnumbered;	Boolean masquerading;	Boolean	needGateway;	// dynamically assigned address	Boolean	pppAddr;		// use specified PPP address	Boolean dhcp;	Boolean wamnet;	Boolean	isDone;} InterfaceEntry_t;#include "CSignalDataEvent.h"#include "MyTypes.h"class	CInterfacesData : public CSignalDataEvent {public:					CInterfacesData();	virtual			~CInterfacesData();	void			Init();	SInt32			MatchInterfaceInConfig(						InterfaceEntry_t*	inInterfaceEntry,						CInterfacesData*	inInterfaceConfig,						InterfaceEntry_t*	outInterfaceEntry);	SInt32			MatchInterfaceEntry(InterfaceEntry_t* inInterfaceEntry1, InterfaceEntry_t* inInterfaceEntry2);	StringPtr		InterfaceEntryToString(InterfaceEntry_t* inEntry, Str255 outStr);	StringPtr		InterfaceAddrToName(UInt32 inAddr, Str255 outStr);	UInt32          InterfaceNameToAddr(Str255 inName);	void			SetDataInterfaceEntry(InterfaceEntry_t* inEntry);	void			GetDataInterfaceEntry(InterfaceEntry_t* outEntry);		ArrayIndexT		SetDataInterfacesArray(ArrayIndexT index, InterfaceEntry_t* inEntry);	Boolean			GetDataInterfacesArray(ArrayIndexT index, InterfaceEntry_t* outEntry);	Boolean			RemoveDataInterfacesArray(ArrayIndexT index);	ArrayIndexT		GetDataCount();	ArrayIndexT		SetDataCount(ArrayIndexT count);	void			SetDataNATexcludeNetwork(NetNumber_t* inNetwork);	void			GetDataNATexcludeNetwork(NetNumber_t* outNetwork);	void			SetDataProxyNames(proxy_names_t* inProxyNames);	void			GetDataProxyNames(proxy_names_t* outProxyNames);	void			UpdateNatInterfaces();	void			SignalDataChange();	CInterfacesData*	mInterfacesData;private:	LArray*				mInterfacesArray;	InterfaceEntry_t	mInterfaceEntry;		NetNumber_t			mNATexcludeNetwork;	// don't masquerade	proxy_names_t		mProxyNames;		// hold NAT port names};const SInt16 kInterfacesData			= 'i';#define kDataChange	1const SInt16 kDataInterfaceEntry		= 2;const SInt16 kDataInterfacesCount		= 3;	// count of elements in arrayconst SInt16 kDataNATexcludeNetwork		= 4;const SInt16 kDataProxyNames			= 5;const SInt16 kDataInterfacesArrayOffset	= 5;	// use offset+1..n// Constants for comparing Interface Entriesconst UInt16 kEntryNoMatch				= 0xFF;const UInt16 kEntryMatch				= 0x00;const UInt16 kEntryNeedAddr			    = 0x01;const UInt16 kEntryNeedFlags			= 0x02;const UInt16 kEntryNeedMasquerading	    = 0x04;const UInt16 kEntryNeedDhcp			    = 0x08;const UInt16 kEntryNeedMtu				= 0x10;// Constants for restoring routesconst SInt16 kEntryAdd					= 0x40;const SInt16 kEntryDelete				= 0x80;#endif