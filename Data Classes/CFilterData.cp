// ===========================================================================//	CFilterData.cp			©1998 Sustainable Softworks, All rights reserved.// ===========================================================================// Filter data (corresponds to filter window)#include "CFilterData.h"#include "CFilterConst.h"#include "CConfigDocument.h"#include "IPSupport.h"#include "CDeviceData.h"// Globalsextern CDeviceData*			gDeviceData;// ---------------------------------------------------------------------------------//		¥ CFilterData	[Constructor]// ---------------------------------------------------------------------------------CFilterData::CFilterData(){	mFilterArray = nil;	bzero((UInt8*)&mFilterEntry, sizeof(FilterEntry_t));	Init();	mFilterData = nil;		// link to temp copy of filters}// ---------------------------------------------------------------------------------//		¥ ~CFilterData	[Destructor]// ---------------------------------------------------------------------------------CFilterData::~CFilterData(){	if (mFilterArray) delete mFilterArray;	mFilterArray = nil;	if (mFilterData) delete mFilterData;	mFilterData = nil;}// ---------------------------------------------------------------------------------//		¥ Init// ---------------------------------------------------------------------------------//	Initialize filter data storagevoidCFilterData::Init(){	UInt32	count;		// Filter array	if (mFilterArray == nil) {		// allocate array object if needed		mFilterArray		= new LArray(sizeof(FilterEntry_t));		ThrowIfNil_(mFilterArray);	} else {		// remove any previous elements		count = mFilterArray->GetCount();		if (count > 0) {			// (inCount, atIndex)			mFilterArray->RemoveItemsAt(count, 1);		}	}}// ---------------------------------------------------------------------------------//		¥ EqualFilterEntry// ---------------------------------------------------------------------------------//	Compare two filter entriesBooleanCFilterData::EqualFilterEntry(FilterEntry_t* inEntry1, FilterEntry_t* inEntry2){	Boolean result = false;	do {		if (inEntry1->portName			!= inEntry2->portName)			break;		if (inEntry1->flags				!= inEntry2->flags)				break;		if (inEntry1->protocol			!= inEntry2->protocol)			break;		if (inEntry1->sourceNet.address	!= inEntry2->sourceNet.address)	break;		if (inEntry1->sourceNet.mask	!= inEntry2->sourceNet.mask)	break;		if (inEntry1->sourcePorts.lo	!= inEntry2->sourcePorts.lo)	break;		if (inEntry1->sourcePorts.hi	!= inEntry2->sourcePorts.hi)	break;		if (inEntry1->destNet.address	!= inEntry2->destNet.address)	break;		if (inEntry1->destNet.mask		!= inEntry2->destNet.mask)		break;		if (inEntry1->destPorts.lo		!= inEntry2->destPorts.lo)		break;		if (inEntry1->destPorts.hi		!= inEntry2->destPorts.hi)		break;		result = true;	} while (false);		return result;}// ---------------------------------------------------------------------------------//		¥ FilterEntryToString// ---------------------------------------------------------------------------------// Convert an Filter Entry to a text string for exportStringPtrCFilterData::FilterEntryToString(FilterEntry_t* inEntry, Str255 outStr){	LStr255			textStr;	Str31			str;	DeviceEntry_t	info;	// add entry	if (inEntry->flags & kFlagFilterActive) textStr = "\p+filter";	else textStr = "\p-filter";	textStr += kDelimiterStr;			// PortName	if (gDeviceData->HashFindDataDeviceArray(inEntry->portName, &info)) {		textStr += info.userPortName;	} else textStr += "\p";	textStr += kDelimiterStr;	// direction	if (inEntry->flags & kFlagDirectionRead)		textStr += kDirectionReadStr;	else textStr += kDirectionWriteStr;	textStr += kDelimiterStr;	// action	UInt16 action = inEntry->flags & kFlagActionMask;	action = action >> 1;	if      (action == kFilterPass)     textStr += kActionPassStr;	else if (action == kFilterReject)   textStr += kActionRejectStr;	else if (action == kFilterNoDial)   textStr += kActionNoDialStr;	else if (action == kFilterTrigger)  textStr += kActionTriggerStr;	else if (action == kFilterLog)  	textStr += kActionLogStr;	textStr += kDelimiterStr;	// protocol	switch (inEntry->protocol) {		case kProtocolTCP:			textStr += kProtocolTCPStr;			break;		case kProtocolUDP:			textStr += kProtocolUDPStr;			break;		case kProtocolICMP:			textStr += kProtocolICMPStr;			break;		case kProtocolGRE:			textStr += kProtocolGREStr;			break;		case kProtocolAny:			textStr += kProtocolAnyStr;			break;		default:			NumToString(inEntry->protocol, str);							textStr += str;	}	textStr += kDelimiterStr;	// Ack Flag	if (inEntry->flags & kFlagAck) textStr += kFlagAckStr;	else if (inEntry->flags & kFlagNoAck) textStr += kFlagNoAckStr;	else textStr += "\p*";	textStr += kDelimiterStr;	// sourceNet	if (inEntry->sourceNet.address == 0) textStr += "\p*";	else {		IP_NetToStr( inEntry->sourceNet, str );		textStr += str;	}	textStr += kDelimiterStr;	// sourcePorts	if ((inEntry->sourcePorts.lo == 0) &&	    (inEntry->sourcePorts.hi == 0) &&	    (inEntry->protocol != kProtocolICMP)) textStr += "\p*";	else {		NumToString( inEntry->sourcePorts.lo, str );		textStr += str;		if (inEntry->sourcePorts.hi != 0) {			::NumToString( inEntry->sourcePorts.hi, str );			textStr += "\p-";			textStr += str;		}	}	textStr += kDelimiterStr;	// destNet	if (inEntry->destNet.address == 0) textStr += "\p*";	else {		IP_NetToStr( inEntry->destNet, str );		textStr += str;	}	textStr += kDelimiterStr;	// destPorts	if ((inEntry->destPorts.lo == 0) &&	    (inEntry->destPorts.hi == 0) &&	    (inEntry->protocol != kProtocolICMP)) textStr += "\p*";	else {		NumToString( inEntry->destPorts.lo, str );		textStr += str;		if (inEntry->destPorts.hi != 0) {			::NumToString( inEntry->destPorts.hi, str );			textStr += "\p-";			textStr += str;		}	}	textStr += kDelimiterStr;	return LString::CopyPStr(textStr, outStr, sizeof(Str255));}#pragma mark --- Accessors ---// ---------------------------------------------------------------------------------//		¥ SignalDataChange// ---------------------------------------------------------------------------------// Used to tell our document when data has changedvoidCFilterData::SignalDataChange(){	SignalDataEvent( DATA_ID(kFilterData, kDataChange) );}// ---------------------------------------------------------------------------------//		¥ SetDataFilterEntry// ---------------------------------------------------------------------------------// Set of Get Config Entry (corresponds to parameters in config area of window)voidCFilterData::SetDataFilterEntry(FilterEntry_t* inEntry){	mFilterEntry = *inEntry;	SignalDataEvent( DATA_ID(kFilterData, kDataFilterEntry) );}voidCFilterData::GetDataFilterEntry(FilterEntry_t* outEntry){	*outEntry = mFilterEntry;}// ---------------------------------------------------------------------------------//		¥ SetDataFilterArray// ---------------------------------------------------------------------------------// Write element to filter array, insert new element if beyond end of array// and return index of where element was written.ArrayIndexTCFilterData::SetDataFilterArray(ArrayIndexT index, FilterEntry_t* inEntry){	ArrayIndexT	count;	ArrayIndexT	result;		count = mFilterArray->GetCount();	if (index <= count) {		// assign element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mFilterArray->AssignItemsAt(1, index, inEntry, sizeof(FilterEntry_t));	} else {		// insert element in Array		//	(inCount, inAtIndex, *inItem, inItemSize)		result = mFilterArray->InsertItemsAt(1, index, inEntry, sizeof(FilterEntry_t));	}	SignalDataEvent( DATA_ID(kFilterData, kDataFilterArrayOffset + result) );		return result;}// ---------------------------------------------------------------------------------//		¥ GetDataFilterArray// ---------------------------------------------------------------------------------// Get element from filter array at index.// Return false if index is out of range.BooleanCFilterData::GetDataFilterArray(ArrayIndexT index, FilterEntry_t* outEntry){	return mFilterArray->FetchItemAt(index, outEntry);}// ---------------------------------------------------------------------------------//		¥ GetDataCount// ---------------------------------------------------------------------------------//	return number of elements in filter arrayArrayIndexTCFilterData::GetDataCount(){	return mFilterArray->GetCount();}// ---------------------------------------------------------------------------------//		¥ SetDataCount// ---------------------------------------------------------------------------------// Set number of elements in filter array.// Remove any elements after specified count and return count of last element// which could be less than the number requested.ArrayIndexTCFilterData::SetDataCount(ArrayIndexT count){	ArrayIndexT	num;	ArrayIndexT result;	ArrayIndexT index;		// remove any elements beyond count	result = count;	num = mFilterArray->GetCount();	if (num < count) {		result = num;	}	else if (num > count) {		// remove extras		// (inCount, atIndex)		mFilterArray->RemoveItemsAt(num-count, count+1);		// signal corresponding elements have changed		for (index=count+1; index<=num; index++) {			SignalDataEvent( DATA_ID(kFilterData, kDataFilterArrayOffset + index) );		}	}		return result;}