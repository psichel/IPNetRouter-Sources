// =================================================================================//	IPSupport.cp				©1996 Sustainable Softworks.  All rights reserved.// =================================================================================// IP Support Routines#include "IPSupport.h"#include "MacSupport.h"#include <LString.h>#include <Resources.h>#pragma mark --- IP Address Strings ---// ---------------------------------------------------------------------------//		¥ IP_StrToInt// ---------------------------------------------------------------------------//	Return the integer value represented by the IP address string//		If not a full quad, return 0 for the missing segments//		if not a valid IP address, returns 0SInt32IP_StrToInt(ConstStr255Param inStr){LStr255 theString, subString;UInt8	startPos, endPos;SInt32	address, segment;Boolean	skipFlag = false;	theString = inStr;	// trim the string to remove non-digits from the start	for (startPos = 1; startPos <= theString[0]; startPos++) {		if ( (theString[startPos] >= '0') && (theString[startPos] <= '9') ) break;	}		// check for "-" indicating address range, ignore 2nd address of range	endPos = theString.Find( '-', startPos );	if (endPos != 0) theString.Assign( theString, 1, endPos-1 );		// check for ":" indicating addr:port, ignore port#	endPos = theString.Find( ':', startPos );	if (endPos != 0) theString.Assign( theString, 1, endPos-1 );	// check for "\r" indicating addr list	endPos = theString.Find( '\r', startPos );	if (endPos != 0) theString.Assign( theString, 1, endPos-1 );	// check for "," indicating addr list	endPos = theString.Find( ',', startPos );	if (endPos != 0) theString.Assign( theString, 1, endPos-1 );		do {			// get first segment of address 		endPos = theString.Find( '.', startPos );		if (endPos == 0) {			endPos = theString.Find( '/', startPos );			if (endPos == 0) {				endPos = theString.Length()+1;				subString.Assign( theString, startPos, endPos-startPos );				address = subString;				if ( !IsDigitString(subString) ) address = 0;				break;			}			else skipFlag = true;		}		segment = subString.Assign( theString, startPos, endPos-startPos );		if ( !IsDigitString(subString) ) {			address = 0;			break;		}		segment &= 0xFF;		address = segment;				// get remaining segments		// 2nd		segment = 0;		if (!skipFlag) {			startPos = endPos + 1;			endPos = theString.Find( '.', startPos );			if (endPos == 0) {				endPos = theString.Find( '/', startPos );				if (endPos == 0) endPos = startPos + 3;				else skipFlag = true;			}			segment = subString.Assign( theString, startPos, endPos-startPos );			if ( !IsDigitString(subString) ) {				address = 0;				break;			}			segment &= 0xFF;		}		address = address << 8;		address |= segment;		// 3rd		segment = 0;		if (!skipFlag) {			startPos = endPos + 1;			endPos = theString.Find( '.', startPos );			if (endPos == 0) {				endPos = theString.Find( '/', startPos );				if (endPos == 0) endPos = startPos + 3;				else skipFlag = true;			}			segment = subString.Assign( theString, startPos, endPos-startPos );			if ( !IsDigitString(subString) ) {				address = 0;				break;			}			segment &= 0xFF;		}		address = address << 8;		address |= segment;				// 4th		segment = 0;		if (!skipFlag) {			startPos = endPos + 1;			endPos = theString.Find( '.', startPos );			if (endPos == 0) {				endPos = theString.Find( '/', startPos );				if (endPos == 0) endPos = startPos + 3;			}			segment = subString.Assign( theString, startPos, endPos-startPos );			if ( !IsDigitString(subString) ) {				address = 0;				break;			}			segment &= 0xFF;		}		address = address << 8;		address |= segment;	} while (false);		return address;}BooleanIsDigitString(ConstStr255Param inStr){	UInt8	len;		len = inStr[0];	while (len > 0) {		if ((inStr[len] < '0') || (inStr[len] > '9')) return false;		len -= 1;	}	return true;}// Test for digit 0-9Boolean IsDigit(UInt8 inDigit){	Boolean result = false;			if (('0' <= inDigit) && (inDigit <= '9')) result = true;	return result;}// ---------------------------------------------------------------------------//		¥ IPprefixLen_StrToInt// ---------------------------------------------------------------------------//	Return the integer value represented by the prefix len part of//	a CIDR aggregate addr/lenUInt8IPprefixLen_StrToInt(ConstStr255Param inStr){LStr255 theString;SInt32	prefixLen;UInt8	pos;	theString = inStr;	prefixLen = 0;	// check for "/" indicating addr/prefixLen, skip addr part	pos = theString.Find('/');	if (pos != 0) {		theString.Assign(theString, pos+1);			if ( IsDigitString(theString) ) {			::StringToNum(theString, &prefixLen);		}	}	return prefixLen;}// ---------------------------------------------------------------------------//		¥ IP_NumToStr// ---------------------------------------------------------------------------//	Return the dotted quad string representing an integer IP addressStringPtrIP_NumToStr(SInt32 inValue, Str255	outStr){	LStr255 returnStr = "\p";	LStr255 numStr = (SInt32) (inValue >> 24 & 0xFF);	returnStr += numStr;	returnStr += "\p.";	numStr = (SInt32) (inValue >> 16 & 0xFF);	returnStr += numStr;	returnStr += "\p.";	numStr = (SInt32) (inValue >> 8 & 0xFF);	returnStr += numStr;	returnStr += "\p.";	numStr = (SInt32) (inValue & 0xFF);	returnStr += numStr;		return LString::CopyPStr(returnStr, outStr);}// ---------------------------------------------------------------------------//		¥ IP_NetToStr// ---------------------------------------------------------------------------//	Return the dotted quad plus prefix length string representing a CIDR aggregateStringPtrIP_NetToStr(NetNumber_t net, Str255 outStr){    LStr255 returnStr;    Str31   str;    IP_NumToStr(net.address, str);    returnStr = str;    if (net.mask != 0) {        returnStr += "\p/";    	UInt32 len = FindRightBit(net.mask, 32);    	::NumToString(len, str);    	returnStr += str;    }	return LString::CopyPStr(returnStr, outStr);}// ---------------------------------------------------------------------------//		¥ IP_NumToHexStr// ---------------------------------------------------------------------------//	Return the hexidecimal string representing an integer IP addressStringPtrIP_NumToHexStr(SInt32 inValue, Str255	outStr){	LStr255 returnStr = "\p";	unsigned char digit;		digit = (inValue >> 28 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	digit = (inValue >> 24 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	digit = (inValue >> 20 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	digit = (inValue >> 16 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	digit = (inValue >> 12 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	digit = (inValue >> 8 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	digit = (inValue >> 4 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	digit = (inValue & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	return LString::CopyPStr(returnStr, outStr);}#pragma mark --- IP Port Strings ---// ---------------------------------------------------------------------------//		¥ PortToString// ---------------------------------------------------------------------------//	Return the string for a specified protocol port//		Well known protocol port names are stored as 'STRP' resources//		starting from kPortStart//	Examples://		kPortStart+7 = "echo"//		kPortStart+20 = "ftp-data"StringPtrPortToString(SInt32 inValue, Str255 outStr){	OSErr		err;	short		stringID;	Handle		h;	short		theID;	ResType		theType;	Str31		name;	// Get port name from resource if any	stringID = kPortStart + inValue;	err = ECGetResource('STRP', stringID, &h);		if (err == noErr) {		// get resource name		::GetResInfo(h, &theID, &theType, name);		LString::CopyPStr(name, outStr);		::ReleaseResource(h);   // *** [PAS]	} else {		// no resource available, just use port number		::NumToString( inValue, outStr );	}	return outStr;}// ---------------------------------------------------------------------------//		¥ Endpoint_StrToInt// ---------------------------------------------------------------------------//	Return the integer value represented by the port part of endpoint addr:portUInt8Endpoint_StrToInt(ConstStr255Param inStr, UInt32* outAddr, UInt16* outPortA, UInt16* outPortB){LStr255 theString;UInt8	pos;UInt8	len;	theString = inStr;	len = theString[0];	theString[len+1] = 0;	// null terminate	*outAddr = IP_StrToInt(theString);	// check for ":" indicating addr:port, skip addr part	len = 0;	pos = theString.Find(':');	if (pos != 0) {		len = DecodePortRange((char*)&theString[pos+1], outPortA, outPortB);	}	return pos + len;}// ---------------------------------------------------------------------------//		¥ DecodePortRange// ---------------------------------------------------------------------------//	Convert RTSP client_port"=aaaa-bbbb" command to a protocol port range//	Return length of port range data, or Zero if command error detectedUInt8DecodePortRange(char* inStr, UInt16* outPortA, UInt16* outPortB){	UInt8	lenA, lenB;	SInt32	portA, portB;		lenA = ctoi(inStr, &portA);	lenB = 0;	portB = 0;					// default to range of 1	if (inStr[lenA] == '-') {		lenA += 1;		lenB = ctoi(&inStr[lenA], &portB);	}	*outPortA = portA;	*outPortB = portB;	return lenA + lenB;}// ---------------------------------------------------------------------------//		¥ EncodePortRange// ---------------------------------------------------------------------------//	Convert protocol port range to RTSP client_port="aaaa-bbbb" command//	Output as null terminated string and return length excluding null.UInt8EncodePortRange(UInt16 inPortA, UInt16 inPortB, char* outStr){	UInt8	lenA, lenB;		lenA = itoc(inPortA, outStr);	lenB = 0;				// default to range of 1	if (inPortB) {		outStr[lenA++] = '-';		lenB = itoc(inPortB, &outStr[lenA]);	}		return lenA+lenB;}// ---------------------------------------------------------------------------//		¥ itoc// ---------------------------------------------------------------------------//	Convert integer to character string and return length of string (excluding null).//	May be called at interrupt time (unlike NumToString).////	A 32-bit integer can produce 10 decimal digits plus a sign and null byte//	so outStr should be at least 12 characters long.UInt8itoc(SInt32 inNum, char* outStr){	SInt32	intVal;	SInt32	d;	UInt8	i,j, k;	char	myStr[16];	const char digits[11] = "0123456789";		intVal = (inNum < 0) ? -inNum : inNum;	for (i=1; i<=10; i++) {		// get digits		d = intVal % 10;		myStr[i] = digits[d];		intVal = intVal/10;		if (intVal == 0) break;	}	if (inNum < 0) {			// sign		i += 1;		myStr[i] = '-';	}	k = 0;	for (j=i; j>=1; j--) {		// reverse		outStr[k++] = myStr[j];	}	outStr[k++] = 0;			// make null terminated		return i;	}// ---------------------------------------------------------------------------//		¥ ctoi// ---------------------------------------------------------------------------//	Convert sequence of decimal digits to an integer.//	Stop at first non-digit character and return number of characters converted.//	A 32-bit int can hold a 10 digit decimal, so convert up to 10 characters max.//	If first char is "-", make result negative.//	May be called at interrupt time (unlike StrToNum).UInt8ctoi(char* inStr, SInt32* outNum){	SInt32	num;	UInt8	d, i, start, end;	Boolean	isNegative = false;		start = 0;	end = 9;	if (inStr[0] == '-') {		// adjust start and end position if negative		isNegative = true;		start = 1;		end = 10;	}		num = 0;	for (i=start; i<=end; i++) {	// tally digits		d = inStr[i];		if (IsDigit(d)) {			num = num*10;			num += d - '0';		}		else break;	}	if (isNegative) *outNum = -num;	// set corresponding value	else *outNum = num;		return i;}#pragma mark --- Hex Notation ---// ---------------------------------------------------------------------------//		¥ EncodeHexStr// ---------------------------------------------------------------------------//	Encode non-printable characters as hex pairs <xx>//	If first byte is 1, show entire string as hex (for DHCP ClientID)StringPtrEncodeHexStr(Str255 inStr, Str255	outStr){	UInt8	len, i, j;	unsigned char digit;	Boolean	encodeFlag = false;	if (inStr[1] == 1) encodeFlag = true;		j = 0;	len = inStr[0];	for (i=1; i<=len; i++) {		if (!UKeyFilters::IsPrintingChar(inStr[i]) || encodeFlag) {			// write out as hex pair <xx>			outStr[++j] = '<';			digit = inStr[i]>>4 & 0x0F;			if (digit < 10) digit += '0';			else digit += ('A' - 10);			outStr[++j] = digit;						digit = inStr[i] & 0x0F;			if (digit < 10) digit += '0';			else digit += ('A' - 10);			outStr[++j] = digit;			outStr[++j] = '>';		}		else {			// copy printable character directly			outStr[++j] = inStr[i];		}	}	outStr[0] = j;	return outStr;}// ---------------------------------------------------------------------------//		¥ DecodeHexStr// ---------------------------------------------------------------------------//	Decode string containing hex pairs <xx>StringPtrDecodeHexStr(Str255 inStr, Str255	outStr){	UInt8	len, i, j;	unsigned char digit;		j = 0;	len = inStr[0];	for (i=1; i<=len; i++) {		if ((inStr[i] == '<') &&			(i+3 <= len) &&			(IsHexChar(inStr[i+1])) &&			(IsHexChar(inStr[i+2])) &&			(inStr[i+3] == '>')) {			// convert hex pair <xx> to binary			i++;			if (('0'<=inStr[i]) && (inStr[i]<='9')) digit = inStr[i] - '0';			else if (('A'<=inStr[i]) && (inStr[i]<='F')) digit = inStr[i] - 'A' + 10;			else if (('a'<=inStr[i]) && (inStr[i]<='f')) digit = inStr[i] - 'a' + 10;				digit = digit << 4;			i++;			if (('0'<=inStr[i]) && (inStr[i]<='9')) digit += inStr[i] - '0';			else if (('A'<=inStr[i]) && (inStr[i]<='F')) digit += inStr[i] - 'A' + 10;			else if (('a'<=inStr[i]) && (inStr[i]<='f')) digit += inStr[i] - 'a' + 10;				i++;			outStr[++j] = digit;		} else {			// copy printable character directly			outStr[++j] = inStr[i];		}	}	outStr[0] = j;	return outStr;}BooleanIsHexChar(UInt16 inChar){	Boolean result = false;	if (('0'<=inChar) && (inChar<='9')) result = true;	else if (('A'<=inChar) && (inChar<='F')) result = true;	else if (('a'<=inChar) && (inChar<='f')) result = true;		return result;}// ---------------------------------------------------------------------------//		¥ Port_NumToHexStr// ---------------------------------------------------------------------------//	Return the hexidecimal string representing a protocol port numberStringPtrPort_NumToHexStr(SInt32 inValue, Str255	outStr){	LStr255 returnStr = "\p";	unsigned char digit;		digit = (inValue >> 12 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	digit = (inValue >> 8 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	digit = (inValue >> 4 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	digit = (inValue & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	return LString::CopyPStr(returnStr, outStr);}// ---------------------------------------------------------------------------//		¥ HW_NumToHexStr// ---------------------------------------------------------------------------//	Return the hexidecimal string representing an integer HW addressStringPtrHW_NumToHexStr(MACAddr_t* inValue, Str255	outStr){	UInt32	tData;	LStr255 returnStr = "\p";	unsigned char digit;		// first 4 bytes	tData = inValue->first4;		digit = (tData >> 28 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	digit = (tData >> 24 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	returnStr += "\p:";	digit = (tData >> 20 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	digit = (tData >> 16 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	returnStr += "\p:";	digit = (tData >> 12 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	digit = (tData >> 8 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	returnStr += "\p:";	digit = (tData >> 4 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	digit = (tData & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	returnStr += "\p:";		// last 2 bytes	tData = inValue->last2;	digit = (tData >> 12 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	digit = (tData >> 8 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	returnStr += "\p:";	digit = (tData >> 4 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	digit = (tData & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	returnStr += digit;	return LString::CopyPStr(returnStr, outStr);}// ---------------------------------------------------------------------------//		¥ Convert hardware MAC address string to MACAddr_t// ---------------------------------------------------------------------------BooleanHW_StrToInt(ConstStr255Param inStr, MACAddr_t *outValue){	UInt8	pos, len, count;	UInt8	digit;	UInt32	tData;		Boolean result;	result = true;	tData = 0;	pos = 0;	count = 0;	len = inStr[0];		do {		digit = inStr[++pos] | 0x20;	// convert to lower case		if (('0' <= digit) && (digit <= '9')) {			tData <<= 4;			tData += digit - '0';			count += 1;			continue;		}		if (('a' <= digit) && (digit <= 'f')) {			tData <<= 4;			tData += digit - 'a' + 10;			count += 1;			continue;		}		if (digit == ':') continue;		// digit is not 0-9, a-f, or :		result = false;		} while ((pos<len) && (result==true) && (count<8));		outValue->first4 = tData;	tData = 0;	do {		digit = inStr[++pos] | 0x20;	// convert to lower case		if (('0' <= digit) && (digit <= '9')) {			tData <<= 4;			tData += digit - '0';			count += 1;			continue;		}		if (('a' <= digit) && (digit <= 'f')) {			tData <<= 4;			tData += digit - 'a' + 10;			count += 1;			continue;		}		if (digit == ':') continue;		// digit is not 0-9, a-f, or :		result = false;		} while ((pos<len) && (result==true) && (count<12));	outValue->last2 = tData;		return result;}// ---------------------------------------------------------------------------//		¥ HEXStrToInt// ---------------------------------------------------------------------------//	Return the integer value represented by a hex string//		return 0 if invalid character detectedSInt32HEX_StrToInt(ConstStr255Param inStr){	UInt8	pos, len, count;	UInt8	digit;	UInt32	tData;		Boolean result;	result = true;	tData = 0;	pos = 0;	count = 0;	len = inStr[0];		do {		digit = inStr[++pos] | 0x20;	// convert to lower case		if (('0' <= digit) && (digit <= '9')) {			tData <<= 4;			tData += digit - '0';			count += 1;			continue;		}		if (('a' <= digit) && (digit <= 'f')) {			tData <<= 4;			tData += digit - 'a' + 10;			count += 1;			continue;		}		if (digit == ':') continue;		// digit is not 0-9, a-f, or :		result = false;		} while ((pos<len) && (result==true) && (count<8));		if (!result) tData = 0;	return tData;}#pragma mark --- IP Utilities ---// ---------------------------------------------------------------------------//		¥ Get IP Address Class// ---------------------------------------------------------------------------//	Recognize traditional IP address classes (A, B, C, Multicast, etc.)////	Return//    An integer representing the address class.//    	(if greater than or equal to 8, it's also the prefix length)//    classString set to name of IP address classSInt32GetIPAddressClass( SInt32 theIPAddress, Str255 classString ){SInt32	addressClass;	theIPAddress = (theIPAddress >> 24) & 0xff;	if (theIPAddress <= 126) {		addressClass = kIPAddressClassA;		LString::CopyPStr("\pClass A", classString);	} else {		if ((128 <= theIPAddress) && (theIPAddress <= 191)) {			addressClass = kIPAddressClassB;			LString::CopyPStr("\pClass B", classString);		} else {			if ((192 <= theIPAddress) && (theIPAddress <= 223)) {				addressClass = kIPAddressClassC;				LString::CopyPStr("\pClass C", classString);			} else {				if ((224 <= theIPAddress) && (theIPAddress <= 239)) {					addressClass = kIPAddressMulticast;					LString::CopyPStr("\pMulticast", classString);				} else {					if ((240 <= theIPAddress) && (theIPAddress <= 247)) {						addressClass = kIPAddressReserved;						LString::CopyPStr("\pReserved", classString);					} else {						if (127 == theIPAddress) {							addressClass = kIPAddressLoopback;							LString::CopyPStr("\pLoopback", classString);						} else {							addressClass = kIPAddressBroadcast;							LString::CopyPStr("\p ", classString);						}					}				}			}		}	}	return addressClass;}// ---------------------------------------------------------------------------//		¥ CalcPseudoGateway// ---------------------------------------------------------------------------//	Calculate an acceptable pseudo gateway addressUInt32CalcPseudoGateway(UInt32 inAddress){	UInt32	theNetmask;	UInt32	theGateway;		// determine network mask	if ( (inAddress & 0x80000000) == 0 )		theNetmask = 0xff000000;	else if ( (inAddress & 0xC0000000) == 0x80000000 )		theNetmask = 0xffff0000;	else if ( (inAddress & 0xE0000000) == 0xC0000000 )		theNetmask = 0xffffff00;	else		theNetmask = 0xffffffff;	// find an acceptable pseudo gateway address (not all 0s or 1s)	if ( ((inAddress ^ 0x00000001) & ~theNetmask) == 0 )		theGateway = inAddress + 1;								else if	(((inAddress ^ 0x00000001) & ~theNetmask) == ~theNetmask)		theGateway = inAddress - 1;							else			theGateway = inAddress ^ 0x00000001;	return theGateway;}// ---------------------------------------------------------------------------//		¥ FindRightBit// ---------------------------------------------------------------------------//	Find right most one bit in 32 bit data.//	If found, return bit position from MSB (1) to LSB (32)//	Returns zero if not foundUInt8FindRightBit(UInt32 inData, UInt8 inStart){	UInt32	mask, index;	for (index=inStart; index>=1; index--) {		mask = (UInt32)0x01 << (32-index);		if ( (mask&inData) != 0 ) {			return index;		}	}	return 0;}// ---------------------------------------------------------------------------//		¥ FindLeftBit// ---------------------------------------------------------------------------//	Find left most one bit in 32 bit data.//	If found, return bit position from MSB (1) to LSB (32)//	Returns zero if not foundUInt8FindLeftBit(UInt32 inData, UInt8 inStart){	UInt32	mask, index;	for (index=inStart; index<=32; index++) {		mask = (UInt32)0x01 << (32-index);		if ( (mask&inData) != 0 ) {			return index;		}	}	return 0;}// ---------------------------------------------------------------------------------//		¥ SetupIoctl// ---------------------------------------------------------------------------------//	Setup I_STR ioctlvoidSetupIoctl( struct strioctl *stri, long cmd, char* ptr, long len ){	stri->ic_cmd = cmd;	stri->ic_timout = -1;	stri->ic_len = len;	stri->ic_dp = ptr;}// ---------------------------------------------------------------------------//		¥ bzero// ---------------------------------------------------------------------------//	Init block of memory to zerovoid bzero(UInt8* start, UInt32 size){	do	{		*start++ = 0;	} while (--size);}// ---------------------------------------------------------------------------//		¥ Small copy routine// ---------------------------------------------------------------------------voidSmallStrCopy(UInt8 *inDest, const char *inSource){	UInt16 index = 0;	while ((inDest[index] = inSource[index]) != 0) index++;}// ---------------------------------------------------------------------------------//	¥ Hash Name// ---------------------------------------------------------------------------------//	Hash port name to a 32-bit valueUInt32 HashName(ConstStr255Param inName){	UInt32	result = 0;	UInt32	part = 0;	UInt32	index;		for (index=1; index<=inName[0]; index++) {		part = result >> 24;		// get left most byte		result = result << 8;		// shift left 8-bits		result += inName[index];	// add next character in name		result += part << 5;		// add back anything shifted out		result += part << 19;	}		return result;}// ---------------------------------------------------------------------------//		¥ IpSum// ---------------------------------------------------------------------------// Compute IP checksums// One's complement of 16 bit one's complement sum//UInt16 IpSum( UInt16* dataptr, UInt16* endptr){	// dataptr points to a sequence of 16 bit words to be checksummed	// endptr points to one past the last word to be included in checksum		UInt16	hi;	SInt32	sum;		// initialize checksum to zero	sum = 0;		// add in each word, accumulating overflow in the upper word	while (dataptr < endptr)		{		sum += *dataptr++;		};		// add in the overflow to form one's complement sum	hi = (sum >> 16);	sum &= 0x0000FFFF;	sum += hi;		// possibly one more	hi = (sum >> 16);	sum &= 0x0000FFFF;	sum += hi;		// return the one's complement of the one's complement sum	return ((UInt16)~sum);}//// Adjust IP checksum for modified data//  4/13/96 Peter Sichel - Original versionUInt16 AdjustIpSum( UInt16 oldsum, UInt16 olddata, UInt16 newdata){	// oldsum is the previous checksum value	// olddata is prevous value of word to be modified	// newdata is word to replace oldata		UInt16	hi;	SInt32	sum;		sum = ~oldsum & 0xFFFF;	// reverse one's complement to get previous sum	sum -= olddata;	// subtract old data	sum += newdata;	// add new data		// adjust to include carry for ones complement sum	hi = (sum >> 16);	sum &= 0x0000FFFF;	sum += hi;		// return the one's complement of the one's complement sum	return ((UInt16)~sum);}