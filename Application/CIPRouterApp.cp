// ===========================================================================//	CIPRouterApp.cp 		©1996 Sustainable Softworks. All rights reserved.// ===========================================================================////	This file contains the code for the IP router application object//  which handles application startup, the menu bar, and termination.////  Based on the <PP Starter Source>.cp file that is part of PowerPlant//	stationery.#include "CompileFlags.h"#include "CIPRouterApp.h"#include <LGrowZone.h>#include <LWindow.h>#include <PP_Messages.h>#include <PP_Resources.h>#include <LThread.h>#include <UThread.h>#include <UDrawingState.h>#include <UEnvironment.h>#include <UMemoryMgr.h>#include <UResourceMgr.h>#include <UReanimator.h>#include <URegistrar.h>#include <UWindows.h>#include <LEditField.h>#include "CTabButtons.h"#include <LMultiPanelView.h>#include "CDHCPStatusTable.h"#include "CDHCPStaticCfgTable.h"#include "CDHCPDynamicCfgTable.h"#include "CDHCPLeaseDataView.h"#include "CIPNumberListField.h"#include <LToggleButton.h>#include <LStdControl.h>#include <LGroupBox.h>#include <LCleanupTask.h>#include <OpenTransport.h>#include <OpenTptInternet.h>#include <TextEdit.h>#include <TextUtils.h>#include "MacSupport.h"#include "IPSupport.h"#include "ICAPI.h"#include "CNetscapeEvent.h"#include "CStartupThread.h"#include "CAuthorizationThread.h"#include "CGURLThread.h"#define DCON 0#include "DCon.h"// Include definitions for window objects managed by IProuterApp#include "CIPNumberEditField.h"#include "CIPNumberField.h"#include "CSubnetCalcWindow.h"#include "CSpinButton.h"#include "CSpinCaption.h"#include "CBoxCaption.h"#include "CMultiCaption.h"#include "CLogWindow.h"#include "CDisplayTable.h"#include "CEditField.h"#include "DemoStartupConst.h"#include "CHelpWindow.h"#include "CRegisterDialog.h"#include "CRegisterConst.h"#include "CAboutDialog.h"#include "CAboutConst.h"#include "CPrintView.h"//#include "CTabButtons.h"//#include "CIPConfigureHostsWindow.h"#include "URL_Caption.h"#include "CInterfacesWindow.h"#include "CRoutesWindow.h"#include "CGatewayWindow.h"#include "CPortMapWindow.h"#include "CPortMapTable.h"#include "CFilterWindow.h"#include "CFilterTable.h"#include "CInterfacesTable.h"#include "CRoutesTable.h"#include "CConfigDocument.h"//#include "CNatTask.h"#include "CIfCaption.h"#include <UExtractFromAEDesc.h>// data objects#include "CLogData.h"#include "CLogAction.h"#include "CLogFile.h"#include "CResidentIfInfo.h"#include "CProxyControl.h"#include "CInterfacesData.h"#include "CInterfacesAction.h"#include "CRoutesData.h"#include "CRoutesAction.h"#include "CPortMapData.h"#include "CPortMapAction.h"#include "CFilterData.h"#include "CFilterAction.h"#include "CGatewayAction.h"#include "CGatewayData.h"#include "CConnectionData.h"#include "CDeviceData.h"#include "CArpWindow.h"#include "CArpTable.h"#include "CArpData.h"#include "CArpAction.h"#include "CDHCPWindow.h"#include "CDHCPData.h"#include "CDHCPAction.h"#include "CDNSAction.h"const ResIDT	rALRT_NoThreadManager			= 1000;// GlobalsCIPRouterApp*		gAppObject;ICInstance			gICInstance;CLogData*			gLogData;CLogAction*			gLogAction;CResidentIfInfo*	gResInfo;CProxyControl*		gProxyControl;CInterfacesData*	gInterfacesData;CInterfacesAction*	gInterfacesAction;CRoutesData*		gRoutesData;CRoutesAction*		gRoutesAction;CPortMapData*		gPortMapData;CPortMapAction*		gPortMapAction;CFilterData*		gFilterData;CFilterAction*		gFilterAction;CGatewayAction*		gGatewayAction;CGatewayData*		gGatewayData;CConnectionData*	gConnectionData;CDeviceData*		gDeviceData;CArpData*			gArpData;CArpAction*			gArpAction;CDHCPData*			gDHCPData;CDHCPAction*		gDHCPAction;CDNSAction*			gDNSAction;UInt8				gApplicationMode;SInt32				gBaseLanguage;enum {	kOTVersion111 = 0x01118000};// ===========================================================================//		¥ Main Program// ===========================================================================void main(void){									// Set Debugging options	if (false) {		SetDebugThrow_(debugAction_Alert);		SetDebugSignal_(debugAction_Alert);		} else {		SetDebugThrow_(debugAction_Nothing);		SetDebugSignal_(debugAction_Nothing);	}#if defined(powerc)	// do nothing for PowerPC#else	// Increase the stack size by lowering the heap limit.	SetApplLimit((Ptr) ((unsigned long) GetApplLimit() - (64*1024)));#endif	InitializeHeap(10);				// Initialize Memory Manager									// Parameter is number of Master Pointer									//   blocks to allocate	// Initialize application mode from resource	gApplicationMode = kModeNone;	StringHandle	strH = ::GetString(rSTR_ApplicationMode);	if (strH != nil) {		if (::EqualString(*strH, "\pfba", false, false)) gApplicationMode |= kModeFBA;				if (::EqualString(*strH, "\pwamnet", false, false)) gApplicationMode |= kModeWamnet;		if (::EqualString(*strH, "\pwamnetfba", false, false)) gApplicationMode |= (kModeWamnet + kModeFBA);				if (::EqualString(*strH, "\papplefba", false, false)) gApplicationMode |= (kModeApple + kModeFBA);		dprintf("\nApplication mode: %#s", *strH);		::ReleaseResource((Handle)strH);	} else dprintf("\nApplication mode none");										// Initialize standard Toolbox managers	if (!(gApplicationMode & kModeFBA)) {		UQDGlobals::InitializeToolbox(&qd);	} else {		::InitGraf((Ptr) &qd.thePort);		::InitFonts();	}	// Check for thread manager.	if ( !UEnvironment::HasFeature( env_HasThreadsManager ) ) {		if (!(gApplicationMode & kModeFBA)) ::StopAlert(rALRT_NoThreadManager, nil);		::ExitToShell();	}	// Check for OT 1.1.1 or later	OSStatus err;	UInt32 otVersion;	err = Gestalt(gestaltOpenTptVersions, (long *) &otVersion);	if (err != noErr || otVersion < kOTVersion111) {		if (!(gApplicationMode & kModeFBA)) ::StopAlert(ALRT_OTVersion, nil);		::ExitToShell();					}		new LGrowZone(20000);			// Install a GrowZone function to catch									//    low memory situations.	// Run the application.	new UMainThread;	CIPRouterApp theApp;	theApp.AddAttachment(new LYieldAttachment);	theApp.Run();		// Make sure async tasks get cleaned up.	LCleanupTask::CleanUpAtExit();}// ---------------------------------------------------------------------------//		¥ CIPRouterApp// ---------------------------------------------------------------------------//	ConstructorCIPRouterApp::CIPRouterApp(){	// Register functions to create core PowerPlant classes	RegisterClass_(LButton);	RegisterClass_(LCaption);	RegisterClass_(LDialogBox);	RegisterClass_(LEditField);//	RegisterClass_(LListBox);	RegisterClass_(LPane);	RegisterClass_(LPicture);	RegisterClass_(LPlaceHolder);	RegisterClass_(LPrintout);	RegisterClass_(LScroller);	RegisterClass_(LStdControl);	RegisterClass_(LStdButton);	RegisterClass_(LStdCheckBox);	RegisterClass_(LStdRadioButton);	RegisterClass_(LStdPopupMenu);	RegisterClass_(LTextEditView);	RegisterClass_(LView);	RegisterClass_(LWindow);	RegisterClass_(LRadioGroup);	RegisterClass_(LTabGroup);	#ifdef PP_NewClasses//	RegisterClass_(LCicnButton);//	RegisterClass_(LOffscreenView);//	RegisterClass_(LActiveScroller);	RegisterClass_(LTable);//	RegisterClass_(LIconPane);	RegisterClass_(LGroupBox);//	RegisterClass_(LTextButton);#endif	// Register custom classes.	RegisterClass_(CIPNumberEditField);	RegisterClass_(CIPNumberField);	RegisterClass_(CSubnetCalcWindow);	RegisterClass_(CSpinButton);	RegisterClass_(CSpinCaption);	RegisterClass_(CMultiCaption);	RegisterClass_(CBoxCaption);	RegisterClass_(CLogWindow);	RegisterClass_(CDisplayTable);	RegisterClass_(CEditField);	RegisterClass_(CHelpWindow);	RegisterClass_(CRegisterDialog);	RegisterClass_(CAboutDialog);	RegisterClass_(CPrintView);	RegisterClass_(URL_Caption);	RegisterClass_(CTabButtons);	RegisterClass_(LMultiPanelView);	RegisterClass_(CDHCPStatusTable);	RegisterClass_(CDHCPStaticCfgTable);	RegisterClass_(CDHCPDynamicCfgTable);	RegisterClass_(CDHCPLeaseDataView);	RegisterClass_(CIPNumberListField);		RegisterClass_(LToggleButton);	RegisterClass_(LGroupBox);	RegisterClass_(CInterfacesWindow);	RegisterClass_(CInterfacesTable);	RegisterClass_(CRoutesWindow);	RegisterClass_(CGatewayWindow);	RegisterClass_(CPortMapWindow);	RegisterClass_(CFilterWindow);	RegisterClass_(CRoutesTable);	RegisterClass_(CIfCaption);	RegisterClass_(CPortMapTable);	RegisterClass_(CFilterTable);	RegisterClass_(CArpWindow);	RegisterClass_(CArpTable);	RegisterClass_(CDHCPWindow);	// standard initialization from LApplication	mState = programState_StartingUp;	sTopCommander = this;			// The default sleep time is 6 ticks (0.1 seconds). You may		// wish to change this, either by setting mSleepTime directly		// in the constructor of your Application subclass or by		// calling SetSleepTime()	Str31 str;	::GetIndString(str, rSTRN_OptionSettings, kOptionSleepTime);	if ( BeginsWith(str, "\pSleepTime") && GetKeywordValue(str, str) ) {		long value;		::StringToNum(str, &value);		SetSleepTime(value);	}	else SetSleepTime(6);										// Check for Color QuickDraw	SInt32		qdVersion = gestaltOriginalQD;	::Gestalt(gestaltQuickdrawVersion, &qdVersion);	UEnvironment::SetFeature(env_SupportsColor,							 (qdVersion > gestaltOriginalQD));							 	SetUseSubModelList(true);	SetModelKind(cApplication);			// More initialization	mRegKey = 0;	mStartupPause = true;	mXTime = 0;	mTrialFlag = false;	mStartupFlag = false;		mMenuFlag = false;		// disable menu's until user accepts terms	mBeginEvents = false;	mPrefsFile = nil;	mStartupDialog = nil;	mStartupThread = nil;	mAuthorizationThread = nil;	mGURLThread = nil;	mLaunchGURL = false;	mStartupDialog = nil;	mRegisterDialog = nil;	mDocument = nil;	mLogFile = nil;	// global data and action pointers	gLogData = nil;	gInterfacesData = nil;	gRoutesData = nil;	gPortMapData = nil;	gFilterData = nil;	gArpData = nil;	gDHCPData = nil;	gGatewayData = nil;	gConnectionData = nil;	gDeviceData = nil;	gLogAction = nil;	gProxyControl = nil;	gInterfacesAction = nil;	gRoutesAction = nil;	gPortMapAction = nil;	gFilterAction = nil;	gGatewayAction = nil;	gArpAction = nil;	gDHCPAction = nil;	gDNSAction = nil;	gResInfo = nil;		gBaseLanguage = 0;}// ---------------------------------------------------------------------------//		¥ ~CIPRouterApp			// replace this with your App type// ---------------------------------------------------------------------------//	Destructor//CIPRouterApp::~CIPRouterApp(){	if (mStartupThread) mStartupThread->DeleteThread();	if (mLogFile) delete mLogFile;	if (mPrefsFile) delete mPrefsFile;		if (mGURLThread) mGURLThread->DeleteThread();	if (gICInstance) ICStop(gICInstance);	// Clean up at the end#if powerc	::CloseOpenTransport();#endif}// ---------------------------------------------------------------------------//		¥ Run// ---------------------------------------------------------------------------//	Run the Application by processing events until quittingvoidCIPRouterApp::Run(){	try {		if (!(gApplicationMode & kModeFBA)) MakeMenuBar();		MakeModelDirector();				mState = programState_ProcessingEvents;		Initialize();				SwitchTarget(this);		::InitCursor();		if (!(gApplicationMode & kModeFBA)) UpdateMenus();	}			// You should catch all exceptions in your code.		// If an exception reaches here, we'll signal		// and go on to the event loop.		catch(...) {		SignalPStr_("\pApp Initialization failed.");	}	// wait for startup to complete before processing events	while (!mBeginEvents) LThread::Yield();		while (mState != programState_Quitting) {		try {			ProcessNextEvent();		}					// You should catch all exceptions in your code.			// If an exception reaches here, we'll signal			// and continue running.				catch(...) {			SignalPStr_("\pException caught in LApplication::Run");		}	}}// ---------------------------------------------------------------------------//		¥ Initialize// ---------------------------------------------------------------------------//	Last chance to initialize Application before processing eventsvoidCIPRouterApp::Initialize(){		// allocate data and action objects	// create logging objects first so others can use them	if (gLogData == nil) {		gLogData = new CLogData();		ThrowIfNil_(gLogData);	}	if (gLogAction == nil) {		gLogAction = new CLogAction();		ThrowIfNil_(gLogAction);	}	if (mLogFile == nil) {		mLogFile = new CLogFile();		ThrowIfNil_(mLogFile);	}	// create data before actions!	if (gInterfacesData == nil) {		gInterfacesData = new CInterfacesData();		ThrowIfNil_(gInterfacesData);	}	if (gRoutesData == nil) {		gRoutesData = new CRoutesData();		ThrowIfNil_(gRoutesData);	}	if (gPortMapData == nil) {		gPortMapData = new CPortMapData();		ThrowIfNil_(gPortMapData);	}	if (gFilterData == nil) {		gFilterData = new CFilterData();		ThrowIfNil_(gFilterData);	}	if (gArpData == nil) {		gArpData = new CArpData();		ThrowIfNil_(gArpData);	}	if (gDHCPData == nil) {		gDHCPData = new CDHCPData();		ThrowIfNil_(gDHCPData);	}	if (gGatewayData == nil) {		gGatewayData = new CGatewayData();		ThrowIfNil_(gGatewayData);	}	if (gConnectionData == nil) {		gConnectionData = new CConnectionData();		ThrowIfNil_(gConnectionData);	}	if (gDeviceData == nil) {		gDeviceData = new CDeviceData();		ThrowIfNil_(gDeviceData);	}	// Action objects	if (gProxyControl == nil) {		gProxyControl = new CProxyControl();		ThrowIfNil_(gProxyControl);	}	if (gInterfacesAction == nil) {		gInterfacesAction = new CInterfacesAction();		ThrowIfNil_(gInterfacesAction);	}	if (gRoutesAction == nil) {		gRoutesAction = new CRoutesAction();		ThrowIfNil_(gRoutesAction);	}	if (gPortMapAction == nil) {		gPortMapAction = new CPortMapAction();		ThrowIfNil_(gPortMapAction);	}	if (gFilterAction == nil) {		gFilterAction = new CFilterAction();		ThrowIfNil_(gFilterAction);	}	if (gGatewayAction == nil) {		gGatewayAction = new CGatewayAction();		ThrowIfNil_(gGatewayAction);	}	if (gArpAction == nil) {		gArpAction = new CArpAction();		ThrowIfNil_(gArpAction);	}	if (gDHCPAction == nil) {		gDHCPAction = new CDHCPAction();		ThrowIfNil_(gDHCPAction);	}	if (gDNSAction == nil) {		gDNSAction = new CDNSAction();		ThrowIfNil_(gDNSAction);	}	if (gResInfo == nil) {		// allocate after others since it contains action routines that use them		gResInfo = new CResidentIfInfo();		ThrowIfNil_(gResInfo);	}	gAppObject = this;	// initialize Internet Config System	gICInstance = nil;	::ICStart(&gICInstance, 'IPnl');	if (gICInstance) {		ICError err;		// find config file		err = ICFindConfigFile(gICInstance, 0, nil);	}    // Add our own item to application help menu    MenuHandle mh;    ::HMGetHelpMenuHandle(&mh);    ::AppendResMenu(mh, (OSType)'Help');	// Create thread to step through startup sequence	if (!mStartupThread) {		mStartupThread = new CStartupThread(this);		ThrowIfNil_(mStartupThread);	}	// Launch thread to begin sequence	mStartupThread->Resume();}// ---------------------------------------------------------------------------//		¥ Startup0// ---------------------------------------------------------------------------//	Open Prefs fileOSStatusCIPRouterApp::Startup0(){	OSStatus result = kSTNoError;	try {		// get preferences (creates new preferences file & folder if none exists)		mAppResFile = CurResFile();		// remember application res file		if (!(gApplicationMode & kModeApple)) {			mPrefsFile = new LPreferencesFile("\pIPNetRouter Prefs");			ThrowIfNil_( mPrefsFile );			mPrefsFile->OpenOrCreateResourceFork(				fsCurPerm, (OSType)'IPnl', (OSType)'pref', smRoman ); // privs, creator, type, script		}	}	catch (...) {		if (!(gApplicationMode & kModeFBA)) {			UDesktop::Deactivate();		// Alert will swallow Deactivate event			::Alert(ALRT_PrefsError, nil);			UDesktop::Activate();			result = kSTQuit;			// try to exit cleanly (unless FBA)		}		mBeginEvents = true;		// begin processing events	}	return result;}// ---------------------------------------------------------------------------//		¥ Startup1// ---------------------------------------------------------------------------//	Check for registrationOSStatusCIPRouterApp::Startup1(){	RegInfo_t	regInfo;	LStr255 	regText;	LStr255		regTextNoDate;	LStr255 	regText68K;	// 68K only	LStr255		regText68KNoDate;	Str255		str;	UInt32		regKey;	UInt8		len;	OSStatus	result = kSTNoError;	try {		// get registration data if any		bzero((UInt8*)&regInfo, sizeof(RegInfo_t));		{	// begin scope for resource object			// try read old reg info			StResource regData( (ResType)'RegD',				rRegD_RegistrationData, false, false );	// inThrowFail, inGet1Resource			if (regData.mResourceH) {				len = ((UInt8*)(*regData.mResourceH))[index_RNam]+1;				::BlockMove( &(*regData.mResourceH)[index_RNam], regInfo.name, len );				len = ((UInt8*)(*regData.mResourceH))[index_ROrg]+1;				::BlockMove( &(*regData.mResourceH)[index_ROrg], regInfo.organization, len );				len = ((UInt8*)(*regData.mResourceH))[index_RNum]+1;				::BlockMove( &(*regData.mResourceH)[index_RNum], regInfo.copies, len );				::BlockMove( &(*regData.mResourceH)[index_RKey], &regKey, 4 );				IP_NumToHexStr(regKey, regInfo.key);			}		}		{	// begin scope for resource object			// try read new reg info (override old info)			StResource regData( (ResType)'RegD',				rRegD_RegistrationData2, false, false );	// inThrowFail, inGet1Resource			if (regData.mResourceH) {				LString::CopyPStr((UInt8*)(*regData.mResourceH), str);				StringToRegInfo(str, &regInfo);			}		}		do {			// check for pirated keys			if (::EqualString(regInfo.name, "\pThe Mac Community", false, false)) break;			if (::EqualString(regInfo.name, "\pName", false, false)) break;			if (::EqualString(regInfo.name, "\pMoonDark", false, false)) break;			if (::EqualString(regInfo.name, "\pPPC", false, false)) break;			if (::EqualString(regInfo.name, "\pRegistered", false, false)) break;			if (::EqualString(regInfo.name, "\pServer Surfer", false, false)) break;			if (::EqualString(regInfo.name, "\pSurfer", false, false)) break;			if (::EqualString(regInfo.name, "\pMidiman", false, false)) break;			if (::EqualString(regInfo.name, "\pNighthawk", false, false)) break;			if (::EqualString(regInfo.name, "\pCendryom", false, false)) break;			if (::EqualString(regInfo.name, "\ppet", true, false)) break;			if (::EqualString(regInfo.name, "\peff", false, false)) break;			if (::EqualString(regInfo.name, "\p", false, false)) break;			if (::EqualString(regInfo.organization, "\pWorldwide", false, false)) break;			if (::EqualString(regInfo.organization, "\pSergioMatic", false, false)) break;			if (::EqualString(regInfo.organization, "\pprivat", false, false)) break;			if (IsDigitString(regInfo.copies)) {				long rNum;				::StringToNum(regInfo.copies, &rNum);				if (rNum > 99) break;			}						// build registration string to validate checksum			regText = regInfo.name;			regText += regInfo.organization;			regText += regInfo.copies;			regTextNoDate		= regText;			regText68KNoDate	= regText;			regText				+= regInfo.date;			regText68K			= regText;			regText				+= kRegisterProductName;			regTextNoDate		+= kRegisterProductName;			regText68K			+= kRegisterProductName68K;			regText68KNoDate	+= kRegisterProductName68K;			regKey = HexToNum(regInfo.key);			// disallow Apple key in UI mode			if ((regKey == 0x30323739) && !(gApplicationMode & kModeFBA)) break;			// validate registration if any			if ( (regKey == GetKey(regText)) || (regKey == GetKey(regTextNoDate)) ) {				mStartupFlag = true;				mRegKey = regKey;				result = kSTIsRegistered;			}			else if ( (regKey == GetKey(regText68K)) || (regKey == GetKey(regText68KNoDate)) ) {//				#if powerc				// test 68K only on PPC				#if !powerc					mStartupFlag = true;					mRegKey = regKey;					result = kSTIsRegistered;				#else					UDesktop::Deactivate();		// Alert will swallow Deactivate event					::Alert(ALRT_68KOnly, nil);					UDesktop::Activate();				#endif			}		} while (false);	}	catch (...) {		if (!(gApplicationMode & kModeFBA)) {			UDesktop::Deactivate();		// Alert will swallow Deactivate event			::Alert(ALRT_PrefsError, nil);			UDesktop::Activate();		}		mBeginEvents = true;		// begin processing events		result = kSTQuit;			// try to exit cleanly	}	return result;}// ---------------------------------------------------------------------------//		¥ Startup2// ---------------------------------------------------------------------------//	ExpirationOSStatusCIPRouterApp::Startup2(){	UInt32		cTime;	OSStatus	result = kSTQuit;			// default try to exit cleanly	try {		// get expiration date		// first try XIPNR resource file		mDemoExpireFile = new LPreferencesFile("\pXIPNR2");		ThrowIfNil_( mDemoExpireFile );		mDemoExpireFile->OpenOrCreateResourceFork(			fsCurPerm, (OSType)'IPnl', (OSType)'pref', smRoman ); // privs, creator, type, script		{	// begin scope for resource objects			StNewResource xDate( (ResType)'XDat',				rRegD_RegistrationData, 4, true );	// inDefaultSize, inGet1Resource			if (xDate.mResourceH == nil) mXTime = 0;	// can't get resource, force expired			else {				if (xDate.ResourceExisted()) {					// resource existed, use value from resource					mXTime = *((unsigned long*)(*xDate.mResourceH));				} else {					// resource doesn't exist, use current time to establish xDate					::GetDateTime(&cTime);					mXTime = cTime + kDTime;				}				// set resource value				*((unsigned long*)(*xDate.mResourceH)) = mXTime;			}		}		// close XIPN resource file		// *** caution only close file after resource objects are out of scope		mDemoExpireFile->CloseResourceFork();				do {			// check demo expiration period			// (within 21 days of expiration date)			::GetDateTime(&cTime);			if ((cTime > mXTime) || ((mXTime - cTime) > kDTime)) {				break;					}			// check for matching expiration dates			int prevResFile = CurResFile();		// remember res file so we can put it back			::UseResFile(mAppResFile);			{	// begin scope for resource object				StNewResource xDate( (ResType)'XDat',					rRegD_RegistrationData, 4, true );	// inDefaultSize, inGet1Resource				if (xDate.mResourceH != nil) {					if (xDate.ResourceExisted()) {						// resource existed, use value from resource						cTime = *((unsigned long*)(*xDate.mResourceH));						if (cTime != mXTime) {							// restore previous res file							::UseResFile(prevResFile);							break;						}					}					// resource didn't exist, set resource value in App file					*((unsigned long*)(*xDate.mResourceH)) = mXTime;				}			}	// end scope for resource object (write to resource file)			// restore previous res file			::UseResFile(prevResFile);						mTrialFlag = true;			result = kSTNoError;		} while (false);	}	catch (...) {		if (!(gApplicationMode & kModeFBA)) {			UDesktop::Deactivate();		// Alert will swallow Deactivate event			::Alert(ALRT_PrefsError, nil);			UDesktop::Activate();		}		mBeginEvents = true;		// begin processing events		result = kSTQuit;			// try to exit cleanly	}	return result;}// ---------------------------------------------------------------------------//		¥ Startup3// ---------------------------------------------------------------------------//	Demo startup dialogOSStatusCIPRouterApp::Startup3(){	Str255		str;	OSStatus	result = kSTNoError;	try {				// create Demo Startup window		mStartupDialog = (LDialogBox*)LWindow::CreateWindow(rPPob_DemoStartupWindow, this);		ThrowIfNil_( mStartupDialog );		// connect register button (control) with dialog (listener)		LButton* theButton = (LButton*)mStartupDialog->FindPaneByID( kRegisterButton );		if (theButton) theButton->AddListener( mStartupDialog );				// display expiration date		::DateString(mXTime, abbrevDate, str, nil);		LCaption	*dateCaption, *expireCaption;		dateCaption = (LCaption*) mStartupDialog->FindPaneByID( kExpireDate );		ThrowIfNil_(dateCaption);		dateCaption->SetDescriptor(str);		// get expire caption		expireCaption = (LCaption*) mStartupDialog->FindPaneByID( kExpireCaption );		ThrowIfNil_(expireCaption);		do {			// check for tampering			// get the actual text displayed			LTextEditView	*demoStartupTextPane;			demoStartupTextPane = (LTextEditView*) mStartupDialog->FindPaneByID( kTermsAndConditionsPane );			ThrowIfNil_( demoStartupTextPane );			TEHandle	myTextEditH = demoStartupTextPane->GetMacTEH();			CharsHandle	theTextH 	= TEGetText(myTextEditH);			SInt32		textSize 	= (**myTextEditH).teLength;			textSize -= 3;	// ignore last few in case length is odd			// calculate IP checksum			UInt16 *dataPtr, *endPtr;			dataPtr = (UInt16*)(*theTextH);			endPtr	= (UInt16*)(*theTextH + textSize);			UInt16 sum = IpSum(dataPtr, endPtr);			// check against previously recorded checksum value ***			if (sum != 56760) {				expireCaption->SetDescriptor("\pSorry, this demo copy is damaged.");				dateCaption->SetValue(sum);				break;			}			// check demo expiration			if (mTrialFlag == false) {				expireCaption->SetDescriptor("\pSorry, this demo has expired");				break;					}						mStartupFlag = true;		} while (false);	}	catch (...) {		if (!(gApplicationMode & kModeFBA)) {			UDesktop::Deactivate();		// Alert will swallow Deactivate event			::Alert(ALRT_PrefsError, nil);			UDesktop::Activate();		}		mBeginEvents = true;		// begin processing events		result = kSTQuit;			// try to exit cleanly	}	return result;}// ---------------------------------------------------------------------------//		¥ AppStarted// ---------------------------------------------------------------------------//	Return whether application has started (registration confirmed...)BooleanCIPRouterApp::AppStarted(){	return (mStartupFlag && mMenuFlag);}// ---------------------------------------------------------------------------//		¥ CheckAuthorization// ---------------------------------------------------------------------------//	Launch thread to test network authorizationBooleanCIPRouterApp::CheckAuthorization(){	Boolean result = false;	if (false) {	// *** testing//	if (gApplicationMode & kModeApple) {		// Create thread to step through Authorization sequence		if (!mAuthorizationThread) {			mAuthorizationThread = new CAuthorizationThread(this);			if (mAuthorizationThread) {				// Launch thread to begin sequence				mAuthorizationThread->Resume();				result = true;			}		}	}	return result;}// ---------------------------------------------------------------------------//		¥ StartUp// ---------------------------------------------------------------------------//	Perform actions at application start up when launched without any//	documents.voidCIPRouterApp::StartUp(){	OSErr	theErr;	FSSpec	myFileSpec;	FInfo	myFndrInfo;	SInt16	theVRef;	SInt32	theDirID;	Boolean	createFolder = false;	Str255	str;	Str255	routerConfigName;	dprintf("\nIPNR Application Startup");	// get PPPName Option	::GetIndString(str, rSTRN_OptionSettings, kOptionPPPName);	if ( BeginsWith(str, "\pPPPName") ) {		GetKeywordValue(str, gResInfo->mPPPName);	}	// get ConfigFileName Option (if any)	::GetIndString(str, rSTRN_OptionSettings, kOptionConfigFileName);	if ( BeginsWith(str, "\pConfigFileName") ) {		GetKeywordValue(str, routerConfigName);	}		// try to open Config File in prefs folder	// find folder	theErr = ::FindFolder(kOnSystemDisk, kPreferencesFolderType,					createFolder, &theVRef, &theDirID);						if (theErr == noErr) {		// create FSSpec		::FSMakeFSSpec(theVRef, theDirID, routerConfigName, &myFileSpec);		// check that file exists		theErr = ::FSpGetFInfo(&myFileSpec, &myFndrInfo);		if (theErr == noErr) {			// try to process it			dprintf("\nOpening config file: %#s", routerConfigName);			OpenDocument(&myFileSpec);		}	}		if (theErr != noErr) {		if (gApplicationMode & kModeApple) {			// quit since there is nothing to do			ObeyCommand(cmd_Quit, nil);			dprintf("\nConfig file %#s was not found, Do Quit", routerConfigName);		}		else {			// open an empty document since we didn't find Router Config			ObeyCommand(cmd_New, nil);		}	}}// ---------------------------------------------------------------------------//		¥ Splash Screen// ---------------------------------------------------------------------------LWindow*CIPRouterApp::SplashUp(){	GrafPtr		theWindowP;	LWindow		*theWindow;	// look for window by name	theWindowP = FindNamedIDWindow( kNameAbout );	if (theWindowP != nil) {	// Already exists?		// yes, bring to front		theWindow = LWindow::FetchWindowObject(theWindowP);		theWindow->Show();		UDesktop::SelectDeskWindow( theWindow );	} else {		// create About Box window		theWindow = (CAboutDialog*)LWindow::CreateWindow(rPPob_AboutBoxWindow, this);		ThrowIfNil_( theWindow );	}	// force it to draw since we're not handling update events yet	theWindow->UpdatePort();		return theWindow;}voidCIPRouterApp::SplashDown(){	GrafPtr		theWindowP;	LWindow		*theWindow;	// look for window by name	theWindowP = FindNamedIDWindow( kNameAbout );	if (theWindowP != nil) {	// Already exists?		// yes, bring down		theWindow = LWindow::FetchWindowObject(theWindowP);		if (theWindow) delete theWindow;	}}voidCIPRouterApp::BeginEvents(){	mBeginEvents = true;	// begin processing events}// ---------------------------------------------------------------------------//		¥ ShowStartupDialog// ---------------------------------------------------------------------------voidCIPRouterApp::ShowStartupDialog(){	if (mStartupDialog) {		mStartupDialog->Show();		// force dialog to display since we're not handling update events yet.		mStartupDialog->UpdatePort();	}}// ---------------------------------------------------------------------------//		¥ ShowAboutBox// ---------------------------------------------------------------------------//	Display the About Box for the ApplicationvoidCIPRouterApp::ShowAboutBox(){	GrafPtr		theWindowP;	CAboutDialog*	theWindow;	// look for window by name	theWindowP = FindNamedIDWindow( kNameAbout );	if (theWindowP != nil) {	// Already exists?		// yes, bring to front		theWindow = (CAboutDialog*)LWindow::FetchWindowObject(theWindowP);		theWindow->Show();		UDesktop::SelectDeskWindow( theWindow );		LoadSplash(theWindow);			// update reg info	} else {		// create About Box window		theWindow = (CAboutDialog*)LWindow::CreateWindow(rPPob_AboutBoxWindow, this);		ThrowIfNil_( theWindow );				LoadSplash(theWindow);	}}// ---------------------------------------------------------------------------//		¥ LoadSplash// ---------------------------------------------------------------------------//	Load the Splash Screen to show version and registration data if anyvoidCIPRouterApp::LoadSplash(CAboutDialog* inWindow){	GrafPtr			theWindowP;	CAboutDialog*	theWindow;		if (inWindow == nil) {		theWindowP = FindNamedIDWindow( kNameAbout );		if (theWindowP != nil) {	// Already exists?			// yes, bring to front			theWindow = (CAboutDialog*)LWindow::FetchWindowObject(theWindowP);			theWindow->Show();			UDesktop::SelectDeskWindow( theWindow );			// force it to draw since we may not be handling update events yet			theWindow->LoadAboutBox();			theWindow->UpdatePort();		}	} else {		// force it to draw since we may not be handling update events yet		inWindow->LoadAboutBox();		inWindow->UpdatePort();	}}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	Respond to commandsBooleanCIPRouterApp::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;	GrafPtr		theWindowP;	LWindow*    theWindow;		switch (inCommand) {			// Deal with command messages (defined in PP_Messages.h).		// Any that you don't handle will be passed to LApplication		case cmd_ConfigureIF:			// look for window by name			theWindowP = FindNamedIDWindow( kNameInterfaces );			if (theWindowP != nil) {	// Already exists?				// yes, bring to front				theWindow = LWindow::FetchWindowObject(theWindowP);				theWindow->Show();				UDesktop::SelectDeskWindow( theWindow );				// if Option key is down, restore interfaces				if (OptionKeyDown()) gInterfacesAction->ProviderWillClose();			} else {				cmdHandled = LDocApplication::ObeyCommand(cmd_New, ioParam);			}			break;		case cmd_RouterLog:			// Create the Log Window			theWindow = InvokeWindow(kNameLog, this);			if (theWindow) theWindow->Show();			break;		case cmd_SubnetCalculator:			// Create the Subnet Calculator Window			theWindow = InvokeWindow(kNameSubnetCalculator, this);			if (theWindow) theWindow->Show();			break;		case cmd_Connect:			gResInfo->ConnectPPP(nil);			break;		case cmd_Disconnect:			gResInfo->DisconnectPPP(nil);			break;		case cmd_Reset:			// reset PPP controller			gResInfo->ResetPPP();			break;				case msg_DemoRegistrationConfirmed:			mStartupFlag = true;			if (!(gApplicationMode & kModeFBA)) LoadSplash(nil);			if (mMenuFlag) break;	// if App has already started, we're done									// otherwise fall through		case msg_DemoAcceptButton:			if (mStartupDialog) mStartupDialog->DoClose();			mStartupDialog = nil;	// defensive, in case we pass this way again			// if demo isn't expired or damaged			if (mStartupFlag == true) {				CheckAuthorization();		// check network authorization				gResInfo->InitNSL();		// open NSL session				// open any Windows that were open when we last quite the app				if ( mPrefsFile && !(gApplicationMode & kModeFBA) ) {					StNewResource windowOpen( (ResType)'WOpn',						(ResIDT)128, kMaxOpenWindows*4, true );	// inDefaultSize, inGet1Resource					if (windowOpen.mResourceH) {						UInt8	index;						SInt32	windowCommand;						for (index=0; index<kMaxOpenWindows; index++) {							windowCommand = ((SInt32*)(*windowOpen.mResourceH))[index];							if (windowCommand > 0) ObeyCommand(windowCommand, nil);						}					}				}				mMenuFlag = true;		// turn on menus				// if there's an Apple Event URL, do it.				if (mLaunchGURL) {					mGURLThread->Resume();					mLaunchGURL = false;				}							}			else {				Send_Netscape_OpenURL("https://www.quicomm2.com/cgi-local/net_reg.cgi?m=ssoft");				SendAEQuit();		// otherwise quite the application			}			break;				case cmd_Registration:			// menu command		case msg_DemoRegisterButton:	// synthetic command from dialog button			// create Register window			mRegisterDialog = (LDialogBox*)LWindow::CreateWindow(rPPob_RegisterWindow, this);			ThrowIfNil_( mRegisterDialog );			break;				case msg_DemoCancelButton:			if (mStartupDialog) mStartupDialog->DoClose();			SendAEQuit();			break;		case cmd_WWWRegistration:			Send_Netscape_OpenURL("https://www.quicomm2.com/cgi-local/net_reg.cgi?m=ssoft");			break;        case cmd_Help_IPNetRouter:										// Create the Help Window			CHelpWindow		*theWindow;			try {    			theWindow = (CHelpWindow*)InvokeWindow(kNameHelp, this);    			theWindow->Show();    			theWindow->LoadTextInWindow(rTEXT_Help_IPNetRouter);			}			catch (...) {			    gLogAction->LogText("\p\rCIPRouterApp: unexpected result trying to display help text");			}                      break;		default:			cmdHandled = LDocApplication::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}// ---------------------------------------------------------------------------//		¥ FindCommandStatus// ---------------------------------------------------------------------------//	This function enables menu commands.//voidCIPRouterApp::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	UInt16		&outMark,	Str255		outName){		switch (inCommand) {			// Return menu item status according to command messages.		// Any that you don't handle will be passed to LApplication		case cmd_New:		case cmd_Open:			outEnabled = true;			break;		case cmd_ConfigureIF:				outEnabled = mMenuFlag;	// enable the Interfaces Window			outUsesMark = true;			outMark = (FindNamedIDWindow(kNameInterfaces) != nil) ?				checkMark : noMark;			break;		case cmd_ConfigureRt:				outEnabled = false;		// enable the Routes Window			outUsesMark = true;			outMark = (FindNamedIDWindow(kNameRoutes) != nil) ?				checkMark : noMark;			break;		case cmd_Gateway:				outEnabled = false;	// enable the Gateway Window			outUsesMark = true;			outMark = (FindNamedIDWindow(kNameGateway) != nil) ?				checkMark : noMark;			break;		case cmd_PortMap:				outEnabled = false;	// enable the Port Mapping Window			outUsesMark = true;			outMark = (FindNamedIDWindow(kNamePortMap) != nil) ?				checkMark : noMark;			break;		case cmd_Filter:				outEnabled = false;	// enable the Filter Window			outUsesMark = true;			outMark = (FindNamedIDWindow(kNameFilter) != nil) ?				checkMark : noMark;			break;		case cmd_Arp:				outEnabled = false;	// enable the Arp Window			outUsesMark = true;			outMark = (FindNamedIDWindow(kNameARP) != nil) ?				checkMark : noMark;			break;		case cmd_DHCP:				outEnabled = false;	// enable the DHCP Window			outUsesMark = true;			outMark = (FindNamedIDWindow(kNameDHCP) != nil) ?				checkMark : noMark;			break;		case cmd_RouterLog:				outEnabled = mMenuFlag;	// enable the Log Window			outUsesMark = true;			outMark = (FindNamedIDWindow(kNameLog) != nil) ?				checkMark : noMark;			break;		case cmd_SubnetCalculator:				outEnabled = mMenuFlag;	// enable the Subnet Calculator Window			outUsesMark = true;			outMark = (FindNamedIDWindow(kNameSubnetCalculator) != nil) ?				checkMark : noMark;			break;		case cmd_Connect:			outEnabled = false;			if (gConnectionData) {				outEnabled = (gConnectionData->GetDataLinkState() == kLinkStateIdle);			}			break;		case cmd_Disconnect:			outEnabled = false;			if (gConnectionData) {				outEnabled = ((gConnectionData->GetDataLinkState() != kLinkStateNone) &&							  (gConnectionData->GetDataLinkState() != kLinkStateIdle));			}			break;		case cmd_Reset:			outEnabled = false;			if (gConnectionData) {				outEnabled = (gConnectionData->GetDataLinkState() != kLinkStateNone);			}			break;		default:			LDocApplication::FindCommandStatus(inCommand, outEnabled,												outUsesMark, outMark, outName);			break;	}}// ---------------------------------------------------------------------------//		¥ Allow Sub Removal// ---------------------------------------------------------------------------//	Override to track when document is closedBooleanCIPRouterApp::AllowSubRemoval(LCommander*	inSub){	if (inSub == mDocument) mDocument = nil;	return true;}// ---------------------------------------------------------------------------//		¥ DoQuit// ---------------------------------------------------------------------------//	Quit the ApplicationvoidCIPRouterApp::DoQuit(	SInt32	inSaveOption){	GrafPtr		theWindowP;	LWindow		*theWindow;	UInt8		index;	if (AttemptQuit(inSaveOption)) {		mState = programState_Quitting;		SetUpdateCommandStatus(false);		// log that we're quiting		gLogAction->LogText("\p\rDo Quit");		// check for disconnect at quit		if (gGatewayData->GetDataDisconnectAtQuit()) {			ObeyCommand(cmd_Disconnect, nil);		}		if ( (gResInfo) && (gDeviceData->AnyNewInterfaces()) ) {			// restore Prefs file and stop any pending PPP activity just in case			gResInfo->Reset(true);			// Remove any interfaces we added			gInterfacesAction->RemoveAll();		}		if (!(gApplicationMode & kModeFBA) && !(gApplicationMode & kModeApple)) {			// set resource in prefs file to remember which windows were open			StNewResource windowOpen( (ResType)'WOpn',				(ResIDT)128, kMaxOpenWindows*4, true );	// inDefaultSize, inGet1Resource			if (windowOpen.mResourceH) {				for (index=0; index<kMaxOpenWindows; index++) {					((SInt32*)(*windowOpen.mResourceH))[index] = 0;				}			}			index = 0;					// Make sure windows are closed in an orderly manner			// Configure Interface Window			theWindowP = FindNamedIDWindow(kNameInterfaces);			if (theWindowP != nil) {	// exists?				// yes, close it				theWindow = LWindow::FetchWindowObject(theWindowP);				theWindow->AttemptClose();				// interfaces window will open automatically				//((SInt32*)(*windowOpen.mResourceH))[index] = cmd_ConfigureIF;				//index += 1;			}			// Subnet Calculator Window			theWindowP = FindNamedIDWindow(kNameSubnetCalculator);			if (theWindowP != nil) {	// exists?				// yes, close it				theWindow = LWindow::FetchWindowObject(theWindowP);    			theWindow->AttemptClose();    			if (index < kMaxOpenWindows) {        			((SInt32*)(*windowOpen.mResourceH))[index] = cmd_SubnetCalculator;        			index += 1;        		}			}			// Log Window			theWindowP = FindNamedIDWindow( kNameLog );			if (theWindowP != nil) {	// exists?				// yes, close it				theWindow = LWindow::FetchWindowObject(theWindowP);				theWindow->AttemptClose();    			if (index < kMaxOpenWindows) {        			((SInt32*)(*windowOpen.mResourceH))[index] = cmd_RouterLog;        			index += 1;        		}			}		}		// delete ResInfo before other data objects since it uses them		if (gResInfo) delete gResInfo;		gResInfo = nil;			// release action routines before corresponding data		if (gDHCPAction) delete gDHCPAction;		gDHCPAction = nil;		if (gArpAction) delete gArpAction;		gArpAction = nil;		if (gFilterAction) delete gFilterAction;		gFilterAction = nil;		if (gInterfacesAction) delete gInterfacesAction;		gInterfacesAction = nil;		if (gRoutesAction) delete gRoutesAction;		gRoutesAction = nil;		if (gGatewayAction) delete gGatewayAction;	// delete after interfaces		gGatewayAction = nil;		if (gPortMapAction) delete gPortMapAction;	// after gateway		gPortMapAction = nil;		if (gDNSAction) delete gDNSAction;			// after portmap		gDNSAction = nil;		// release data objects		if (gDHCPData) delete gDHCPData;		gDHCPData = nil;		if (gArpData) delete gArpData;		gArpData = nil;		if (gFilterData) delete gFilterData;		gFilterData = nil;		if (gPortMapData) delete gPortMapData;		gPortMapData = nil;		if (gInterfacesData) delete gInterfacesData;		gInterfacesData = nil;		if (gRoutesData) delete gRoutesData;		gRoutesData = nil;		if (gDeviceData) delete gDeviceData;		gDeviceData = nil;		if (gConnectionData) delete gConnectionData;		gConnectionData = nil;		if (gGatewayData) delete gGatewayData;		gGatewayData = nil;		// delete last since others use it		if (gProxyControl) delete gProxyControl;		gProxyControl = nil;			if (gLogAction) delete gLogAction;		gLogAction = nil;		if (gLogData) delete gLogData;		gLogData = nil;			}		// close preferences file	// *** caution only close file after resource objects are out of scope	if (mPrefsFile) mPrefsFile->CloseResourceFork();}// ---------------------------------------------------------------------------//		¥ ProcessNextEvent// ---------------------------------------------------------------------------//	Retrieve and handle the next event in the event queue voidCIPRouterApp::ProcessNextEvent(){	EventRecord		macEvent;		// When on duty (application is in the foreground), adjust the		// cursor shape before waiting for the next event. Except for the		// very first time, this is the same as adjusting the cursor		// after every event.		if (IsOnDuty()) {						// Calling OSEventAvail with a zero event mask will always			// pass back a null event. However, it fills the EventRecord			// with the information we need to set the cursor shape--			// the mouse location in global coordinates and the state			// of the modifier keys.					::OSEventAvail(0, &macEvent);		if (!(gApplicationMode & kModeFBA)) AdjustCursor(macEvent);	}			// Retrieve the next event. Context switch could happen here.		SetUpdateCommandStatus(false);	Boolean	gotEvent = ::WaitNextEvent(everyEvent, &macEvent, mSleepTime,										mMouseRgn);			// Let Attachments process the event. Continue with normal		// event dispatching unless suppressed by an Attachment.		if (LAttachable::ExecuteAttachments(msg_Event, &macEvent)) {		if (gotEvent) {			DispatchEvent(macEvent);		} else {			UseIdleTime(macEvent);		}	}									// Repeaters get time after every event	LPeriodical::DevoteTimeToRepeaters(macEvent);										// Update status of menu items	if (IsOnDuty() && GetUpdateCommandStatus()) {		if (!(gApplicationMode & kModeFBA)) UpdateMenus();	}}// ===========================================================================// ¥ Apple Event Handlers								Apple Event Handlers ¥// ===========================================================================voidCIPRouterApp::HandleAppleEvent(	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply,	AEDesc				&outResult,	long				inAENumber){	switch (inAENumber) {		case ae_OpenDoc:		case ae_PrintDoc:			// If demo hasn't expired, open doc (even if not registered)			if (mStartupFlag) DoAEOpenOrPrintDoc(inAppleEvent, outAEReply, inAENumber);			break;			case ae_OpenApp:			StartUp();			break;					case ae_Quit:			DoQuit(0);			break;					case ae_SwitchTellTarget: {			StAEDescriptor	targD;			LModelObject	*newTarget = NULL;						targD.GetOptionalParamDesc(inAppleEvent, keyAEData, typeWildCard);			if (targD.mDesc.descriptorType != typeNull) {				StAEDescriptor	token;				LModelDirector::Resolve(targD.mDesc, token.mDesc);				newTarget = GetModelFromToken(token);			}								SetTellTarget(newTarget);			break;		}					case ae_GURL: {			// get descriptor and extract URL			StAEDescriptor	URLD;			Str255			URLStr;									URLD.GetParamDesc(inAppleEvent, keyDirectObject, typeChar);			UExtractFromAEDesc::ThePString (URLD.mDesc, URLStr);			// create a GURLThread to handle the GURL asynchronously			if (!mGURLThread) {				mGURLThread = new CGURLThread(this, URLStr);				ThrowIfNil_(mGURLThread);				// make sure application has started and user accepts trial terms				if (AppStarted()) {					// Launch thread to begin GURL					mGURLThread->Resume();					mLaunchGURL = false;				} else {					mLaunchGURL = true;		// remember to launch later				}			}						break;		}				case ae_GKey: {		// Get Key value			// get descriptor and extract input string			StAEDescriptor	inputD;			Str255			str;			UInt32			key;									inputD.GetParamDesc(inAppleEvent, keyDirectObject, typeChar);			UExtractFromAEDesc::ThePString (inputD.mDesc, str);			// calculate key value & convert to hex			key = GetKey(str);			IP_NumToHexStr(key, str);			// check if operation permitted			if (mRegKey != 0xBB87FD14) str[0] = 0;						// return hex string as result value keyAEResult			UAEDesc::AddPtr(&outResult, 0, typeChar, &str[1], str[0]);			break;		}		default:			LModelObject::HandleAppleEvent(inAppleEvent, outAEReply,								outResult, inAENumber);			break;	}}// ---------------------------------------------------------------------------------//		¥ OpenDocument// ---------------------------------------------------------------------------------voidCIPRouterApp::OpenDocument(	FSSpec	*inMacFSSpec ){	GrafPtr		theWindowP;	LWindow		*theWindow;	// Only one configuration can be open at a time.	// close previous document if any	// SuperCommander hierarchy:  App->Document->Window	//  Try window first, then document	if (!(gApplicationMode & kModeFBA)) {		// look for window by name		theWindowP = FindNamedIDWindow(kNameInterfaces);		if (theWindowP != nil) {	// Already exists?			theWindow = LWindow::FetchWindowObject(theWindowP);			theWindow->AttemptClose();			mDocument = nil;		}	}	else {		if (mDocument) mDocument->AttemptClose(false);		mDocument = nil;	}	// Create a new document using the file spec.	mDocument = new CConfigDocument( this, inMacFSSpec );}// ---------------------------------------------------------------------------------//		¥ MakeNewDocument// ---------------------------------------------------------------------------------LModelObject *CIPRouterApp::MakeNewDocument(){	GrafPtr		theWindowP;	LWindow		*theWindow;	// Only one configuration can be open at a time.	// close previous document if any	if (!(gApplicationMode & kModeFBA)) {		// look for window by name		theWindowP = FindNamedIDWindow(kNameInterfaces);		if (theWindowP != nil) {	// Already exists?			theWindow = LWindow::FetchWindowObject(theWindowP);			theWindow->AttemptClose();			mDocument = nil;		}	}	else {		if (mDocument) mDocument->AttemptClose(false);		mDocument = nil;	}	// Make a new empty document.	mDocument = new CConfigDocument( this, nil );	return mDocument;}// ---------------------------------------------------------------------------------//		¥ ChooseDocument// ---------------------------------------------------------------------------------voidCIPRouterApp::ChooseDocument(){	// Deactivate the desktop.	::UDesktop::Deactivate();	// Browse for a document.	SFTypeList			theTypeList = {'TEXT'};	StandardFileReply	theReply;	::StandardGetFile( nil, 1, theTypeList, &theReply );	// Activate the desktop.	::UDesktop::Activate();		// Send an apple event to open the file.		if ( theReply.sfGood ) SendAEOpenDoc( theReply.sfFile );}// ---------------------------------------------------------------------------//		¥ ObjectThreadDied// ---------------------------------------------------------------------------//	A threaded operation has completed.voidCIPRouterApp::ObjectThreadDied(LThread *inThread) {			if (inThread == mStartupThread) {		// get result		long result = *((long*)inThread->GetResult());		// indicate thread no longer exists		mStartupThread = nil;		// handle results		if (result == kSTQuit) {			DoQuit(0);				// try to exit cleanly		}	}	else if (inThread == mAuthorizationThread) {		// get result		long result = *((long*)inThread->GetResult());		// indicate thread no longer exists		mAuthorizationThread = nil;		// handle results		if (result == kSTQuit) {			DoQuit(0);				// try to exit cleanly		}	}	else if (inThread == mGURLThread) {		// get result		long result = *((long*)inThread->GetResult());		// indicate thread no longer exists		mGURLThread = nil;		// handle results	}}