// =================================================================================//	MacSupport.cp			©1996-98 Sustainable Softworks.  All rights reserved.// =================================================================================//	Mac Application Support Routines#include "MacSupport.h"#include <UResourceMgr.h>#include <UDrawingState.h>#include <LString.h>#include <UAppleEventsMgr.h>#include <LCaption.h>#include "CIPRouterApp.h"#include "IPRouterCommon.h"#include "CTurboUDPEndpoint.h"#include "IPSupport.h"// Globalsextern CIPRouterApp* gAppObject;extern UInt8		 gApplicationMode;const SInt16 gWindowIDCommand[kMaxWindowID+1]	= {	0,	rPPob_AboutBoxWindow,	rPPob_RouterLogWindow,	rPPob_RouterHelpWindow,	rPPob_InterfacesWindow,	rPPob_RoutesWindow,	rPPob_GatewayWindow,	rPPob_PortMapWindow,	rPPob_FilterWindow,	rPPob_ArpWindow,	rPPob_DHCPWindow,	rPPob_SubnetCalcWindow};/////////////////////////////////////////////////////////////////// Implementation that reads the TCP/IP Preferences file directly.// You have to search for the preferences file by type and creator// because the name will be different on localised systems./*    This routine (FindTCPPrefFile) is from File:   OTTCPWillDial.c    Written by: Quinn "The Eskimo!"    Copyright:  © 1998 by Apple Computer, Inc., all rights reserved.    Change History (most recent first):    You may incorporate this sample code into your applications without    restriction, though the sample code has been provided "AS IS" and the    responsibility for its operation is 100% yours.  However, what you are    not permitted to do is to redistribute the source as "DSC Sample Code"    after having made changes. If you're going to re-distribute the source,    we require that you make it clear in the source that the code was    descended from Apple Sample Code, but that you've made changes.*/enum {    kOTTCPPrefFileType = 'pref',    kOTTCPPrefFileCreator = 'ztcp'};OSStatus FindTCPPrefFile(FSSpec *fss)    // This routine scans the Preferences folder looking    // for the "TCP/IP Preferences" file by type and creator.{    OSStatus err;    Boolean found;    CInfoPBRec cpb;    SInt16 index;    err = FindFolder(kOnSystemDisk, kPreferencesFolderType, kCreateFolder,    				 &fss->vRefNum, &fss->parID);    if (err == noErr) {        found = false;        index = 1;        do {            cpb.hFileInfo.ioVRefNum = fss->vRefNum;            cpb.hFileInfo.ioDirID = fss->parID;            cpb.hFileInfo.ioNamePtr = fss->name;            cpb.hFileInfo.ioFDirIndex = index;            err = PBGetCatInfoSync(&cpb);            if (err == noErr) {                found = (   cpb.hFileInfo.ioFlFndrInfo.fdType == kOTTCPPrefFileType &&                            cpb.hFileInfo.ioFlFndrInfo.fdCreator == kOTTCPPrefFileCreator );            }            index += 1;        } while (err == noErr & ! found);    }    return err;}// ---------------------------------------------------------------------------//		¥ ECGetResource// ---------------------------------------------------------------------------//	Error Check Get ResourceOSErr ECGetResource(OSType inType, short inID, void *outHandle){	Handle h;	OSErr err = noErr;		h = GetResource(inType, inID);	err = ResError();	if (err != noErr) return err;	if (h == nil) return resNotFound;	*(void**)outHandle = h;	return noErr;}// ---------------------------------------------------------------------------//		¥ SetIndString// ---------------------------------------------------------------------------OSErr SetIndString(StringPtr theStr,short resID,short strIndex){   Handle theRes;               /* handle pointing to STR# resource */   short numStrings;            /* number of strings in STR# */   short ourString;             /* counter to index up to strIndex */   char *resStr;                /* string pointer to STR# string to replace */   long oldSize;                /* size of STR# resource before call */   long newSize;                /* size of STR# resource after call */   unsigned long offset;        /* resource offset to str to replace*/   /* make sure index is in bounds */   if (resID < 1)   return -1;   /* make sure resource exists */   theRes = GetResource('STR#',resID);   if (ResError()!=noErr)   return ResError();   if (!theRes || !(*theRes))   return resNotFound;   HLock(theRes);   HNoPurge(theRes);   /* get # of strings in STR# */   BlockMove(*theRes,&numStrings,sizeof(short));   if (strIndex > numStrings)   return resNotFound;   /* get a pointer to the string to replace */   offset = sizeof(short);   resStr = (char *) *theRes + sizeof(short);   for (ourString=1; ourString<strIndex; ourString++) {   offset += 1+resStr[0];   resStr += 1+resStr[0];   }   /* grow/shrink resource handle to make room for new string */   oldSize = GetHandleSize(theRes);   newSize = oldSize - resStr[0] + theStr[0];   HUnlock(theRes);   SetHandleSize(theRes,newSize);   if (MemError()!=noErr) {   ReleaseResource(theRes);   return -1;   }   HLock(theRes);   resStr = *theRes + offset;   /* move old data forward/backward to make room */   BlockMove(resStr+resStr[0]+1, resStr+theStr[0]+1, oldSize-offset-resStr[0]-1);   /* move new data in */   BlockMove(theStr,resStr,theStr[0]+1);   /* write resource out */   ChangedResource(theRes);   WriteResource(theRes);   HPurge(theRes);   ReleaseResource(theRes);   return ResError();}// ---------------------------------------------------------------------------//		¥ IsOT25// ---------------------------------------------------------------------------Boolean IsOT25(){	enum {		gestaltOpenTptVersions			= 'otvr',		kOTVersion250 = 0x02508000	};	OSStatus err;	UInt32 otVersion;	Boolean result = false;		err = Gestalt(gestaltOpenTptVersions, (long *) &otVersion);	if ((err == noErr) && (otVersion >= kOTVersion250)) result = true;	return result;}// ---------------------------------------------------------------------------//	¥ FindNamedIDWindow// ---------------------------------------------------------------------------//	Return a WindowPtr to the Window with the specified IDWindowPtrFindNamedIDWindow(SInt16 inWindowID){    Str31 windowStr;    	::GetIndString(windowStr, rSTRN_WindowID, inWindowID);	return UWindows::FindNamedWindow(windowStr);}// ---------------------------------------------------------------------------//		¥ InvokeWindow// ---------------------------------------------------------------------------//	Invoke a PowerPlant Window//		If window already exists, bring to front, otherwise create it.//		Returns pointer to LWindow object.LWindow*InvokeWindow(SInt16 inWindowID, LCommander *inSuperCommander){	GrafPtr		theWindowP;	LWindow		*theWindow;	Str31		windowNameStr;	if (gApplicationMode & kModeFBA) return nil;	// look for window by name	::GetIndString(windowNameStr, rSTRN_WindowID, inWindowID);	theWindowP = UWindows::FindNamedWindow( windowNameStr );	if (theWindowP != nil) {	// Already exists?		// yes, bring to front		theWindow = LWindow::FetchWindowObject(theWindowP);		theWindow->Show();		UDesktop::SelectDeskWindow( theWindow );	} else {		// no, create a new instance		theWindow = LWindow::CreateWindow(gWindowIDCommand[inWindowID], inSuperCommander);		ThrowIfNil_( theWindow );		// set window title explicitly		theWindow->SetDescriptor(windowNameStr);		// restore window position if any		RestoreWindowPosition( theWindow, gWindowIDCommand[inWindowID] );		// display it		// theWindow->Show();	// let caller do this	}	// store the PPob ResIDT in the Window user constant	theWindow->SetUserCon( gWindowIDCommand[inWindowID] );		return theWindow;	}// ---------------------------------------------------------------------------//		¥ SaveWindowPosition// ---------------------------------------------------------------------------// Save Window Position as a resource in the apps preference filevoidSaveWindowPosition( LWindow* inWindow, ResIDT inPPob ){	// Update saved position resource, creating a new one if necessary	StNewResource windowPosition( (ResType)'WPos',		(ResIDT)inPPob, 8, true );	// inDefaultSize, inGet1Resource	if (windowPosition.mResourceH) {		Rect	theFrame;		Point	pointLT, pointRB;		inWindow->CalcPortFrameRect(theFrame);		pointLT = topLeft(theFrame);		pointRB = botRight(theFrame);		inWindow->PortToGlobalPoint(pointLT);		inWindow->PortToGlobalPoint(pointRB);		::SetRect( (Rect*)(*windowPosition.mResourceH),			pointLT.h, pointLT.v, pointRB.h, pointRB.v );	}}// ---------------------------------------------------------------------------//		¥ RestoreWindowPosition// ---------------------------------------------------------------------------// Restore Window Position from resource in the apps preference filevoidRestoreWindowPosition( LWindow* inWindow, ResIDT inPPob ){	Boolean positionRestored = false;		// is there a saved position for the window?	StNewResource windowPosition( (ResType)'WPos',		inPPob, 8, true );	// inDefaultSize, inGet1Resource	if (windowPosition.mResourceH) {		if (windowPosition.ResourceExisted()) {			// yes, make sure title bar is on an active screen			// get title bar frame			Rect theWindowFrame, theTitleFrame, theFrame;			theWindowFrame = *(Rect*)(*windowPosition.mResourceH);			theTitleFrame = theWindowFrame;			theTitleFrame.bottom = theWindowFrame.top + 20;			// get screen frame for each active screen			GDHandle	currentDevice;			Rect		deviceRect;			currentDevice = ::GetDeviceList();			while (currentDevice != nil) {	// scan device list				if (UDrawingUtils::IsActiveScreenDevice(currentDevice)) {					deviceRect = (**currentDevice).gdRect;					if ( ::SectRect(&deviceRect, &theTitleFrame, &theFrame) ) {						// position window						// if window is resizable, set size as well						if (inWindow->HasAttribute(windAttr_Resizable)) {							Rect minMaxSize;							short h, w;							// check that size is valid							h = theWindowFrame.bottom - theWindowFrame.top;							w = theWindowFrame.right - theWindowFrame.left;							inWindow->GetMinMaxSize(minMaxSize);							if ((minMaxSize.left <= w) && (w <= minMaxSize.right) &&								(minMaxSize.top <= h) && (h <= minMaxSize.bottom)) {								// set size and position								inWindow->DoSetBounds( theWindowFrame );							} else inWindow->DoSetPosition( topLeft(theWindowFrame) );						} else inWindow->DoSetPosition( topLeft(theWindowFrame) );						positionRestored = true;						break;					}				}				currentDevice = ::GetNextDevice(currentDevice);			}		}		// if window position could not be restored		if (!positionRestored) {			// initialize saved position to current default position			Rect	theFrame;			Point	pointLT, pointRB;			inWindow->CalcPortFrameRect(theFrame);			pointLT = topLeft(theFrame);			pointRB = botRight(theFrame);			inWindow->PortToGlobalPoint(pointLT);			inWindow->PortToGlobalPoint(pointRB);			::SetRect( (Rect*)(*windowPosition.mResourceH),				pointLT.h, pointLT.v, pointRB.h, pointRB.v );		}	}}// ---------------------------------------------------------------------------//		¥ EraseMinusRect// ---------------------------------------------------------------------------// Erase rectangular area excluding a contained rectanglevoidEraseMinusRect(Rect inDestRect, Rect inExcludeRect){	Rect frame;		// erase above excluded rect	frame.left		= inDestRect.left;	frame.top		= inDestRect.top;	frame.right		= inDestRect.right;	frame.bottom	= inExcludeRect.top;	::EraseRect(&frame);		// erase left of excluded rect	frame.left		= inDestRect.left;	frame.top		= inExcludeRect.top;	frame.right		= inExcludeRect.left;	frame.bottom	= inExcludeRect.bottom;	::EraseRect(&frame);		// erase right of excluded rect	frame.left		= inExcludeRect.right;	frame.top		= inExcludeRect.top;	frame.right		= inDestRect.right;	frame.bottom	= inExcludeRect.bottom;	::EraseRect(&frame);		// erase below excluded rect	frame.left		= inDestRect.left;	frame.top		= inExcludeRect.bottom;	frame.right		= inDestRect.right;	frame.bottom	= inDestRect.bottom;	::EraseRect(&frame);}// =================================================================================//	GetKey.cp					©1996 Sustainable Softworks All rights reserved.// =================================================================================//	IPNetRouter Calculuate Registration Key//// Parts of this algorithm are "derived from the RSA Data Security, Inc.// MD4 Message-Digest Algorithm".  See RFC 1320.//// F, G and H are basic MD4 functions.#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))#define G(x, y, z) (((x) & (y)) | ((x) & (z)) | ((y) & (z)))#define H(x, y, z) ((x) ^ (y) ^ (z))// ROTATE_LEFT rotates x left n bits.#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))// inStr must be 240 bytes or less, otherwise return zeroUInt32GetKey(ConstStr255Param inStr){	char theString[255], *ptr;	UInt32	a, b, c, returnKey;	int len, pad, index;	// test for valid input length	if (inStr[0] > 240) return 0;		// copy inStr to buffer	//strncpy(theString, (char*)&inStr[1], inStr[0]);	BlockMove((char*)&inStr[1], theString, inStr[0]);		// pad to an odd multiple of 4 bytes	len = inStr[0];	ptr = theString;	ptr += len;	pad = 8 - (len % 8);	if (pad < 4) pad += 4;	else pad -= 4;	index = pad;	while (index>0) {		*ptr = 0; ptr++;		index -= 1;		}	// append original length to make an even multiple of 4 bytes	*ptr = 0; ptr++;	*ptr = 0; ptr++;	*ptr = 0; ptr++;	*ptr = len; ptr++;		// get appended length	len += pad + 4;		returnKey = 0x67452301;		// initialize key	ptr = theString;	while (len > 0) {		//strncpy((char*)&b, ptr, 4);	// get a 4 byte chunk		BlockMove(ptr, (char*)&b, 4);		ptr += 4;		len -= 4;		//strncpy((char*)&c, ptr, 4);	// get a 4 byte chunk		BlockMove(ptr, (char*)&c, 4);		ptr += 4;		len -= 4;		a = F(returnKey, b, c);		returnKey += ROTATE_LEFT(a, 9);		a = G(returnKey, b, c);		returnKey += ROTATE_LEFT(a, 13);		a = H(returnKey, b, c);		returnKey += ROTATE_LEFT(a, 11);		returnKey += b;		a = F(returnKey, b, c);		returnKey += ROTATE_LEFT(a, 21);		a = G(returnKey, b, c);		returnKey += ROTATE_LEFT(a, 23);		a = H(returnKey, b, c);		returnKey += ROTATE_LEFT(a, 27);		returnKey += c;	}	return returnKey;}// ---------------------------------------------------------------------------//		¥ CheckKey// ---------------------------------------------------------------------------//	Checks the Registration Key against a set of values in resources//  If not found, sends a message to a UDP Server////  This function is designed to be called from a PowerPlant Thread//  since it uses CTurboUDPEndpoint directly to send data.voidCheckKey(UInt32 key, ConstStr255Param inStr){	Handle				tResHandle;	UInt32*             dp;	UInt32				loops;	Boolean				foundKeyFlag = false;	UInt32				sendToIPAddress;	CTurboUDPEndpoint*	tUDPEndpoint = nil;	LStr255				sendText;		do {    	// see if we have this key in our resource    	if (ECGetResource((OSType)'IPnw', 128, &tResHandle) != noErr) break;    	loops = ::GetHandleSize(tResHandle)/4;    	if (loops > 50000) break;  // defensive    	::HLock(tResHandle);    	dp = (UInt32*)*tResHandle;    	for (short i=0; i<loops; i++) {    		if (dp[i] == key) {    			foundKeyFlag = true;    			break;    		}    	}    	::HUnlock(tResHandle);    	::ReleaseResource(tResHandle);    	    	if(foundKeyFlag) break;        // if inStr is empty, just beep for testing        if (inStr[0] == 0) {            ::SysBeep(30);            break;        }    		    	// we did not find the reg key in our resource     	// so tell us about it!        sendText = inStr;   // let the caller do it    	    	try {        	tUDPEndpoint = new CTurboUDPEndpoint("udp");        	ThrowIfNil_(tUDPEndpoint);        	        	// Initialization: Bind to any local port        	LInternetAddress from_address(0, 0);        	tUDPEndpoint->Bind(from_address);        	        	// convert the send to IP address or name HARD CODED         	//sendToIPAddress = IP_StrToInt("\p24.6.195.29");        	sendToIPAddress = IP_StrToInt("\p65.8.234.97");        	if(sendToIPAddress != 0) // this is an IP address        	{        		LInternetAddress to_address(sendToIPAddress, 61009);        		tUDPEndpoint->SendPacketData(to_address,&sendText[1],sendText.Length());        	}   	        	//tUDPEndpoint->Unbind();   // skip since we're about to delete it        }        catch (...) {}  // ignore any errors    } while (false);    // clean up    if (tUDPEndpoint) delete tUDPEndpoint;    	}// ---------------------------------------------------------------------------//		¥ HexToNum// ---------------------------------------------------------------------------//	Return the integer value represented by a hex string (0-9, A-F)UInt32HexToNum(ConstStr255Param inStr){	UInt8	len, index, theChar;	UInt32	number;	number = 0;	len = inStr[0];	if (len > 8) len = 8;	for (index=1; index<=len; index++) {		theChar = inStr[index] | 0x20;	// convert to lower case;		if (('0' <= theChar) && (theChar <= '9')) {			number <<= 4;			number += (theChar - '0');		} else if (('a' <= theChar) && (theChar <= 'f')) {			number <<= 4;			number += (theChar - 'a' + 10);				} else return number;	}	return number;}// ---------------------------------------------------------------------------//		¥ HexPairToNum// ---------------------------------------------------------------------------//	Return the integer value represented by a string of two hex digits (0-9, A-F)UInt8HexPairToNum(ConstStr255Param inStr, UInt8& ioPos){	UInt8	digit;	UInt8	number;	number = 0;	digit = inStr[ioPos++] | 0x20;	// convert to lower case;	if (('0' <= digit) && (digit <= '9')) {		number <<= 4;		number += (digit - '0');	} else if (('a' <= digit) && (digit <= 'f')) {		number <<= 4;		number += (digit - 'a' + 10);			} else return number;	digit = inStr[ioPos++] | 0x20;	// convert to lower case;	if (('0' <= digit) && (digit <= '9')) {		number <<= 4;		number += (digit - '0');	} else if (('a' <= digit) && (digit <= 'f')) {		number <<= 4;		number += (digit - 'a' + 10);			} else return number;	return number;}// ---------------------------------------------------------------------------//		¥ CharToHexStr// ---------------------------------------------------------------------------//	Return the two digit hex string representing characterStringPtrCharToHexStr(UInt8 inChar, Str31	outStr){	unsigned char digit;	outStr[0] = 2;	// length is 2	digit = (inChar >> 4 & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	outStr[1] = digit;	digit = (inChar & 0x0F);	if (digit < 10) digit += '0';	else digit += ('A' - 10);	outStr[2] = digit;	return outStr;}// ---------------------------------------------------------------------------//		¥ RegInfoToString// ---------------------------------------------------------------------------//	Build hex reg string from reg info// Format://// RE 000502 IPNR N1 0F 427261642042656E6E657474 08 F993B3CC 04// 53757374776F726B73 01 31//// RE = Chars 1-2 tell us this is a registration// 000502 = Chars 3-8 tell us the registration date in YYMMDD format// IPNR = Chars 9-12 tell us the product// N1 = Chars 13-14  tell us the language (region)// 0F = Chars 15-16 is a Hex value telling us the length of the Name// 4D61727368612057696C6C69616D73 = Name (in Hex) = Brad Bennett// 08 = hex value for number of chars in registration// F993B3CC = registration code// 04 = hex value for number of chars in organization name// 53656C66 = Org (in hex) = Self// 01 = hex value for number of chars in number of copies// 31 = Number of copies (in hex) = 1StringPtrRegInfoToString(RegInfo_t* inRegInfo, Str255 outStr){	LStr255	regStr;	Str31	str;	short	i;	UInt8	len;		regStr = "\pRE";	// check date for valid fixed length	if (inRegInfo->date[0] == 6) regStr += inRegInfo->date;	else regStr += "\p000000";	regStr += "\pIPNR";	regStr += "\pN1";		// name	len = inRegInfo->name[0];	for (i=0; i<=len; i++) {		regStr += CharToHexStr(inRegInfo->name[i], str);	}		// key	len = inRegInfo->key[0];	regStr += CharToHexStr(len, str);	for (i=1; i<=len; i++) {		regStr += inRegInfo->key[i];	}		// org	len = inRegInfo->organization[0];	for (i=0; i<=len; i++) {		regStr += CharToHexStr(inRegInfo->organization[i], str);	}		// copies	len = inRegInfo->copies[0];	for (i=0; i<=len; i++) {		regStr += CharToHexStr(inRegInfo->copies[i], str);	}	return LString::CopyPStr(regStr, outStr);}// ---------------------------------------------------------------------------//		¥ StringToRegInfo// ---------------------------------------------------------------------------//	Convert hex reg string to reg info//	Returns false if string was invalidBooleanStringToRegInfo(ConstStr255Param inStr, RegInfo_t* outRegInfo){	Str255	str;	UInt8	tLen, len, i, ioPos;	Boolean	result = false;		do {		tLen = inStr[0];		if (tLen < 25) break;	// min possible length			// RE		::BlockMove(&inStr[1], &str[1], 2);		str[0] = 2;		if ( !::EqualString(str, "\pRE", true, true) ) break;	// starts "RE"			// date		::BlockMove(&inStr[3], &str[1], 6);		str[0] = 6;		LString::CopyPStr(str, outRegInfo->date);			// product		::BlockMove(&inStr[9], &str[1], 4);		str[0] = 4;		//if ( !::EqualString(str, "\pIPNR", true, true) ) break;			// region		::BlockMove(&inStr[13], &str[1], 2);		str[0] = 2;		LString::CopyPStr(str, outRegInfo->region);			// name		ioPos = 15;		len = HexPairToNum(inStr, ioPos);		outRegInfo->name[0] = len;		for (i=1; i<=len; i++) outRegInfo->name[i] = HexPairToNum(inStr, ioPos);			// key		if (ioPos > tLen) break;		len = HexPairToNum(inStr, ioPos);		outRegInfo->key[0] = len;		for (i=1; i<=len; i++) outRegInfo->key[i] = inStr[ioPos++];			// org		len = HexPairToNum(inStr, ioPos);		outRegInfo->organization[0] = len;		for (i=1; i<=len; i++) outRegInfo->organization[i] = HexPairToNum(inStr, ioPos);			// copies		len = HexPairToNum(inStr, ioPos);		outRegInfo->copies[0] = len;		for (i=1; i<=len; i++) outRegInfo->copies[i] = HexPairToNum(inStr, ioPos);				result = true;	} while (false);		return result;}// ---------------------------------------------------------------------------//		¥ MSecToString// ---------------------------------------------------------------------------//	Convert Milliseconds to StringStringPtrMSecToString(SInt32 inMsec, Str255 outDescriptor){	SInt32	seconds, fraction;	Str32	part;	LStr255	str;		// get seconds	seconds = inMsec/1000;			// number of seconds	NumToString(seconds, part);	str = part;	// get milliseconds	fraction = inMsec % 1000;		// number of milliseconds	// show 3 decimal places if < 100	if ((seconds == 0) && (0 < fraction) && (fraction < 100)) {		if (fraction < 10) str += "\p.00";		else str += "\p.0";		NumToString(fraction, part);		str += part;	} else {		// show hundredths		fraction = (fraction + 5)/10;	// number of hundredths		if (fraction < 10) str += "\p.0";		else str += "\p.";		NumToString(fraction, part);		str += part;	}	// return result	LString::CopyPStr(str, outDescriptor, 255);	return outDescriptor;}// ---------------------------------------------------------------------------//		¥ UpdateCounter// ---------------------------------------------------------------------------//	Update local counter and delta based on new valuevoidUpdateCounter(UInt32& inCurrent, UInt32& ioPrevious, UInt32& ioDelta){	if (ioPrevious < inCurrent) {	// ignore startup deltas		ioDelta = inCurrent - ioPrevious;	} else {		ioDelta = 0;	}	ioPrevious = inCurrent;}// ---------------------------------------------------------------------------//		¥ UpdateCaption// ---------------------------------------------------------------------------//	Display value in Caption if it has changedBooleanUpdateCaption(LCaption* inCaption, UInt32 inValue){	UInt32	oldValue;	Boolean	hasChanged = false;		oldValue = inCaption->GetValue();	if (inValue != oldValue) {		inCaption->SetValue(inValue);		hasChanged = true;	}	return hasChanged;}// ---------------------------------------------------------------------------------//		¥ OptionKeyDown// ---------------------------------------------------------------------------------//	Returns true if Option key is downBooleanOptionKeyDown(){	KeyMap	keyMap;	UInt8*	map;	UInt16	k;	Boolean	result = false;		::GetKeys(keyMap);	map = (UInt8*)keyMap;	k = 58;		// option key	if (map[k >> 3] >> (k & 7) & 1) {		result = true;	}		return result;}#pragma mark --- string manipulation ---// ---------------------------------------------------------------------------------//		¥ AppendString// ---------------------------------------------------------------------------------// Append string to character array.// ioPos updated to one past last character.// Return false if not enough room in array.BooleanAppendStr(UInt8* dp, SInt32& ioPos, SInt32 end, ConstStr255Param inStr){	SInt32	len;	Boolean result = false;		// check if string will fit	len = inStr[0];	if (ioPos+len <= end) {		::BlockMove(&inStr[1], &dp[ioPos], len);		ioPos += len;		result = true;	}	return result;}// ---------------------------------------------------------------------------------//		¥ GetParamString// ---------------------------------------------------------------------------------// Get param string from array dp// Returns offset to one past delimeter or zero if param not found// parameter is terminated by a inDelimeter or ending offsetSInt32GetParamString(UInt8* dp, SInt32 start, SInt32 end, UInt8 inDelimeter, Str255 outStr){	SInt32	pos, len;	pos = 0;	if (start < end) {		// find end of param		pos = FindByte(inDelimeter, dp, start, end);		if (pos == 0) {			len = end - start;			pos = end;		} else {			len = pos - start;			pos += 1;		}		if ((len >= 0) && (len < 255)) {			outStr[0] = len;			::BlockMove(&dp[start], &outStr[1], len);		} else pos = 0;	}	return pos;}// ---------------------------------------------------------------------------------//		¥ BeginsWith// ---------------------------------------------------------------------------------BooleanBeginsWith(Str255 inStr, const Str255 inKeyword){	UInt8	len;	Str255	str;	Boolean	result;	len = inKeyword[0];	LString::CopyPStr(inStr, str, len+1);	result = ::EqualString(str, inKeyword, false, false);	return result;}// ---------------------------------------------------------------------------------//		¥ GetKeywordValue// ---------------------------------------------------------------------------------// Get keyword value from parameter string of the form//   <keyword>=<value>// Returns false if no value foundBooleanGetKeywordValue(Str255 inStr, Str255 outStr){	SInt32	pos, end, len;	Boolean	result = false;	end = inStr[0];	if (end > 0) {		// find start of value		pos = FindByte('=', &inStr[1], 0, end);		if (pos != 0) {			pos += 1;	// adjust for offset from inStr[1]			len = end - pos;			if ((len >= 0) && (len < 255)) {				outStr[0] = len;				::BlockMove(&inStr[pos+1], &outStr[1], len);				result = true;			}		}	}	return result;}// ---------------------------------------------------------------------------------//		¥ FindByte// ---------------------------------------------------------------------------------//	Find the position of a byte value in array dp from start to end.//	Returns offset to byte or zero if not foundSInt32FindByte(UInt8 byte, UInt8* dp, SInt32 start, SInt32 end){	SInt32	last;	SInt32	pos;	UInt8	hold;		pos = 0;	if (start < end) {		// check start is before end		// remember last byte and set it to what we're looking for so the loop		// will terminate without checking on each cycle		last = end-1;		hold = dp[last];		dp[last] = byte;				while (dp[start++] != byte) ;		dp[last] = hold;	// put last back		if (start <= last) pos = start-1;		else if (byte == hold) pos = last;	}	return pos;}