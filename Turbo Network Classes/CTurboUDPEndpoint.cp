// ===========================================================================//	CTurboUDPEndpoint.cp	Turbo Extensions й1996-2000 Sustainable Softworks Inc.//  includes//	LOpenTptUDPEndpoint.cp		PowerPlant 2.1		й1996-1999 Metrowerks Inc.// ===========================================================================//	OpenTransport version of a UDP endpoint. An instance of this class will//	normally be created for you by use of UNetworkFactory.#include "CTurboUDPEndpoint.h"#include <LInternetMapper.h>#include <UNetworkFactory.h>#include "CInternetAddress.h"#include "CNetMessage.h"#if PP_Target_Carbon && !OTCARBONAPPLICATION	// You must put	//		#define OTCARBONAPPLICATION 1	// in your prefix file or precompiled header	//	// Under Carbon, OTOpenEndpoint() takes a context parameter.	// The context can be NULL for an application, but must be set	// for a non-application.	//	// $$$ CARBON $$$ This class needs to be revised to support contexts.	#error "Temporary Wart"#endifPP_Begin_Namespace_PowerPlant// ---------------------------------------------------------------------------//		е CTurboUDPEndpoint()// ---------------------------------------------------------------------------//	ConstructorCTurboUDPEndpoint::CTurboUDPEndpoint(char* inConfig){	mEndpointRef = nil;	UOpenTptSupport::StartOpenTransport();	OSStatus result;	mEndpointRef = ::OTOpenEndpoint( ::OTCreateConfiguration(inConfig),											0, &mEndpointInfo, &result);	ThrowIfError_(result);	InstallNotifierProc(mEndpointRef);	::OTSetAsynchronous(mEndpointRef);	DontAckSends();	mSharedPool = LSharedMemoryPool::GetSharedPool();	mSharedPool->AddPoolUser(this);	mLocalAddress = nil;	mMessageQueue = nil;		try {		mLocalAddress = new LInternetAddress(0,0);		mMessageQueue = new LNetMessageQueue(*this);	} catch (...) {		delete mLocalAddress;		mLocalAddress = nil;		delete mMessageQueue;		mMessageQueue = nil;	}	mWaitingDataOperation = nil;	mWaitingControlOperation = nil;	StopAutoReceive();	// set to not AutoReceive initially}// ---------------------------------------------------------------------------//		е ~CTurboUDPEndpoint()// ---------------------------------------------------------------------------//	DestructorCTurboUDPEndpoint::~CTurboUDPEndpoint(){	RemoveNotifierProc();	//do this before closing the provider	if (mEndpointRef)		::OTCloseProvider(mEndpointRef);		// ignore errors	delete mLocalAddress;	//Need to delete mMessageQueue before removing memory pool!	delete mMessageQueue;	//Probably always want to RemovePoolUser last since other objects may	//	have dependance on the memory pool and the memory pool might	//	delete itself when we do this.	mSharedPool->RemovePoolUser(this);}// ---------------------------------------------------------------------------//		е AbortThreadOperation// ---------------------------------------------------------------------------voidCTurboUDPEndpoint::AbortThreadOperation(LThread * inThread){	StOpenTptOperation * theOperation = (StOpenTptOperation*)StAsyncOperation::GetThreadOperation(inThread);	if (theOperation) {		theOperation->AbortOperation();	}}// ---------------------------------------------------------------------------//		е GetState// ---------------------------------------------------------------------------//	Returns state of endpointEEndpointStateCTurboUDPEndpoint::GetState(){	ResultT result = ::OTGetEndpointState(mEndpointRef);	if (result == kOTStateChangeErr)		result = endpoint_UnknownState;	return (EEndpointState) result;}// ===========================================================================#pragma mark -#pragma mark === local address configurationvoidCTurboUDPEndpoint::Bind(					LInternetAddress&		inLocalAddress,					UInt32					/* inListenQueueSize */,					Boolean					inReusePort){	if (inReusePort) {		TOptMgmt    req;		TOption*	Opt;		UInt8 		OptionBuf[kOTFourByteOptionSize];		Opt = (TOption*)OptionBuf;		req.opt.buf = OptionBuf;		req.opt.len = sizeof(OptionBuf);		req.opt.maxlen = sizeof(OptionBuf);		req.flags   = T_NEGOTIATE;		Opt->level  = INET_IP;		Opt->name   = IP_REUSEADDR;		Opt->len    = kOTFourByteOptionSize;		*(UInt32*)Opt->value = true;		StOpenTptOperation	operation(this, T_OPTMGMTCOMPLETE);		ThrowIfError_(::OTOptionManagement(GetEndpointRef(), &req, &req));		operation.WaitForCompletion();	}	TBind				Req;	TBind				Ret;	inLocalAddress.MakeOTIPAddress(Req.addr);	Req.qlen = Ret.qlen = 1;	// UDP ignores listen queue size	Ret.addr.len = Ret.addr.maxlen = (ByteCount) GetEndpointInfo().addr;	Ret.addr.buf = (unsigned char*)::NewPtrClear((SInt32) Ret.addr.maxlen);	ThrowIfMemFail_(Ret.addr.buf);	StOpenTptOperation	operation(this, T_BINDCOMPLETE, &Ret, true);	ThrowIfError_(::OTBind(GetEndpointRef(), &Req, &Ret));	operation.WaitForCompletion();	delete mLocalAddress;	mLocalAddress =			UOpenTptSupport::OTAddressToPPAddress((OTAddress*)Ret.addr.buf);	::DisposePtr((char*)Req.addr.buf);	::DisposePtr((char*)Ret.addr.buf);}// ---------------------------------------------------------------------------//		е Unbind// ---------------------------------------------------------------------------voidCTurboUDPEndpoint::Unbind(){	StOpenTptOperation	operation(this, T_UNBINDCOMPLETE);	ThrowIfError_(::OTUnbind(GetEndpointRef()));	operation.WaitForCompletion();	mLocalAddress->SetHostPort(0);}// ---------------------------------------------------------------------------//		е GetLocalAddress// ---------------------------------------------------------------------------LInternetAddress*CTurboUDPEndpoint::GetLocalAddress(){	if (mLocalAddress->GetIPAddress() == 0) {		LInternetMapper * theMapper = UNetworkFactory::CreateInternetMapper();		LInternetAddress* tempAddress = theMapper->GetLocalAddress();		mLocalAddress->SetIPAddress(tempAddress->GetIPAddress());		delete theMapper;		delete tempAddress;	}	return new LInternetAddress(*mLocalAddress);}// ===========================================================================#pragma mark -#pragma mark === datagram messagingvoidCTurboUDPEndpoint::SendPacketData(					LInternetAddress&		inRemoteHost,					void*					inData,					UInt32					inDataSize){	TUnitData data;	inRemoteHost.MakeOTIPAddress(data.addr);	data.opt.maxlen = 0;	data.opt.len = 0;	data.opt.buf = nil;	data.udata.maxlen = data.udata.len = inDataSize;	data.udata.buf = (unsigned char *)inData;	StOpenTptOperation	operation(this, T_GODATA);	OSStatus result = ::OTSndUData(mEndpointRef, &data);	while (result == kOTLookErr) {		if (true) {    		//Clear Error    		::OTRcvUDErr(mEndpointRef, NULL);    		//Try again    		result = ::OTSndUData(mEndpointRef, &data);        } else {    		TUDErr error;    		    		error.addr.maxlen = sizeof(struct InetAddress);    		error.addr.len = sizeof(struct InetAddress);    		error.addr.buf = (unsigned char*) ::NewPtrClear(data.addr.maxlen);    		    		error.opt.maxlen = 0;    		error.opt.len = 0;    		error.opt.buf = nil;    		    		OSStatus RcvErrErr = ::OTRcvUDErr(mEndpointRef,&error);    		    		::DisposePtr((char *)error.addr.buf);    		result = ::OTSndUData(mEndpointRef,&data);        }	}	::DisposePtr((Ptr)data.addr.buf);	if (result == kOTFlowErr) {		//Wait for T_GODATA message and send data		operation.WaitForCompletion();		SendPacketData(inRemoteHost, inData, inDataSize);	} else {		ThrowIfError_(result);	}}boolCTurboUDPEndpoint::ReceiveFrom(					LInternetAddress&		outRemoteAddress,					void*					outDataBuffer,					UInt32&					ioDataSize,					UInt32					inTimeoutSeconds){	if (mWaitingDataOperation)	//Don't setup multiples		return false;	if (inTimeoutSeconds == 0)		inTimeoutSeconds = Timeout_None;	StOpenTptOperation	operation(this, T_DATA);	TUnitData data;	// allocate buffer for returned options if any	data.opt.maxlen = kOTFourByteOptionSize * 4;	data.opt.len = 0;	data.opt.buf = (unsigned char*) ::NewPtrClear((SInt32) data.opt.maxlen);	ThrowIfMemFail_(data.opt.buf);    // allocate buffer for IP adress	data.addr.maxlen = sizeof(struct InetAddress);	data.addr.len = sizeof(struct InetAddress);	data.addr.buf = (unsigned char*)::NewPtrClear((SInt32) data.addr.maxlen);	ThrowIfMemFail_(data.addr.buf);	// initialize data buffer, leave room to append two 4-byte addresses	data.udata.maxlen = data.udata.len = ioDataSize-8;	data.udata.buf = (unsigned char *)outDataBuffer;	OTFlags flags;	ResultT result = ::OTRcvUData(mEndpointRef, &data, &flags);	while (result == kOTLookErr) {	    if (false) {    		//Clear Error    		::OTRcvUDErr(mEndpointRef, NULL);    		//Try again    		result = ::OTRcvUData(mEndpointRef, &data, &flags);    	} else {    		TUDErr error;    		    		error.addr.maxlen = sizeof(struct InetAddress);    		error.addr.len = sizeof(struct InetAddress);    		error.addr.buf = (unsigned char*) ::NewPtrClear(data.addr.maxlen);    		    		error.opt.maxlen = 0;    		error.opt.len = 0;    		error.opt.buf = nil;    		    		OSStatus RcvErrErr = ::OTRcvUDErr(mEndpointRef,&error);    		    		::DisposePtr((char *)error.addr.buf);    		result = ::OTRcvUData(mEndpointRef,&data,&flags);    	    	}	}	if (result) {		::DisposePtr((char*)data.addr.buf);		::DisposePtr((char *)data.opt.buf);		switch (result) {			case kOTNoDataErr:		//swallow kOTNoDataErr and block thread				mWaitingDataOperation = &operation;				try{					operation.WaitForCompletion(inTimeoutSeconds);				} catch(...) {					mWaitingDataOperation = nil;					throw;				}				//if we are here, we didn't timeout so we must have a				//		T_DATA event, so we go get the data now				mWaitingDataOperation = nil;				return ReceiveFrom(outRemoteAddress, outDataBuffer, ioDataSize, inTimeoutSeconds);				break;			default:				ThrowIfError_(result);				break;		}		Throw_(result);	}	//if the call returned an address (it won't if the last one had T_MORE)	if (data.addr.len) {		outRemoteAddress.SetIPAddress(((InetAddress*)data.addr.buf)->fHost);		outRemoteAddress.SetHostPort(((InetAddress*)data.addr.buf)->fPort);	}	// get returned IP_RCVIFADDR option if present	UInt8*	dp;	UInt8	optionCount;	UInt32	nextOption;	dp = data.udata.buf;	::OTMemzero(&dp[data.udata.len], 8);	// defensive	optionCount = 0;	nextOption = 0;	while (data.opt.len > nextOption) {		TOption* option;		option = (TOption*)((UInt32)data.opt.buf + nextOption);		if ((option->level == INET_IP) && (option->name == IP_RCVIFADDR)) {			::OTMemcpy(&dp[data.udata.len], &option->value[0], 4);		}		if ((option->level == INET_IP) && (option->name == IP_RCVDSTADDR)) {			::OTMemcpy(&dp[data.udata.len+4], &option->value[0], 4);		}		nextOption += option->len;		optionCount += 1;		if (optionCount >= 4) break;	// defensive	}		::DisposePtr((char *)data.addr.buf);	::DisposePtr((char *)data.opt.buf);	ioDataSize = data.udata.len;	return flags == T_MORE;}voidCTurboUDPEndpoint::ReceiveError(					UInt32&					outRemoteAddress,					UInt16&					outRemotePort,					SInt32&					outError){	TUDErr error;	InetAddress theResult;	error.addr.maxlen = sizeof(theResult);	error.addr.len = sizeof(theResult);	error.addr.buf = (unsigned char*)&theResult;	error.opt.maxlen = 0;	error.opt.len = 0;	error.opt.buf = nil;	OSStatus RcvErrErr = ::OTRcvUDErr(mEndpointRef,&error);	outRemoteAddress = theResult.fHost;	outRemotePort = theResult.fPort;	outError = error.error;}// ===========================================================================#pragma mark -#pragma mark === acknowledgement of sent data// ---------------------------------------------------------------------------//		е AckSends// ---------------------------------------------------------------------------voidCTurboUDPEndpoint::AckSends(){	ThrowIfError_(::OTAckSends(GetEndpointRef()));}// ---------------------------------------------------------------------------//		е DontAckSends// ---------------------------------------------------------------------------voidCTurboUDPEndpoint::DontAckSends(){	ThrowIfError_(::OTDontAckSends(GetEndpointRef()));}// ---------------------------------------------------------------------------//		е IsAckingSends// ---------------------------------------------------------------------------BooleanCTurboUDPEndpoint::IsAckingSends(){	return ::OTIsAckingSends(GetEndpointRef());}// ===========================================================================#pragma mark -#pragma mark === implementation details#pragma mark еее Turbo Extension еее// ---------------------------------------------------------------------------//		е CheckSharedPool()// ---------------------------------------------------------------------------//	Return the amount of Free memory in the shared pool as a debugging aidUInt32CTurboUDPEndpoint::CheckSharedPool(){	return mSharedPool->FreeMem();}// ---------------------------------------------------------------------------//		е StartAutoReceive()// ---------------------------------------------------------------------------voidCTurboUDPEndpoint::StartAutoReceive(LInterruptSafeList *inMessageQueue,						  LReentrantMemoryPool *inMemoryPool,						  UInt32 inReserve,						  UInt32 inMTU,						  void*  inRef){	mARQueue	= inMessageQueue;	mARPool		= inMemoryPool;	mReserve	= inReserve;	mMTU		= inMTU;	mRef		= inRef;	mIsAutoReceiving = true;}// ---------------------------------------------------------------------------//		е StopAutoReceive()// ---------------------------------------------------------------------------voidCTurboUDPEndpoint::StopAutoReceive(){	mARQueue	= nil;	mARPool		= nil;	mRef		= nil;	mIsAutoReceiving = false;}voidCTurboUDPEndpoint::ContinueAutoReceive(){	if (mWaitingDataOperation)	//Don't setup multiples		return;	StOpenTptOperation	operation(this, AR_DATA);	OTResult result = 0;	SInt16 limit = 0;	OTFlags flags = 0;	// try to read some data	result = Int_AutoReceiveFrom(&flags);	// if no data available	if (result == kOTNoDataErr) {		//swallow kOTNoDataErr and block thread		mWaitingDataOperation = &operation;		// only block if mARQueue is empty		if (mARQueue->IsEmpty()) {			try {				operation.WaitForCompletion();			} catch (...) {				mWaitingDataOperation = nil;				throw;			}				}		//if we are here, we didn't timeout so we must have gotten a 		//		T_DATA event, and have already read some data (or Q wasn't empty)		mWaitingDataOperation = nil;		return;	}	// Repeat until kOTNoDataErr or ARPool_Reserve exceeded	while (result == 0) {		result = Int_AutoReceiveFrom(&flags);		limit += 1;		if (limit > 500) break;		// defensive			}	// if any other error occured, throw an exception	if ((result != kOTNoDataErr) && (result != ARPool_Reserve)) {		Throw_(result);	}		}// ---------------------------------------------------------------------------//		е HandleAsyncEventSelf// ---------------------------------------------------------------------------//	Called by NotifyProc to handle notifications for this endpoint.//	You will be notified via a Broadcast at primary task time of the event if necessary.//	Warning: This routine will probably be called at interrupt time.voidCTurboUDPEndpoint::Int_HandleAsyncEventSelf(				OTEventCode		inEventCode,				OTResult		inResult,				void*			inCookie){	switch (inEventCode) {		//case T_EXDATA:		case T_DATA:			if (mIsAutoReceiving) {				OTResult result = 0;				SInt16 limit = 0;				OTFlags flags = 0;				// Repeat until kOTNoDataErr or ARPool_Reserve exceeded				while (result == 0) {					result = Int_AutoReceiveFrom(&flags);					limit += 1;					if (limit > 500) break;		// defensive				}				// if any other error occured, broadcast message to client				if ((result != kOTNoDataErr) && (result != ARPool_Reserve)) {					mMessageQueue->Append(new(*(mSharedPool)) LNetMessage(inEventCode, result, this));				}				if (mWaitingDataOperation)					mWaitingDataOperation->Int_AsyncResume(kOTNoError);			} else {    			mMessageQueue->Append(new(*mSharedPool) LDataArrived((MessageT) inEventCode, noErr, nil, 0, nil, false, this));    			if (mWaitingDataOperation)    				mWaitingDataOperation->Int_AsyncResume(kOTNoError);			}			break;		case kStreamIoctlEvent:		// handle Ioctl responses			mMessageQueue->Append(new(*(mSharedPool)) CNetMessage(inEventCode, inResult, inCookie, this));			if (mWaitingControlOperation)				mWaitingControlOperation->Int_AsyncResume(kOTNoError);			break;		case T_UDERR: {			UInt32		remoteAddress;			UInt16		remotePort;			SInt32		error;			ReceiveError(remoteAddress, remotePort, error);			mMessageQueue->Append(new(*mSharedPool) LICMPMessage(			                                                (MessageT)inEventCode, 															inResult, 															error, 															remoteAddress, 															remotePort, 															this));			}			break;		default:			mMessageQueue->Append(new(*(mSharedPool)) CNetMessage((MessageT)inEventCode, inResult, inCookie, this));			break;	}}// ---------------------------------------------------------------------------//		е Int_AutoReceiveFrom()// ---------------------------------------------------------------------------//	Process TDATA event.  May be called at interrupt time.ResultTCTurboUDPEndpoint::Int_AutoReceiveFrom(OTFlags* flags){	TUnitData data;	// check Auto Receive Pool against Reserve amount	if (mARPool->FreeMem() < mReserve) return ARPool_Reserve;		data.opt.maxlen = 0;	data.opt.len = 0;	data.opt.buf = nil;	data.addr.maxlen = sizeof(struct InetAddress);	data.addr.len = sizeof(struct InetAddress);	data.addr.buf = (unsigned char*) mARPool->NewPtrClear(data.addr.maxlen);  // *** use AR Pool	if (data.addr.buf == nil) return ARPool_Error;	data.udata.maxlen = data.udata.len = mMTU+8;	// *** use inMTU+8 to leave room for timeStamp	// if previous result was T_MORE try to allocate a larger buffer	if ((*flags & T_MORE) && (mARPool->FreeMem() > 1508)) {		data.udata.maxlen = data.udata.len = 1508;	}	data.udata.buf = (unsigned char*) mARPool->NewPtr(data.udata.maxlen);  // *** use AR Pool	if (data.udata.buf == nil) return ARPool_Error;		ResultT result = ::OTRcvUData(mEndpointRef, &data, flags);	while (result == kOTLookErr) {		TUDErr	error;		UInt8	addrBuf[sizeof(struct InetAddress)];		UInt8	optBuf[kOTFourByteOptionSize];				error.addr.maxlen = sizeof(struct InetAddress);		error.addr.len = sizeof(struct InetAddress);		error.addr.buf = addrBuf;				error.opt.maxlen = kOTFourByteOptionSize;		error.opt.len = 0;		error.opt.buf = optBuf;				OSStatus RcvErrErr = ::OTRcvUDErr(mEndpointRef,&error);				result = ::OTRcvUData(mEndpointRef,&data, flags);	}	if (result) {			mARPool->DisposePtr((char *)data.addr.buf);		// *** use AR Pool		mARPool->DisposePtr((char *)data.udata.buf);	// *** use AR Pool				// kOTNoDataErr means we're done, exit normally.		return result;	}	// add time stamp to end of message data	::OTGetTimeStamp( (OTTimeStamp*)(data.udata.buf+data.udata.len) );		// get the received from address if any and convert to PP address	CInternetAddress *remoteAddress = nil;	if (data.addr.len) {		remoteAddress = new(*mARPool) CInternetAddress(			((InetAddress*)data.addr.buf)->fHost,			((InetAddress*)data.addr.buf)->fPort );	}	// release addr buffer since it is no longer needed	mARPool->DisposePtr((char *)data.addr.buf);		// *** use AR Pool	// create data arrived message	LDataArrived* theMessage;	theMessage = new(*mARPool) LDataArrived(		*flags & T_EXPEDITED ? T_EXDATA : T_DATA,	// MessageT				inMessageType		result,										// ResultT				inResultCode		(void *)data.udata.buf,						// void*				inDataBuffer		data.udata.len,								// UInt32				inDataSize		remoteAddress,								// CInternetAddress*	inRemoteAddress		true,										// Boolean				inMustReleaseMemory		this);										// LEndpoint*			inEndpoint		if (theMessage == nil) {		mARPool->DisposePtr((char *)data.udata.buf);	// *** use AR Pool		if (remoteAddress != nil) delete remoteAddress;		return ARPool_Error;	}	// add message to AR Queue	mARQueue->Append(theMessage);	// Note you must release AR Pool memory by calling ReleaseAutoReceiveMessage() below	//	mARPool->DisposePtr((char *)data.udata.buf);	//	if (remoteAddress != nil) delete remoteAddress;	//	delete theMessage;		return result;	// no error}// ---------------------------------------------------------------------------//		е ReleaseAutoReceiveMessage()// ---------------------------------------------------------------------------//	Release Auto Receive MessagevoidCTurboUDPEndpoint::ReleaseAutoReceiveMessage(LDataArrived* inMessage){	CInternetAddress *remoteAddress;		mARPool->DisposePtr( (char *)inMessage->GetDataBuffer() );	remoteAddress = (CInternetAddress*)inMessage->GetRemoteAddress();	if (remoteAddress != nil) delete remoteAddress;	delete inMessage;}// ===========================================================================#pragma mark -#pragma mark ее Set Options// ---------------------------------------------------------------------------//		е SetIP_TTL()// ---------------------------------------------------------------------------//	Set Time To Live option for subsequent transmit datavoidCTurboUDPEndpoint::SetIP_TTL(UInt32 inTTL){	TOptMgmt    req;	TOption*	Opt;	UInt8 		OptionBuf[kOTFourByteOptionSize];						// define buffer for options, although we only						// use a "1 byte option", we define a "4 byte option"						// buffer to hold the returning options	// Point Opt to the start of buf.  This allows us to set the items in buf easily.	Opt = (TOption*)OptionBuf;	// Setup the fields of the options buffer...	Opt->level  = INET_IP;	Opt->name   = IP_TTL;	Opt->len    = kOTOneByteOptionSize;					// Note that kOTOneByteOptionSize != 1, it also					//  includes the size of the option header.		Opt->status = 0;	*(UInt8*)Opt->value = inTTL;	// Set up the req structure to denote the options we're requesting...	req.opt.buf = OptionBuf;	req.opt.len = kOTOneByteOptionSize;;	req.opt.maxlen = sizeof(OptionBuf);	req.flags   = T_NEGOTIATE;	DoOption(&req);}// ---------------------------------------------------------------------------//		е DoOption()// ---------------------------------------------------------------------------//	Do Option ManagementvoidCTurboUDPEndpoint::DoOption(TOptMgmt* cmd){	if (mWaitingControlOperation)	//Don't setup multiples		return;		StOpenTptOperation	operation(this, T_OPTMGMTCOMPLETE);	mWaitingControlOperation = &operation;		// save op so we can abort	ThrowIfError_(::OTOptionManagement(GetEndpointRef(), cmd, cmd));	operation.WaitForCompletion();	mWaitingControlOperation = nil;}// ---------------------------------------------------------------------------//		е Ioctl()// ---------------------------------------------------------------------------//	Perform Ioctl on endpointvoidCTurboUDPEndpoint::Ioctl(UInt32 inCmd, void* inData){	if (mWaitingControlOperation)	//Don't setup multiples		return;		StOpenTptOperation	operation(this, AR_DATA);	// pass-on kStreamIoctlEvent	mWaitingControlOperation = &operation;		// save op so we can abort	ThrowIfError_(::OTIoctl(GetEndpointRef(), inCmd, inData));	operation.WaitForCompletion();	mWaitingControlOperation = nil;}PP_End_Namespace_PowerPlant