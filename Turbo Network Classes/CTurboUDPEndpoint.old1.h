// ===========================================================================//	CTurboUDPEndpoint.h	 © 1996-97 Sustainable Softworks, All rights reserved.//	Includes//	LOpenTptUDPEndpoint.h			   © 1996 Metrowerks Inc. All rights reserved.// ===========================================================================#ifndef _H_CTurboUDPEndpoint#define _H_CTurboUDPEndpoint#pragma once#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import on#endif#include <LUDPEndpoint.h>#include <OpenTransport.h>#include <UOpenTptSupport.h>#include <LNetMessageQueue.h>#include <LSharedMemoryPool.h>enum {	AR_DATA			= kPRIVATEEVENT + 97,		// Private event so wait for completion						// will always call Int_HandleAsyncEventSelf()	ARPool_Reserve	= kPRIVATEEVENT + 98,		// Auto Receive Pool reserve exceeded	ARPool_Error	= kPRIVATEEVENT + 99		// Auto Receive Pool allocation failed};// ===========================================================================//		¥ CTurboUDPEndpoint// ===========================================================================//	Subclass of LOpenTptUDPEndpoint that creates an ICMP endpoint.////	The Turbo extension is designed to work around the inherent//	performance limitation of doing all processing at primary task//	time, while keeping much of the elegance and simplicity of the//	PowerPlant networking design.////	This class adds an AutoReceive capability to improve performance.//	AutoReceive is designed to read endpoint data (TDATA) at interrupt time//	and queues a message containing the actual data to be processed//	at primary task time.  By handling TDATA events at interrupt//	time, we can continue receiving data without introducing the arbitrary//	latency of WaitNextEvent.  By modifying the Int_HandleAsyncEventSelf()//	method, you can respond to received data immediately.  In this//	instance we just note when the data was actually received by appending//	an OT timeStamp to the end of each message. ////	This class includes 4 new methods://		StartAutoReceive( inMessageQ, inMemoryPool, inMTU, inReserve, void* inRef)//		ContinueAutoReceive()//		ReleaseAutoReceiveMessage(inMessage)//		StopAutoReceive()////	To start auto receiving, you must specify a message Queue to receive//	data messages, and a memory pool for allocating the messages.//	"inReserve" specifies the minimum remaining pool space required//	to accept another message.  If less than this minimum remains,//	the endpoint will not call ::OTRcv to read the incoming data until//	you again call ContinueAutoReceive() and "inReserve" bytes is once//	again available.  By setting inReserve appropriately, you can prevent//	valid message data from being discarded due to pool allocation//	failures when your application doesn't get sufficient task time//	to keep up with incomming data.  inMTU specifies the maximum//	amount of data to transfer in a single read, thus placing an//	upper bound on the size of pool allocation requests.////	After calling StartAutoReceive, the endpoint is configured to//	call Int_HandleAsyncEventSelf() when it receives a T_DATA message.//	Int_HandleAsyncEventSelf() checks the pool for inReserve bytes//	available, allocates a message buffer of size inMTU+8, calls//	::OTRcv to read up to inMTU bytes, and then tries to create//	an LDataArrived message from the pool and place it on the//	messageQ.////	ContinueAutoReceive() will read any data available on the endpoint//	placing it on the inMessageQ as needed.  If no data is available,//	it will put the calling thread to sleep while waiting.//	[operation.WaitForCompletion()].  Upon return from ContinueAutoReceive(),//	the caller should handle any messages in the inMessageQ supplied//	to StartAutoReceive(), release each message when done by calling//	ReleaseAutoReceiveMessage(), and call ContinueAutoReceive()//	again to have the caller wait for more data.  Note that if the memory//	pool reserve is exceeded, it is this subsequent call to ContinueAutoReceive()//	that will restart receiving.////	StopAutoReceive() tells the endpoint to stop using the inMessageQ//	and inMemoryPool to handle incoming data (stop calling ::OTRcv for//	TDATA events).  After calling StopAutoReceive(), it is safe for the//	caller to delete the inMessageQ and inMemoryPool objects.////	Finally, the inRef parameter to StartAutoReceive() lets you pass a//	pointer to data or an object to be used for processing incoming//	data (in a derived class with your own Int_HandleAsyncEventSelf()//	for example).// ===========================================================================//		¥ LMacTCPTCPEndpoint// ===========================================================================//	An implementation of LTCPEndpoint that communicates with MacTCP.//	We recommend that you do not make a subclass of this class.class CTurboUDPEndpoint :		public LUDPEndpoint,								public LOpenTptNotifHandler{public:								CTurboUDPEndpoint(char* inConfig);								~CTurboUDPEndpoint();									virtual void				Bind(										LInternetAddress&		inLocalAddress,										UInt32					inListenQueueSize = 0,										Boolean					inReusePort = true);	virtual void				Unbind();	virtual LInternetAddress*	GetLocalAddress();	virtual void				SendPacketData(										LInternetAddress&		inRemoteHost,										void*					inData,										UInt32					inDataSize);	virtual void				ReceiveFrom(										LInternetAddress&		outRemoteAddress,										void*					outDataBuffer,										UInt32&					ioDataSize,										UInt32					inTimeoutSeconds = Timeout_None);	virtual void				ReceiveError(										UInt32&					outRemoteAddress,										UInt16&					outRemotePort,										SInt32&					outError);	// connection status	virtual EEndpointState		GetState();	// acknowledgement of sent data		virtual void				AckSends();	virtual void				DontAckSends();	virtual Boolean				IsAckingSends();		void						AbortThreadOperation(LThread * inThread);	// Turbo extensions	UInt32 CheckSharedPool();	void StartAutoReceive(LInterruptSafeList *inMessageQueue,						  LReentrantMemoryPool *inMemoryPool,						  UInt32 inReserve,						  UInt32 inMTU,						  void*  inRef);	void ContinueAutoReceive();	void StopAutoReceive();	void ReleaseAutoReceiveMessage(LDataArrived* inMessage);				void SetIP_RCVIFADDR(UInt32 inValue);	void SetIP_TTL(UInt32 inTTL);	void DoOption(TOptMgmt* cmd);	void Ioctl(UInt32 inCmd, void* inData);	inline const EndpointRef	GetEndpointRef()	// [PAS] make this public									{										return mEndpointRef;									}protected:		void					Int_HandleAsyncEventSelf(									OTEventCode		inEventCode,									OTResult		inResult,									void*			inCookie);		inline const TEndpointInfo&	GetEndpointInfo()									{										return mEndpointInfo;									}	EndpointRef				mEndpointRef;				// Open Transport endpoint object	TEndpointInfo			mEndpointInfo;				// info obtained when endpoint was opened	LInternetAddress *		mLocalAddress;		LNetMessageQueue *		mMessageQueue;	LSharedMemoryPool * 	mSharedPool;		StOpenTptOperation *	mWaitingDataOperation;	// Turbo extensions	ResultT					Int_AutoReceiveFrom();	StOpenTptOperation *	mWaitingControlOperation;		// allow separate control opsprivate:	// Turbo extensions	LInterruptSafeList*		mARQueue;		// AutoReceive message Q	LReentrantMemoryPool*	mARPool;		// AutoReceive memory pool	UInt32					mReserve;	UInt32					mMTU;	void*					mRef;	Boolean					mIsAutoReceiving;};#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import reset#endif#endif