// ===========================================================================//	CTurboTCPEndpoint.cp	й 1997 Sustainable Softworks. All rights reserved.// ===========================================================================//	Subclass of LOpenTptTCPEndpoint that supports I_STR Ioctls,//	OTPutMessage, and OTGetMessage.//	Add flag to test for provider is closing before message is delivered.#include "CTurboTCPEndpoint.h"// ===========================================================================#pragma mark еее CTurboTCPEndpoint еее// ---------------------------------------------------------------------------//		е CTurboTCPEndpoint()// ---------------------------------------------------------------------------//	ConstructorCTurboTCPEndpoint::CTurboTCPEndpoint()	: LOpenTptTCPEndpoint(){	mProviderIsClosing = false;}// ---------------------------------------------------------------------------//		е ~CTurboTCPEndpoint()// ---------------------------------------------------------------------------//	DestructoCTurboTCPEndpoint::~CTurboTCPEndpoint(){}// ---------------------------------------------------------------------------//		е Ioctl()// ---------------------------------------------------------------------------//	Perform Ioctl on endpointOTResultCTurboTCPEndpoint::Ioctl(UInt32 inCmd, void* inData){	StOpenTptOperation	operation(this,  kStreamIoctlEvent);	ThrowIfError_(::OTIoctl(GetEndpointRef(), inCmd, inData));	operation.WaitForCompletion();	return operation.GetResultCode();}// ---------------------------------------------------------------------------//		е PutMessage()// ---------------------------------------------------------------------------//	Put a single message to a STREAMOTResultCTurboTCPEndpoint::PutMessage(TNetbuf* ctlbuf, TNetbuf* databuf, OTFlags flags){	OTResult	result;	//	StOpenTptOperation	operation(this,  kStreamIoctlEvent);//	ThrowIfError_(::OTPutMessage(GetEndpointRef(), (strbuf*)ctlbuf, (strbuf*)databuf, flags));//	operation.WaitForCompletion();//	return operation.GetResultCode();	result = ::OTPutMessage(GetEndpointRef(), (strbuf*)ctlbuf, (strbuf*)databuf, flags);	return result;}// ---------------------------------------------------------------------------//		е GetMessage()// ---------------------------------------------------------------------------//	Get a single message from a STREAMOTResultCTurboTCPEndpoint::GetMessage(TNetbuf* ctlbuf, TNetbuf* databuf, OTFlags* outFlags){	StOpenTptOperation	operation(this,  kGetmsgEvent);	ThrowIfError_(::OTGetMessage(GetEndpointRef(), (strbuf*)ctlbuf, (strbuf*)databuf, outFlags));	operation.WaitForCompletion();	return operation.GetResultCode();}// ---------------------------------------------------------------------------//		е HandleAsyncEventSelf// ---------------------------------------------------------------------------//	Called by NotifyProc to handle notifications for this endpoint.//	You will be notified via a Broadcast at primary task time of the event if necessary.//	Warning: This routine will probably be called at interrupt time.voidCTurboTCPEndpoint::Int_HandleAsyncEventSelf(				OTEventCode		inEventCode,				OTResult		inResult,				void*			inCookie){	switch (inEventCode) {		case T_DISCONNECT:			if (mOpenPending) {				mOpenPending = false;				Int_HandleAsyncEvent(T_CONNECT, kOTCanceledErr, inCookie);			} else {				mReceivedDisconnect = inEventCode;				mMessageQueue->Append(new(*mSharedPool) LNetMessage(inEventCode, inResult, this));				if (mWaitingDataOperation)					mWaitingDataOperation->Int_AsyncResume(Disconnect_Error);			}			break;					case T_DISCONNECTCOMPLETE:			mMessageQueue->Append(new(*mSharedPool) LNetMessage(inEventCode, inResult, this));			if (mWaitingDataOperation)				mWaitingDataOperation->Int_AsyncResume(Disconnect_Error);			break;		case T_ORDREL:			mReceivedDisconnect = inEventCode;			mMessageQueue->Append(new(*mSharedPool) LNetMessage(inEventCode, inResult, this));			if (mWaitingDataOperation)				mWaitingDataOperation->Int_AsyncResume(OrderlyDisconnect_Error);			break;		case T_DATA:			mMessageQueue->Append(new(*mSharedPool) LDataArrived(inEventCode, noErr, nil, 0, nil, false, this));			if (mWaitingDataOperation)				mWaitingDataOperation->Int_AsyncResume(kOTNoError);			break;		case T_MEMORYRELEASED:			mMessageQueue->Append(new(*mSharedPool) LMemoryReleasedMsg(inEventCode, kOTNoError, inCookie, inResult, this));		case kOTProviderWillClose:			mProviderIsClosing = true;		// set flag so we can test before message is delivered			mMessageQueue->Append(new(*(mSharedPool)) LNetMessage(inEventCode, inResult, this));			break;		default:			mMessageQueue->Append(new(*(mSharedPool)) LNetMessage(inEventCode, inResult, this));	}}